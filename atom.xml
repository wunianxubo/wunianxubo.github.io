<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wunian&#39;s Blog</title>
  <subtitle>清风徐来，水波不兴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-13T08:21:53.160Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xu Bo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/08/13/synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E5%92%8C%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2017/08/13/synchronized的实现原理及锁的升级和对比/</id>
    <published>2017-08-13T08:13:38.216Z</published>
    <updated>2017-08-13T08:21:53.160Z</updated>
    
    <content type="html"><![CDATA[<p>title: synchronized的实现原理及锁的升级和对比<br>date: 2017-08-13 16:14:00<br>tags: [java,java并发]    </p>
<h2 id="categories-java"><a href="#categories-java" class="headerlink" title="categories: java "></a>categories: java </h2><h1 id="一、synchronized的实现原理"><a href="#一、synchronized的实现原理" class="headerlink" title="一、synchronized的实现原理"></a>一、synchronized的实现原理</h1><p>Java中的每一个对象都可以作为锁，有三种形式：<br><strong>1、对于普通同步方法，锁是当前实例对象。<br>2、对于静态同步方法，锁是当前类的Class对象。<br>3、对于同步代码块，锁是Synchronized括号中配置的对象.</strong>   </p>
<p>由JVM规范，<strong>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步</strong>，但两者实现细节不一样。<br><strong>1、代码块同步是使用monitorenter和monitorexit指令实现的。<br>2、方法同步则是依靠方法修饰符上的ACC_SYNCHRONIZED实现</strong>。  </p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>&emsp;&emsp;monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。<strong>任何一个对象都有一个monitor与之关联。当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</strong><br>&emsp;&emsp;<strong>而synchronized用的锁是存放在Java对象头中的。</strong></p>
<h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>HotSpot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。  </p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><strong>对象头包括两部分：Mark Word 和 类型指针</strong>。</p>
<h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p>&emsp;&emsp;<strong>Mark Word用于存储对象自身的运行时数据，如哈希吗（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</strong>等，占用的内存大小和虚拟机的位长一致。  </p>
<h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>&emsp;&emsp;<strong>类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例。</strong>  </p>
<p>&emsp;&emsp;在对象处于未被锁定的情况下，mark word的32bit空间中有25bit存储对象的哈希吗、4bit存储对象的分代年龄、2bit存储锁的标记位、1bit固定为0。</p>
<h1 id="锁的升级和对比"><a href="#锁的升级和对比" class="headerlink" title="锁的升级和对比"></a>锁的升级和对比</h1><p>&emsp;&emsp;为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，锁共有四种状态：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</strong>  </p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>&emsp;&emsp;大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低引入了偏向锁。<br>&emsp;&emsp;<strong>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要一次CAS原子指令来置换线程ID</strong>。<br><strong>（1）偏向锁的获取</strong><br>1、通过 markOop mark = obj-&gt;mark() 获取对象的markOop数据mark，即对象头的Mark Word；<br>2、判断mark是否为可偏向状态，即Mark的偏向锁标志位为1，锁标志位为01；<br>3、判断mark中Java Thread的状态：如果为空，则进入步骤4；如果指向当前线程，则执行同步代码块；如果指向其它线程，进入步骤5；<br>4、通过CAS原子指令设置mark中Java Thread为当前线程ID，如果执行CAS成功，则执行同步代码块，否则进入步骤5；<br>5、如果CAS执行失败，表示当前存在多个线程竞争锁，当达到全局安全点（safepoint），获得偏向锁的线程被挂起，撤销偏向锁，并升级为轻量级锁，升级完成后被阻塞在安全点的线程继续执行同步代码块。<br><strong>（2）偏向锁的撤销</strong><br>①偏向锁使用了一种等到竞争出现才会释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>②偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。<br>③暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。<br>④如果线程不处于活动状态，则将对象头设置成无锁状态；撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。<br><strong>（3）偏向锁的关闭</strong><br>偏向锁默认开启，但会在应用程序启动几秒后才激活。使用JVM参数关闭延迟：-XX：BiasedLockingStartupDelay=0。如果确定应用程序里所有的锁通常都处于竞争状态下，通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序会默认进入轻量级锁状态。  </p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>&emsp;&emsp;<strong>引入轻量级锁的目的：</strong>在多线程<strong>交替执行</strong>同步块时，尽量避免重量级锁引起的性能消耗，<strong>但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级为重量级锁。</strong><br><strong>（1）轻量级锁的获取</strong><br>当关闭偏向锁功能，或多个线程竞争偏向锁导致偏向锁升级为轻量级锁时，会尝试去获取轻量级锁。<br>1、通过 markOop mark = obj-&gt;mark() 获取对象的markOop数据mark，即对象头的Mark Word；<br>2、通过mark-&gt;is_neutral()方法判断mark是否为无锁状态：mark的偏向锁标志位为0（偏向锁关闭），锁标志位为01（无锁状态）；<br>3、如果mark处于无锁状态，则进入步骤4，否则进入步骤6；<br>4、把mark（对象头的Mark Word）复制到锁记录中（线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，_displaced_header字段）；<br>5、通过CAS尝试将Mark Word更新为指向锁记录的指针，如果更新成功，表示竞争到锁，执行同步代码，否则执行步骤6；<br>6、如果当前mark处于加锁状态，并且mark中的ptr指针指向当前线程的栈帧，则执行同步代码，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁。  </p>
<p><strong>假设线程A和B同时执行到临界区</strong><br>1、线程A、B都把Mark Word复制到各自的锁记录（_displaced_header字段），该数据保存在线程的栈帧上，是线程私有的；<br>2、CAS操作保证只有一个线程可以将Mark Word更新为指向锁记录的指针，假设A执行成功，并返回继续执行同步代码块；<br>3、线程B的CAS操作失败，退出临界区，通过 ObjectSynchronizer::inflate方法开始膨胀锁。  </p>
<p><strong>（2）轻量级锁的解锁 </strong><br>轻量级锁解锁时，会使用CAS操作将锁记录中复制来的Mark Word重新替换回对象头。如果CAS成功，表示没有竞争发生，解锁成功；如果CAS失败，表示当前锁竞争存在，锁就会膨胀成重量级锁。  </p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>&emsp;&emsp;重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。<br>&emsp;&emsp;<strong>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。</strong> 在这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后才会唤醒这些线程，被唤醒的线程就会进行新的一轮夺锁之争。  </p>
<h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳米级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间，同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较长</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;title: synchronized的实现原理及锁的升级和对比&lt;br&gt;date: 2017-08-13 16:14:00&lt;br&gt;tags: [java,java并发]    &lt;/p&gt;
&lt;h2 id=&quot;categories-java&quot;&gt;&lt;a href=&quot;#categorie
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>原子操作及CAS算法</title>
    <link href="http://yoursite.com/2017/08/12/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8F%8ACAS%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/08/12/原子操作及CAS算法/</id>
    <published>2017-08-12T13:48:04.000Z</published>
    <updated>2017-08-12T13:51:39.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、原子操作的实现原理"><a href="#一、原子操作的实现原理" class="headerlink" title="一、原子操作的实现原理"></a>一、原子操作的实现原理</h1><h2 id="处理器如何实现原子操作"><a href="#处理器如何实现原子操作" class="headerlink" title="处理器如何实现原子操作"></a>处理器如何实现原子操作</h2><p><strong>1. 使用总线锁保证原子性</strong><br>&emsp;&emsp;<strong>总线锁</strong>就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，这样，该处理器就可以独占共享内存。<br><strong>2. 使用缓存锁保证原子性</strong><br>&emsp;&emsp;在同一时刻，我们只需要保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，使得在锁定期间，其他的处理器不能操作其他内存地址的数据，所以总线锁定开销较大，在某些场合用缓存锁代替总线锁。<br>&emsp;&emsp;<strong>缓存锁定</strong>是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，<strong>因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</strong>  </p>
<h2 id="Java如何实现原子操作"><a href="#Java如何实现原子操作" class="headerlink" title="Java如何实现原子操作"></a>Java如何实现原子操作</h2><p>&emsp;&emsp;Java中可以通过<strong>循环CAS</strong>和<strong>锁</strong>的方式来实现原子操作。<br><strong>1. 使用循环CAS实现原子操</strong><br>&emsp;&emsp;JVM中的CAS操作是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作，所以能保证原子操作的实现。<br><strong>2. 使用锁机制实现原子操作</strong><br>&emsp;&emsp;锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。<strong>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</strong>  </p>
<h1 id="二、CAS算法剖析"><a href="#二、CAS算法剖析" class="headerlink" title="二、CAS算法剖析"></a>二、CAS算法剖析</h1><p>&emsp;&emsp;<strong>CAS(Compare And Swap)，即比较并替换。三个操作数：内存值V，预估值A，更新值B，当且仅当V==A时，V=B。CAS的比较和替换是一组原子操作，不会被外部打断，属于硬件级别的操作，效率比加锁高</strong> </p>
<h2 id="AtomicInteger为例："><a href="#AtomicInteger为例：" class="headerlink" title="AtomicInteger为例："></a><strong>AtomicInteger为例：</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class AtomicInteger extends Number implements java.io.Serializable&#123;</div><div class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">    private static final long valueOffset;</div><div class="line">    static&#123;</div><div class="line">        valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(&quot;value&quot;))</div><div class="line">    &#125;</div><div class="line">    private volatile int value;</div><div class="line">    public final int get()&#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>①<strong>Unsafe</strong>是CAS的核心类，它提供了<strong>硬件级别的原子操作</strong>。<br>②<strong>valueOffset</strong>表示变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址来获取数据的原值的。<br>③<strong>value</strong>是用<strong>volatile</strong>修饰的，保证了value的可见性。  </p>
<p>AtomicInteger在并发下的累加操作过程：<br>&emsp;&emsp;在jdk1.8中，比较和替换操作放在Unsafe类中实现。假设线程A和B同时执行getAndAdd操作：  </p>
<ol>
<li>AtomicInteger中的value值为3，即内存中value为3，根据Java内存模型，线程A和B各持有一份value的副本，值为3.</li>
<li>线程A通过getIntVolatile(var1,var2)方法获取value值为3，此时线程切换，线程A挂起。</li>
<li>线程B通过getIntVolatile(var1,var2)方法获取value值为3，并利用<strong>compareAndSwapInt</strong>方法比较和替换，修改内存值为4，线程切换，线程B挂起。</li>
<li>线程A恢复，利用<strong>compareAndSwapInt</strong>方法比较，发现手中的值3和内存值4不一致，此时value正在被另一个线程修改，线程A不能修改value值。</li>
<li>线程的<strong>compareAndSwapInt</strong>实现，循环判断，重新获取value的值，value为volatile修饰变量，其他线程的修改，线程A总是能看到。直到<strong>compareAndSwapInt</strong>修改成功并返回true。 </li>
</ol>
<p>&emsp;&emsp;<strong>整个过程中，使用CAS保证了value修改的线程安全性。</strong>  </p>
<h3 id="compareAndSwapInt方法："><a href="#compareAndSwapInt方法：" class="headerlink" title="compareAndSwapInt方法："></a>compareAndSwapInt方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public final native boolean compareAndSwapInt(...)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;<strong>compareAndSwapInt是一个本地方法的调用，会根据处理器的类型来决定是否为CMPXCHG指令添加lock前缀。</strong>多处理器，为CMPXCHG指令添加lock前缀；单处理器则省略lock前缀（不需为单处理器提供内存屏障效果）。  </p>
<h3 id="lock前缀："><a href="#lock前缀：" class="headerlink" title="lock前缀："></a>lock前缀：</h3><p>&emsp;&emsp;lock前缀的指令<strong>在多核处理器下</strong>会引发两件事：</p>
<ol>
<li><strong>将当前处理器缓存行的数据写回到系统内存。</strong></li>
<li><strong>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</strong>  </li>
</ol>
<h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><p><strong>（1）ABA问题</strong><br>&emsp;&emsp;CAS在操作值的时候，需要检查值有没有发生变化，如果没有变化则更新。但如果一个值原来是A，变成了B，最后又变成A，那么使用CAS检查变化时会发现他的值没有发生变化，而实际上却变化了。<br><strong>解决方法：在变量前面加上版本号，每次变量更新时把版本号加1，那么A-&gt;B-&gt;C变成1A-&gt;2B-&gt;3A,在Atomic里提供了一个类AtomicStampedReference</strong>来解决ABA问题。<br><strong>（2）循环时间长开销大</strong><br>&emsp;&emsp;自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。<br><strong>（3）只能保证一个共享变量的原子操作</strong><br>&emsp;&emsp;当对一个共享变量执行操作时，可以使用循环CAS的方式保证原子操作，但对多个共享变量操作时，循环CAS就不能保证操作的原子性，这时候可以用锁。<strong>jdk提供AtomicReference保证了引用之间的原子性，就可以把多个变量放在一个对象里进行CAS操作。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、原子操作的实现原理&quot;&gt;&lt;a href=&quot;#一、原子操作的实现原理&quot; class=&quot;headerlink&quot; title=&quot;一、原子操作的实现原理&quot;&gt;&lt;/a&gt;一、原子操作的实现原理&lt;/h1&gt;&lt;h2 id=&quot;处理器如何实现原子操作&quot;&gt;&lt;a href=&quot;#处理器如何实
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析volatile</title>
    <link href="http://yoursite.com/2017/08/11/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90volatile/"/>
    <id>http://yoursite.com/2017/08/11/深入剖析volatile/</id>
    <published>2017-08-11T12:16:04.000Z</published>
    <updated>2017-08-11T14:45:27.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、volatile的性质"><a href="#一、volatile的性质" class="headerlink" title="一、volatile的性质"></a>一、volatile的性质</h1><h2 id="1、volatile保证可见性"><a href="#1、volatile保证可见性" class="headerlink" title="1、volatile保证可见性"></a>1、volatile保证可见性</h2><ol>
<li>volatile关键字保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对于其他线程来说是立即可见的。</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//线程1</div><div class="line">boolean stop =false;</div><div class="line">while(!stop)</div><div class="line">  doSomething();</div><div class="line"></div><div class="line">//线程2</div><div class="line">stop=true;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;上面的代码，可能导致无法中断线程。当线程2更改了stop变量的值后，还没来得及写入内存中，线程2就转去做其他事情了，线程1由于不知道线程2对stop变量的修改，会一直循环下去。<br>&emsp;&emsp;使用volatile修饰后，发生变化：<br>第一：使用volatile会强制将修改的值写入主内存。<br>第二：使用volatile的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效。<br>第三：由于线程1的工作内存中的缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主内存读取。  </p>
<h2 id="2、volatile保证有序性"><a href="#2、volatile保证有序性" class="headerlink" title="2、volatile保证有序性"></a>2、volatile保证有序性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//x、y不是volatile变量</div><div class="line">//flag为volatile变量</div><div class="line">x=2;            //语句1</div><div class="line">y=0;            //语句2</div><div class="line">flag=true;      //语句3</div><div class="line">x=4;            //语句4</div><div class="line">y=-1            //语句5</div></pre></td></tr></table></figure>
<p>①由于flag为volatile变量，在进行指令重排序时，不会将语句3放到语句1、2前面，也不会将语句3放到语句4、5的后面，但是语句1、2的顺序，语句4、5的执行顺序是不做任何保证的。<br>②并且volatile保证：执行到语句3时，语句1、2必定是执行完毕类的，而且语句1、2的执行结果对语句3、4、5是可见的。  </p>
<h2 id="3、volatile不能保证原子性"><a href="#3、volatile不能保证原子性" class="headerlink" title="3、volatile不能保证原子性"></a>3、volatile不能保证原子性</h2><p>&emsp;&emsp;原子性：即一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>&emsp;&emsp;可以通过synchronized或Lock进行加锁，来保证操作的原子性。也可以通过使用java.util.concurrent.atomic包下提供的原子操作类（对基本数据类型的一些操作进行了封装）来实现。<br>&emsp;&emsp;atomic是利用CAS（Compare And Swap）来实现原子性操作的，CAS实际上利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性的操作。  </p>
<h2 id="4、volatile的应用场景"><a href="#4、volatile的应用场景" class="headerlink" title="4、volatile的应用场景"></a>4、volatile的应用场景</h2><p>&emsp;&emsp;相较于synchronized，volatile是较为轻量级的同步策略，使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但volatile无法代替synchronized，因为volatile无法保证操作的原子性。<br>&emsp;&emsp;使用volatile的两个条件：<br>1、对变量的写操作不依赖于当前值<br>2、 该变量没有包含在具有其他变量的不变式中  </p>
<h1 id="二、volatile的实现原理"><a href="#二、volatile的实现原理" class="headerlink" title="二、volatile的实现原理"></a>二、volatile的实现原理</h1><h2 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h2><p>&emsp;&emsp;处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据读到内部缓存后再进行操作，但操作完后不知道何时才会写到内存中。<br>&emsp;&emsp;对声明了volatile变量进行写操作时，<strong>JVM会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。</strong>这一步确保了如果有其他线程对声明了volatile的变量进行修改时，则立即更新主内存中的数据。<br>&emsp;&emsp;但此时其他处理器的缓存的数据还是旧数据，<strong>所以在多处理器的环境下，为了保证各个处理器的缓存一致，每个处理器会通过嗅探在总线上传播的数据来检查自己的缓存是否过期。当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个数据进行修改时，会强制重新从系统内存把数据读到处理器缓存里。</strong>这一步确保了其他线程获得的声明了volatile的变量都是从主内存中获取的最新的。  </p>
<h2 id="2、有序性"><a href="#2、有序性" class="headerlink" title="2、有序性"></a>2、有序性</h2><p>&emsp;&emsp;Lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障之后的位置，即在执行到内存屏障这句指令时，在它之前的操作已经全部完成。</p>
<h2 id="3、Lock前缀指令"><a href="#3、Lock前缀指令" class="headerlink" title="3、Lock前缀指令"></a>3、Lock前缀指令</h2><p>在多处理器下会引发两件事：<br>①将当前处理器缓存行的数据写回到系统内存。<br>②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、volatile的性质&quot;&gt;&lt;a href=&quot;#一、volatile的性质&quot; class=&quot;headerlink&quot; title=&quot;一、volatile的性质&quot;&gt;&lt;/a&gt;一、volatile的性质&lt;/h1&gt;&lt;h2 id=&quot;1、volatile保证可见性&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出多线程</title>
    <link href="http://yoursite.com/2017/07/08/Java%E5%9F%BA%E7%A1%80---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/07/08/Java基础---深入浅出多线程/</id>
    <published>2017-07-08T09:12:55.000Z</published>
    <updated>2017-07-20T13:53:08.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、多线程的引入"><a href="#1、多线程的引入" class="headerlink" title="1、多线程的引入"></a><strong>1、多线程的引入</strong></h2><p>  多线程的相关内容是Java基础中非常重要的一部分，这两天对这部分知识进行了梳理，以达到复习和查漏补缺的目的。<br>  首先，多线程指的是在单个程序中可以同时运行多个不同的线程执行不同的任务，多线程编程的目的其实就是“最大限度地利用CPU资源”，我们接下来介绍下进程/程序/线程之间有什么区别和联系。</p>
<p> <strong>1. 进程与程序的区别是什么呢？</strong><br> （1）程序是长期存在的，进程是暂时的，是程序在数据集上的一次运行，有创建有撤销，存在是暂时的<br> （2）程序是静态的观念，进程是动态的观念<br> （3）进程具有并发性，而程序没有<br> （4） 进程是竞争计算机资源的基本单位，程序不是<br> （5）进程和程序不是一一对应的，一个程序可对应多个进程即多个进程可执行同一程序，一个进程可以执行一个或多个程序<br> <strong>2. 进程和线程又有什么区别呢？</strong><br> 线程是指进程内的一个执行单元，也是进程内的可调度实体。与进程的区别：<br> （1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位<br> （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行<br> （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源<br> （4）系统开销：在创建和撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建和撤销线程时的开销</p>
<h2 id="2、创建线程的两种方式"><a href="#2、创建线程的两种方式" class="headerlink" title="2、创建线程的两种方式"></a><strong>2、创建线程的两种方式</strong></h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a><strong>继承Thread类</strong></h3><ul>
<li>定义一个类去继承Thread</li>
<li>重写run方法</li>
<li>创建子类对象，就是创建线程对象</li>
<li><p>调用start方法，开启线程并让线程执行，同时告诉jvm去调用run方法</p>
<p>几个小问题：<br><strong>1.  线程对象调用run()方法和调用start()方法有什么区别</strong><br>调用run()方法不开启线程，仅仅是线程调用方法。调用start()方法开启线程，并让jvm调用run方法，在开启的线程中执行。<br><strong>2. 为什么要继承Thread类？</strong><br>因为Thread类描述线程事务，具备线程应有功能。<br><strong>3. 为什么不直接创建Thread类的对象呢？</strong><br>这么做start()调用的是Thread类中的run方法，此方法内部为空，不做任何事情，没有我们需要让线程执行的代码。</p>
<p> 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间，进行方法的压栈和弹栈。当执行线程的任务结束了，线程自动在栈内存中释放；当所有的执行线程都结束了，进程也就结束了。</p>
</li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a><strong>实现Runnable接口</strong></h3><ul>
<li>定义一个类来实现Runnable接口</li>
<li>覆盖接口中的run方法，将线程任务代码定义到run方法中</li>
<li>创建Thread类的对象（只有创建Thread对象，才能创建线程。）</li>
<li>将Runnable接口的子类对象作为参数传递给Thread类的构造函数</li>
<li>调用Thread类的start()方法开启线程</li>
</ul>
<p>Thread源码调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Thread&#123;</div><div class="line">	private Runnable target;</div><div class="line">	Thread(Runnable target)&#123;</div><div class="line">		this.target = target;</div><div class="line">		&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		if(target != null)&#123;</div><div class="line">			target.run();</div><div class="line">		&#125;</div><div class="line">	public void start()&#123;</div><div class="line">			run();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Runnable d = new Demo();</div><div class="line">Thread t = new Thread(d);</div><div class="line">t.start();</div></pre></td></tr></table></figure>
<p><strong>1. 为什么将Runnable接口的子类对象作为参数传递给Thread类的构造函数？</strong><br>   结合上面的Thread源码，我们不难看出，因为线程任务已被封装到Runnable接口的run()方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要执行的线程任务了。</p>
<p><strong>2.  实现Runnable接口的方式较继承Thread的方式有何优势？</strong><br>  1、实现Runnable接口避免了单继承的局限性<br>  2、实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分是线程对象，一部分是线程任务。<br>  继承Thread类：线程对象和线程任务耦合在一起，一旦创建Thread类的子类对象，既是线程对象，又有线程任务<br>  实现Runnable接口：将线程任务单独分离出来，封装成对象，类型就是Runnable接口类型，Runnable接口对线程对象和线程任务进行了解耦</p>
<h2 id="3、多线程的安全问题"><a href="#3、多线程的安全问题" class="headerlink" title="3、多线程的安全问题"></a><strong>3、多线程的安全问题</strong></h2><p>  线程安全问题产生的原因：<br>  <strong>1、多个线程在操作共享的数据</strong><br>  <strong>2、线程任务操作共享数据的代码有多条（有多次运算）</strong><br>  解决思路：只要让一个线程在执行线程任务时，将多条操作共享数据的代码执行完，在执行过程中，不要让其他线程参与运算。</p>
<p>使用同步synchronized：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized(锁对象)&#123;</div><div class="line"></div><div class="line">	//需要被同步的代码...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  考虑到大家对synchronized锁可能很难理解，我做个比较形象的比喻来方便大家理解：使用同步时会用到锁，这就好比是<strong>在火车上上厕所</strong>。这又从何说起呢？<br>   <strong>火车上有个人想上厕所时，会去拿锁进入厕所并关上门，此时其他人拿不到锁是进不了厕所的。当这个人上完厕所后，离开厕所的同时释放了锁，那么其他人都具有同等的机会来竞相拿到锁进入厕所。</strong>这就好比一个线程拿到锁，此时其他线程无法进入同步代码块或者同步函数执行代码，当一个线程执行完后释放锁，其他线程争相获得cpu的执行权，以此来获得锁进入同步代码块执行代码。希望这个例子能给大家一些启发。</p>
<p>同步代码块的好处：解决了多线程的安全问题<br>同步弊端：降低了程序的性能（很多线程访问，每次访问都需要判断锁，做了很多无用功）；当线程任务中出现了多个同步（多个锁）时，如果同步嵌套了其他的同步，这时候容易引发死锁。<br><strong>同步前提：必须保证多个线程在同步中使用的是同一个锁。（也以此前提来判断同步是否书写正确）</strong></p>
<p><strong>同步代码块与同步函数的区别？</strong><br>1、同步函数使用的锁是固定的this；同步代码块使用的锁可以是任意对象<br>2、当线程任务只需要一个同步时，完全可以使用同步函数；当线程任务中需要多个同步时，必须通过锁来区分，这时候必须使用同步代码块<br>注：static同步函数使用的锁不是this，而是字节码文件对象，类名.class</p>
<h2 id="4、多线程间的通信"><a href="#4、多线程间的通信" class="headerlink" title="4、多线程间的通信"></a><strong>4、多线程间的通信</strong></h2><p>多线程间最为常见的应用案例：生产者消费者问题，具体说来就是：生产和消费同时进行，需要多线程，但是执行的任务却不相同，处理的资源确实相同的。在生产者生产了商品后应该告诉消费者进行消费，这时的生产者需要处于等待状态；消费者在消费了商品后应该告诉生产者进行生产，这时消费者需要处于等待状态。</p>
<p>  <strong>生产一个消费一个的情况</strong>：生产者生产面包，判断盘子中是否有面包，有的话生产者进入等待状态；没有的话将生产后的面包放于盘子中，唤醒消费者进行消费。如果盘子中没有面包，消费者就进入等待状态；如果盘子中有面包，那么消费者消费，同时唤醒生产者进行生产。以下为具体代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">class Resource&#123;</div><div class="line">	private String name;</div><div class="line">	private int count = 1;</div><div class="line">	//定义标记flag</div><div class="line">	private boolean flag = false;</div><div class="line">    //生产者生产行为</div><div class="line">	public synchronized void set(String name)&#123;</div><div class="line">		//如果flag为true,说明盘子里有面包，不需要生产，生产者进入等待模式。</div><div class="line">		if(flag)</div><div class="line">			this.wait();</div><div class="line">		this.name = name + count;</div><div class="line">		count++;</div><div class="line">		System.out.println(&quot;...生产者...&quot;+this.name);</div><div class="line">		//完成生产，将标记改为true</div><div class="line">		flag = true;</div><div class="line">		//唤醒消费者</div><div class="line">		this.notify();	</div><div class="line">	&#125;</div><div class="line">	//消费者消费行为</div><div class="line">	public synchronized void out()&#123;</div><div class="line">		//如果flag为false,说明盘子里没有面包，消费不了，消费者者进入等待模式。</div><div class="line">		if(!flag)</div><div class="line">			this.wait();</div><div class="line">		System.out.println(&quot;...消费者...&quot;+this.name);</div><div class="line">		//完成消费，盘子里没有面包了，将标记改为false</div><div class="line">		flag = false;</div><div class="line">		//唤醒生产者</div><div class="line">		this.notify();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//描述生产者</div><div class="line">class Producer implements Runnable&#123;</div><div class="line">	private Resource r;</div><div class="line">	Producer(Resource r)&#123;</div><div class="line">		this.r = r;</div><div class="line">	&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		while(true)&#123;</div><div class="line">			r.set(&quot;面包&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//描述消费者</div><div class="line">class Consumer implements Runnable&#123;</div><div class="line">	private Resource r;</div><div class="line">	Consumer(Resource r)&#123;</div><div class="line">	this.r = r;</div><div class="line">	&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		r.out();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public class Tset1&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Resource r = new resource();</div><div class="line">		Producer pro = new Producer(r);</div><div class="line">		Consumer con = new Consumer(r);</div><div class="line">		Thread t1 = new Thread(pro);</div><div class="line">		Thread t2 = new Thread(con);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="等待-唤醒机制"><a href="#等待-唤醒机制" class="headerlink" title="等待/唤醒机制"></a><strong>等待/唤醒机制</strong></h3><p>wait()：会让线程处于等待状态，其实就是将线程临时存储到线程池中。<br>notify()：会让线程池中任意一个等待的线程唤醒。<br>notifyAll()：会唤醒线程池中所有的等待线程。<br><strong>记住：这些方法必须使用在同步中，因为必须要标识wait、notify等方法所属的锁，同一个锁上的notify只能唤醒该锁上被wait的线程。</strong></p>
<p><strong>多生产多消费的形式</strong>：多个生产者，多个消费者的情况，如果延用上面的代码则会遇到一下几个问题，具体大家可以自己实施下，无非是，多new几个生产者、消费者，多创建几个线程。</p>
<p><strong><em>问题一：部分生产了的商品没有被消费，同一个商品可能被消费多次</em></strong><br>原因：被唤醒的线程没有再次判断标记，造成问题的发生<br>解决：只要让被唤醒的线程重新再次去判断标记就可以了，将if判断标记的方式改为while判断标记的方式。<br><strong>记住：多生产多消费，必须是while判断语句。</strong></p>
<p><strong><em>问题二：改为while后，死锁了</em></strong><br>原因：生产方唤醒了线程池中生产方的线程（由于唤醒的是线程池中<strong>任意一个</strong>线程），唤醒后判断标记flag，发现为true进入等待状态，此时所有线程都进入等待状态，程序无法继续执行，死锁发生。<br>解决：希望本方唤醒对方，没有对应的方法，只能使用notifyAll的方法。</p>
<p>经过上面两步，我们解决了遇到的问题，但是这种方式最大的问题是，<strong>效率相对比较低</strong>，那我们有没有更好的解决方法呢？答案是肯定的！</p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a><strong>Lock接口</strong></h3><p>   Lock接口提供了更加面向对象的锁，在所中提供了更加显示的锁操作，我们可以通过lock()方法来获得锁，也可以用过unlock()方法来达到释放锁的目的，比同步更加厉害，可以用来替代synchronized。<br>   新锁（Lock）替代旧锁（synchronized），那么旧锁上的监视器方法（wait, notify, notifyAll）也在新锁上得到替换（await,  signal, signalAll）。在jdk1.5中，将这些原有的监视器方法封装到了一个Condition对象中，想要换取监视器的方法，就需要通过lock的newCondition方法获取Condition对象。通过使用新锁，我们可以在一个锁上创建多个监视器对象。<br>  下图为Lock与synchronized的对比：</p>
<p>  <img src="http://img.blog.csdn.net/20170320101442665?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Lock与synchronized对比"></p>
<p>下面我们使用新锁的方式，介绍一个<strong>生产多个消费多个</strong>的问题：一边在生产商品，将生产的放于容器中；另一边从容器中取商品消费。</p>
<p>   <img src="http://img.blog.csdn.net/20170320102244052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="多个消费多个生产模型"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Test2&#123;</div><div class="line">	final Lock lock = new ReentranLock();//锁</div><div class="line">	final Condition notFull = lock.newCondition();//生产</div><div class="line">	final Condition notEmpty = lock.newCondition();//消费</div><div class="line">	final Object[] items = new Object[20];//存储商品的容器</div><div class="line">	int putptr, takeptr, count;//生产者角标、消费者角标、计数器</div><div class="line">//往容器中存储商品</div><div class="line">public void put(Object x)throws InterruptException&#123;</div><div class="line">	lock.lock();//加锁</div><div class="line">	try&#123;</div><div class="line">		while(count == items.length)//判断计数器是否已到数组长度，满了生产就进入等待状态</div><div class="line">			notFull.await();</div><div class="line">		items[putptr] = x;//按照角标存储商品</div><div class="line">		if(++putptr == items.length)//存储角标到达数组长度，角标归零，重新从头存储商品</div><div class="line">			putptr = 0;</div><div class="line">		++count;//计数器自增</div><div class="line">		notEmpty.signal();//唤醒消费者</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();//释放锁</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">public Object take()throws InterruptException&#123;</div><div class="line">	lock.lock();</div><div class="line">	try&#123;</div><div class="line">		while(count==0)</div><div class="line">			notEmpty.await();</div><div class="line">		Object x = items[takeptr];</div><div class="line">		if(++takeptr == items.length)</div><div class="line">			takeptr = 0;</div><div class="line">		--count;</div><div class="line">		notFull.signal();</div><div class="line">		return x;</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a><strong>线程的状态</strong></h3><p>线程状态图如下所示：<br><img src="http://img.blog.csdn.net/20170320105528467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程状态图"></p>
<h2 id="5、多线程的细节"><a href="#5、多线程的细节" class="headerlink" title="5、多线程的细节"></a><strong>5、多线程的细节</strong></h2><p><strong>1. sleep方法和wait方法的异同？</strong><br>相同点：都可以让线程处于冻结状态<br>不同点：<br>1，sleep必须指定时间；wait可指定时间，也可不指定时间<br>2，sleep时间到，线程处于临时阻塞或进行状态；wait如果没有时间，必须要通过notify或者notifyAll唤醒<br>3，sleep不一定非要定义在同步中；wait必须要定义在同步中<br>4，都定义在同步中时，线程执行到sleep不会释放锁；线程执行到wait会释放锁</p>
<p><strong>2. 线程如何停止呢？</strong><br>线程结束就是让线程任务执行完，run方法结束。在run方法中通常都定义循环，只要控制住循环就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Test3 implements Runnable&#123;</div><div class="line">	private boolean flag = true;</div><div class="line">	public void run()&#123;</div><div class="line">	while(flag)</div><div class="line">		System.out.println(Thread.currentThread().getName()+&quot;--------&gt;&quot;);</div><div class="line">	&#125; </div><div class="line"></div><div class="line">	//对标记修改的方法</div><div class="line">	public void changeFlag()&#123;</div><div class="line">		flag = false;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class StopThreadDemo&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Test3 t = new Test3();</div><div class="line">		Thread t1 = new Thread(t);</div><div class="line">		Thread t2 = new Thread(t);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		int x = 0;</div><div class="line">		//满足循环要求，改变标记使其他线程任务能够结束，同时break跳出循环，让主线程也可以结束。</div><div class="line">		while(true)&#123;</div><div class="line">			if(++x = 50)&#123;</div><div class="line">			t.changeFlag();</div><div class="line">			break;</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;main----&gt;&quot;+x);</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;over&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：万一线程在任务中被冻结了，那么它还能去判断标记吗？不能！<br>解决：如果目标线程等待很长时间，则应该使用interrupt方法来中断该等待，所谓的中断并不是停止线程。<br>  interrupt的功能是将线程的状态清除，让线程恢复到运行状态（让线程重新具备cpu的执行资格）。由于是强制性的，所有会有异常发生，可以在catch中捕获异常，在异常处理中，改变标记让循环结束，让run方法结束。</p>
<p><strong>3.  守护线程的概念</strong><br>守护线程为后台线程，一般创建的都是前台线程。<br>相同点：前台、后台线程运行时都是一样的获取cpu的执行权和执行资格，都可以通过run方法结束，线程结束的方式结束。<br>不同点：当进程中所有的前台进程都结束了，无论后台处于什么样的状态，都会结束，从而进程会结束，进程的结束都是依赖于前台进程。</p>
<p><strong>4.  线程的优先级</strong><br>用数字标识。1-10，其中默认的初始优先级是5，最明显的优先级是1，5，10。</p>
<p><strong>5.  线程组ThreadGroup</strong><br>可以通过Thread的构造函数明确新线程对象所属的线程组。线程组的好处是，可以对多个同组线程进行统一的操作，效率高，默认是都属于main线程组。</p>
<p><strong>6.  jion()方法和yield()方法</strong><br>Thread1.jion()：主线程执行到这里，知道Thread1线程要加入执行，主线程释放了执行权、执行资格，并处于冻结状态。什么时候能恢复呢？等Thread1线程执行完后。<br>Thread2.yield()：线程临时暂停，将执行权释放，让其他线程有机会获得cpu的执行权。</p>
<p><strong>7. 开发中，线程的匿名内部类体现</strong><br>第一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new Thread()&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int x=0; x&lt;40; x++)&#123;</div><div class="line">		System.out.println(Thread.currentThread().getName()+ &quot;...X...&quot; +x);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure>
<p>第二种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Runnable r = new Runnable()&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int x=0; x&lt;40; x++)&#123;</div><div class="line">		System.out.println(Thread.currentThread().getName()+ &quot;...Y...&quot; +x);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">new Thread(r).start();</div></pre></td></tr></table></figure>
<p><strong>8.  关于成员变量与局部变量</strong><br>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他的线程。</p>
<p>  <strong>先总结这么多，刚买了《Java并发编程实战》，后面肯定要通过好好读这本书对并发有个更好的理解，大家多多交流，一起努力！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、多线程的引入&quot;&gt;&lt;a href=&quot;#1、多线程的引入&quot; class=&quot;headerlink&quot; title=&quot;1、多线程的引入&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、多线程的引入&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;  多线程的相关内容是Java基础中非常重要的一部分，这两
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
