<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wunian&#39;s Blog</title>
  <subtitle>清风徐来，水波不兴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-11T14:45:27.068Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xu Bo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入剖析volatile</title>
    <link href="http://yoursite.com/2017/08/11/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90volatile/"/>
    <id>http://yoursite.com/2017/08/11/深入剖析volatile/</id>
    <published>2017-08-11T12:16:04.000Z</published>
    <updated>2017-08-11T14:45:27.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、volatile的性质"><a href="#一、volatile的性质" class="headerlink" title="一、volatile的性质"></a>一、volatile的性质</h1><h2 id="1、volatile保证可见性"><a href="#1、volatile保证可见性" class="headerlink" title="1、volatile保证可见性"></a>1、volatile保证可见性</h2><ol>
<li>volatile关键字保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对于其他线程来说是立即可见的。</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//线程1</div><div class="line">boolean stop =false;</div><div class="line">while(!stop)</div><div class="line">  doSomething();</div><div class="line"></div><div class="line">//线程2</div><div class="line">stop=true;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;上面的代码，可能导致无法中断线程。当线程2更改了stop变量的值后，还没来得及写入内存中，线程2就转去做其他事情了，线程1由于不知道线程2对stop变量的修改，会一直循环下去。<br>&emsp;&emsp;使用volatile修饰后，发生变化：<br>第一：使用volatile会强制将修改的值写入主内存。<br>第二：使用volatile的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效。<br>第三：由于线程1的工作内存中的缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主内存读取。  </p>
<h2 id="2、volatile保证有序性"><a href="#2、volatile保证有序性" class="headerlink" title="2、volatile保证有序性"></a>2、volatile保证有序性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//x、y不是volatile变量</div><div class="line">//flag为volatile变量</div><div class="line">x=2;            //语句1</div><div class="line">y=0;            //语句2</div><div class="line">flag=true;      //语句3</div><div class="line">x=4;            //语句4</div><div class="line">y=-1            //语句5</div></pre></td></tr></table></figure>
<p>①由于flag为volatile变量，在进行指令重排序时，不会将语句3放到语句1、2前面，也不会将语句3放到语句4、5的后面，但是语句1、2的顺序，语句4、5的执行顺序是不做任何保证的。<br>②并且volatile保证：执行到语句3时，语句1、2必定是执行完毕类的，而且语句1、2的执行结果对语句3、4、5是可见的。  </p>
<h2 id="3、volatile不能保证原子性"><a href="#3、volatile不能保证原子性" class="headerlink" title="3、volatile不能保证原子性"></a>3、volatile不能保证原子性</h2><p>&emsp;&emsp;原子性：即一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>&emsp;&emsp;可以通过synchronized或Lock进行加锁，来保证操作的原子性。也可以通过使用java.util.concurrent.atomic包下提供的原子操作类（对基本数据类型的一些操作进行了封装）来实现。<br>&emsp;&emsp;atomic是利用CAS（Compare And Swap）来实现原子性操作的，CAS实际上利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性的操作。  </p>
<h2 id="4、volatile的应用场景"><a href="#4、volatile的应用场景" class="headerlink" title="4、volatile的应用场景"></a>4、volatile的应用场景</h2><p>&emsp;&emsp;相较于synchronized，volatile是较为轻量级的同步策略，使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但volatile无法代替synchronized，因为volatile无法保证操作的原子性。<br>&emsp;&emsp;使用volatile的两个条件：<br>1、对变量的写操作不依赖于当前值<br>2、 该变量没有包含在具有其他变量的不变式中  </p>
<h1 id="二、volatile的实现原理"><a href="#二、volatile的实现原理" class="headerlink" title="二、volatile的实现原理"></a>二、volatile的实现原理</h1><h2 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h2><p>&emsp;&emsp;处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据读到内部缓存后再进行操作，但操作完后不知道何时才会写到内存中。<br>&emsp;&emsp;对声明了volatile变量进行写操作时，<strong>JVM会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。</strong>这一步确保了如果有其他线程对声明了volatile的变量进行修改时，则立即更新主内存中的数据。<br>&emsp;&emsp;但此时其他处理器的缓存的数据还是旧数据，<strong>所以在多处理器的环境下，为了保证各个处理器的缓存一致，每个处理器会通过嗅探在总线上传播的数据来检查自己的缓存是否过期。当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个数据进行修改时，会强制重新从系统内存把数据读到处理器缓存里。</strong>这一步确保了其他线程获得的声明了volatile的变量都是从主内存中获取的最新的。  </p>
<h2 id="2、有序性"><a href="#2、有序性" class="headerlink" title="2、有序性"></a>2、有序性</h2><p>&emsp;&emsp;Lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障之后的位置，即在执行到内存屏障这句指令时，在它之前的操作已经全部完成。</p>
<h2 id="3、Lock前缀指令"><a href="#3、Lock前缀指令" class="headerlink" title="3、Lock前缀指令"></a>3、Lock前缀指令</h2><p>在多处理器下会引发两件事：<br>①将当前处理器缓存行的数据写回到系统内存。<br>②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、volatile的性质&quot;&gt;&lt;a href=&quot;#一、volatile的性质&quot; class=&quot;headerlink&quot; title=&quot;一、volatile的性质&quot;&gt;&lt;/a&gt;一、volatile的性质&lt;/h1&gt;&lt;h2 id=&quot;1、volatile保证可见性&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出多线程</title>
    <link href="http://yoursite.com/2017/07/08/Java%E5%9F%BA%E7%A1%80---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/07/08/Java基础---深入浅出多线程/</id>
    <published>2017-07-08T09:12:55.000Z</published>
    <updated>2017-07-20T13:53:08.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、多线程的引入"><a href="#1、多线程的引入" class="headerlink" title="1、多线程的引入"></a><strong>1、多线程的引入</strong></h2><p>  多线程的相关内容是Java基础中非常重要的一部分，这两天对这部分知识进行了梳理，以达到复习和查漏补缺的目的。<br>  首先，多线程指的是在单个程序中可以同时运行多个不同的线程执行不同的任务，多线程编程的目的其实就是“最大限度地利用CPU资源”，我们接下来介绍下进程/程序/线程之间有什么区别和联系。</p>
<p> <strong>1. 进程与程序的区别是什么呢？</strong><br> （1）程序是长期存在的，进程是暂时的，是程序在数据集上的一次运行，有创建有撤销，存在是暂时的<br> （2）程序是静态的观念，进程是动态的观念<br> （3）进程具有并发性，而程序没有<br> （4） 进程是竞争计算机资源的基本单位，程序不是<br> （5）进程和程序不是一一对应的，一个程序可对应多个进程即多个进程可执行同一程序，一个进程可以执行一个或多个程序<br> <strong>2. 进程和线程又有什么区别呢？</strong><br> 线程是指进程内的一个执行单元，也是进程内的可调度实体。与进程的区别：<br> （1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位<br> （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行<br> （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源<br> （4）系统开销：在创建和撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建和撤销线程时的开销</p>
<h2 id="2、创建线程的两种方式"><a href="#2、创建线程的两种方式" class="headerlink" title="2、创建线程的两种方式"></a><strong>2、创建线程的两种方式</strong></h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a><strong>继承Thread类</strong></h3><ul>
<li>定义一个类去继承Thread</li>
<li>重写run方法</li>
<li>创建子类对象，就是创建线程对象</li>
<li><p>调用start方法，开启线程并让线程执行，同时告诉jvm去调用run方法</p>
<p>几个小问题：<br><strong>1.  线程对象调用run()方法和调用start()方法有什么区别</strong><br>调用run()方法不开启线程，仅仅是线程调用方法。调用start()方法开启线程，并让jvm调用run方法，在开启的线程中执行。<br><strong>2. 为什么要继承Thread类？</strong><br>因为Thread类描述线程事务，具备线程应有功能。<br><strong>3. 为什么不直接创建Thread类的对象呢？</strong><br>这么做start()调用的是Thread类中的run方法，此方法内部为空，不做任何事情，没有我们需要让线程执行的代码。</p>
<p> 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间，进行方法的压栈和弹栈。当执行线程的任务结束了，线程自动在栈内存中释放；当所有的执行线程都结束了，进程也就结束了。</p>
</li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a><strong>实现Runnable接口</strong></h3><ul>
<li>定义一个类来实现Runnable接口</li>
<li>覆盖接口中的run方法，将线程任务代码定义到run方法中</li>
<li>创建Thread类的对象（只有创建Thread对象，才能创建线程。）</li>
<li>将Runnable接口的子类对象作为参数传递给Thread类的构造函数</li>
<li>调用Thread类的start()方法开启线程</li>
</ul>
<p>Thread源码调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Thread&#123;</div><div class="line">	private Runnable target;</div><div class="line">	Thread(Runnable target)&#123;</div><div class="line">		this.target = target;</div><div class="line">		&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		if(target != null)&#123;</div><div class="line">			target.run();</div><div class="line">		&#125;</div><div class="line">	public void start()&#123;</div><div class="line">			run();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Runnable d = new Demo();</div><div class="line">Thread t = new Thread(d);</div><div class="line">t.start();</div></pre></td></tr></table></figure>
<p><strong>1. 为什么将Runnable接口的子类对象作为参数传递给Thread类的构造函数？</strong><br>   结合上面的Thread源码，我们不难看出，因为线程任务已被封装到Runnable接口的run()方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要执行的线程任务了。</p>
<p><strong>2.  实现Runnable接口的方式较继承Thread的方式有何优势？</strong><br>  1、实现Runnable接口避免了单继承的局限性<br>  2、实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分是线程对象，一部分是线程任务。<br>  继承Thread类：线程对象和线程任务耦合在一起，一旦创建Thread类的子类对象，既是线程对象，又有线程任务<br>  实现Runnable接口：将线程任务单独分离出来，封装成对象，类型就是Runnable接口类型，Runnable接口对线程对象和线程任务进行了解耦</p>
<h2 id="3、多线程的安全问题"><a href="#3、多线程的安全问题" class="headerlink" title="3、多线程的安全问题"></a><strong>3、多线程的安全问题</strong></h2><p>  线程安全问题产生的原因：<br>  <strong>1、多个线程在操作共享的数据</strong><br>  <strong>2、线程任务操作共享数据的代码有多条（有多次运算）</strong><br>  解决思路：只要让一个线程在执行线程任务时，将多条操作共享数据的代码执行完，在执行过程中，不要让其他线程参与运算。</p>
<p>使用同步synchronized：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">synchronized(锁对象)&#123;</div><div class="line"></div><div class="line">	//需要被同步的代码...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  考虑到大家对synchronized锁可能很难理解，我做个比较形象的比喻来方便大家理解：使用同步时会用到锁，这就好比是<strong>在火车上上厕所</strong>。这又从何说起呢？<br>   <strong>火车上有个人想上厕所时，会去拿锁进入厕所并关上门，此时其他人拿不到锁是进不了厕所的。当这个人上完厕所后，离开厕所的同时释放了锁，那么其他人都具有同等的机会来竞相拿到锁进入厕所。</strong>这就好比一个线程拿到锁，此时其他线程无法进入同步代码块或者同步函数执行代码，当一个线程执行完后释放锁，其他线程争相获得cpu的执行权，以此来获得锁进入同步代码块执行代码。希望这个例子能给大家一些启发。</p>
<p>同步代码块的好处：解决了多线程的安全问题<br>同步弊端：降低了程序的性能（很多线程访问，每次访问都需要判断锁，做了很多无用功）；当线程任务中出现了多个同步（多个锁）时，如果同步嵌套了其他的同步，这时候容易引发死锁。<br><strong>同步前提：必须保证多个线程在同步中使用的是同一个锁。（也以此前提来判断同步是否书写正确）</strong></p>
<p><strong>同步代码块与同步函数的区别？</strong><br>1、同步函数使用的锁是固定的this；同步代码块使用的锁可以是任意对象<br>2、当线程任务只需要一个同步时，完全可以使用同步函数；当线程任务中需要多个同步时，必须通过锁来区分，这时候必须使用同步代码块<br>注：static同步函数使用的锁不是this，而是字节码文件对象，类名.class</p>
<h2 id="4、多线程间的通信"><a href="#4、多线程间的通信" class="headerlink" title="4、多线程间的通信"></a><strong>4、多线程间的通信</strong></h2><p>多线程间最为常见的应用案例：生产者消费者问题，具体说来就是：生产和消费同时进行，需要多线程，但是执行的任务却不相同，处理的资源确实相同的。在生产者生产了商品后应该告诉消费者进行消费，这时的生产者需要处于等待状态；消费者在消费了商品后应该告诉生产者进行生产，这时消费者需要处于等待状态。</p>
<p>  <strong>生产一个消费一个的情况</strong>：生产者生产面包，判断盘子中是否有面包，有的话生产者进入等待状态；没有的话将生产后的面包放于盘子中，唤醒消费者进行消费。如果盘子中没有面包，消费者就进入等待状态；如果盘子中有面包，那么消费者消费，同时唤醒生产者进行生产。以下为具体代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">class Resource&#123;</div><div class="line">	private String name;</div><div class="line">	private int count = 1;</div><div class="line">	//定义标记flag</div><div class="line">	private boolean flag = false;</div><div class="line">    //生产者生产行为</div><div class="line">	public synchronized void set(String name)&#123;</div><div class="line">		//如果flag为true,说明盘子里有面包，不需要生产，生产者进入等待模式。</div><div class="line">		if(flag)</div><div class="line">			this.wait();</div><div class="line">		this.name = name + count;</div><div class="line">		count++;</div><div class="line">		System.out.println(&quot;...生产者...&quot;+this.name);</div><div class="line">		//完成生产，将标记改为true</div><div class="line">		flag = true;</div><div class="line">		//唤醒消费者</div><div class="line">		this.notify();	</div><div class="line">	&#125;</div><div class="line">	//消费者消费行为</div><div class="line">	public synchronized void out()&#123;</div><div class="line">		//如果flag为false,说明盘子里没有面包，消费不了，消费者者进入等待模式。</div><div class="line">		if(!flag)</div><div class="line">			this.wait();</div><div class="line">		System.out.println(&quot;...消费者...&quot;+this.name);</div><div class="line">		//完成消费，盘子里没有面包了，将标记改为false</div><div class="line">		flag = false;</div><div class="line">		//唤醒生产者</div><div class="line">		this.notify();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//描述生产者</div><div class="line">class Producer implements Runnable&#123;</div><div class="line">	private Resource r;</div><div class="line">	Producer(Resource r)&#123;</div><div class="line">		this.r = r;</div><div class="line">	&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		while(true)&#123;</div><div class="line">			r.set(&quot;面包&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//描述消费者</div><div class="line">class Consumer implements Runnable&#123;</div><div class="line">	private Resource r;</div><div class="line">	Consumer(Resource r)&#123;</div><div class="line">	this.r = r;</div><div class="line">	&#125;</div><div class="line">	public void run()&#123;</div><div class="line">		r.out();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">public class Tset1&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Resource r = new resource();</div><div class="line">		Producer pro = new Producer(r);</div><div class="line">		Consumer con = new Consumer(r);</div><div class="line">		Thread t1 = new Thread(pro);</div><div class="line">		Thread t2 = new Thread(con);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="等待-唤醒机制"><a href="#等待-唤醒机制" class="headerlink" title="等待/唤醒机制"></a><strong>等待/唤醒机制</strong></h3><p>wait()：会让线程处于等待状态，其实就是将线程临时存储到线程池中。<br>notify()：会让线程池中任意一个等待的线程唤醒。<br>notifyAll()：会唤醒线程池中所有的等待线程。<br><strong>记住：这些方法必须使用在同步中，因为必须要标识wait、notify等方法所属的锁，同一个锁上的notify只能唤醒该锁上被wait的线程。</strong></p>
<p><strong>多生产多消费的形式</strong>：多个生产者，多个消费者的情况，如果延用上面的代码则会遇到一下几个问题，具体大家可以自己实施下，无非是，多new几个生产者、消费者，多创建几个线程。</p>
<p><strong><em>问题一：部分生产了的商品没有被消费，同一个商品可能被消费多次</em></strong><br>原因：被唤醒的线程没有再次判断标记，造成问题的发生<br>解决：只要让被唤醒的线程重新再次去判断标记就可以了，将if判断标记的方式改为while判断标记的方式。<br><strong>记住：多生产多消费，必须是while判断语句。</strong></p>
<p><strong><em>问题二：改为while后，死锁了</em></strong><br>原因：生产方唤醒了线程池中生产方的线程（由于唤醒的是线程池中<strong>任意一个</strong>线程），唤醒后判断标记flag，发现为true进入等待状态，此时所有线程都进入等待状态，程序无法继续执行，死锁发生。<br>解决：希望本方唤醒对方，没有对应的方法，只能使用notifyAll的方法。</p>
<p>经过上面两步，我们解决了遇到的问题，但是这种方式最大的问题是，<strong>效率相对比较低</strong>，那我们有没有更好的解决方法呢？答案是肯定的！</p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a><strong>Lock接口</strong></h3><p>   Lock接口提供了更加面向对象的锁，在所中提供了更加显示的锁操作，我们可以通过lock()方法来获得锁，也可以用过unlock()方法来达到释放锁的目的，比同步更加厉害，可以用来替代synchronized。<br>   新锁（Lock）替代旧锁（synchronized），那么旧锁上的监视器方法（wait, notify, notifyAll）也在新锁上得到替换（await,  signal, signalAll）。在jdk1.5中，将这些原有的监视器方法封装到了一个Condition对象中，想要换取监视器的方法，就需要通过lock的newCondition方法获取Condition对象。通过使用新锁，我们可以在一个锁上创建多个监视器对象。<br>  下图为Lock与synchronized的对比：</p>
<p>  <img src="http://img.blog.csdn.net/20170320101442665?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Lock与synchronized对比"></p>
<p>下面我们使用新锁的方式，介绍一个<strong>生产多个消费多个</strong>的问题：一边在生产商品，将生产的放于容器中；另一边从容器中取商品消费。</p>
<p>   <img src="http://img.blog.csdn.net/20170320102244052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="多个消费多个生产模型"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">class Test2&#123;</div><div class="line">	final Lock lock = new ReentranLock();//锁</div><div class="line">	final Condition notFull = lock.newCondition();//生产</div><div class="line">	final Condition notEmpty = lock.newCondition();//消费</div><div class="line">	final Object[] items = new Object[20];//存储商品的容器</div><div class="line">	int putptr, takeptr, count;//生产者角标、消费者角标、计数器</div><div class="line">//往容器中存储商品</div><div class="line">public void put(Object x)throws InterruptException&#123;</div><div class="line">	lock.lock();//加锁</div><div class="line">	try&#123;</div><div class="line">		while(count == items.length)//判断计数器是否已到数组长度，满了生产就进入等待状态</div><div class="line">			notFull.await();</div><div class="line">		items[putptr] = x;//按照角标存储商品</div><div class="line">		if(++putptr == items.length)//存储角标到达数组长度，角标归零，重新从头存储商品</div><div class="line">			putptr = 0;</div><div class="line">		++count;//计数器自增</div><div class="line">		notEmpty.signal();//唤醒消费者</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();//释放锁</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">public Object take()throws InterruptException&#123;</div><div class="line">	lock.lock();</div><div class="line">	try&#123;</div><div class="line">		while(count==0)</div><div class="line">			notEmpty.await();</div><div class="line">		Object x = items[takeptr];</div><div class="line">		if(++takeptr == items.length)</div><div class="line">			takeptr = 0;</div><div class="line">		--count;</div><div class="line">		notFull.signal();</div><div class="line">		return x;</div><div class="line">		&#125;finally&#123;</div><div class="line">			lock.unlock();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a><strong>线程的状态</strong></h3><p>线程状态图如下所示：<br><img src="http://img.blog.csdn.net/20170320105528467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程状态图"></p>
<h2 id="5、多线程的细节"><a href="#5、多线程的细节" class="headerlink" title="5、多线程的细节"></a><strong>5、多线程的细节</strong></h2><p><strong>1. sleep方法和wait方法的异同？</strong><br>相同点：都可以让线程处于冻结状态<br>不同点：<br>1，sleep必须指定时间；wait可指定时间，也可不指定时间<br>2，sleep时间到，线程处于临时阻塞或进行状态；wait如果没有时间，必须要通过notify或者notifyAll唤醒<br>3，sleep不一定非要定义在同步中；wait必须要定义在同步中<br>4，都定义在同步中时，线程执行到sleep不会释放锁；线程执行到wait会释放锁</p>
<p><strong>2. 线程如何停止呢？</strong><br>线程结束就是让线程任务执行完，run方法结束。在run方法中通常都定义循环，只要控制住循环就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">class Test3 implements Runnable&#123;</div><div class="line">	private boolean flag = true;</div><div class="line">	public void run()&#123;</div><div class="line">	while(flag)</div><div class="line">		System.out.println(Thread.currentThread().getName()+&quot;--------&gt;&quot;);</div><div class="line">	&#125; </div><div class="line"></div><div class="line">	//对标记修改的方法</div><div class="line">	public void changeFlag()&#123;</div><div class="line">		flag = false;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class StopThreadDemo&#123;</div><div class="line">	public static void main(String[] args)&#123;</div><div class="line">		Test3 t = new Test3();</div><div class="line">		Thread t1 = new Thread(t);</div><div class="line">		Thread t2 = new Thread(t);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">		int x = 0;</div><div class="line">		//满足循环要求，改变标记使其他线程任务能够结束，同时break跳出循环，让主线程也可以结束。</div><div class="line">		while(true)&#123;</div><div class="line">			if(++x = 50)&#123;</div><div class="line">			t.changeFlag();</div><div class="line">			break;</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;main----&gt;&quot;+x);</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;over&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：万一线程在任务中被冻结了，那么它还能去判断标记吗？不能！<br>解决：如果目标线程等待很长时间，则应该使用interrupt方法来中断该等待，所谓的中断并不是停止线程。<br>  interrupt的功能是将线程的状态清除，让线程恢复到运行状态（让线程重新具备cpu的执行资格）。由于是强制性的，所有会有异常发生，可以在catch中捕获异常，在异常处理中，改变标记让循环结束，让run方法结束。</p>
<p><strong>3.  守护线程的概念</strong><br>守护线程为后台线程，一般创建的都是前台线程。<br>相同点：前台、后台线程运行时都是一样的获取cpu的执行权和执行资格，都可以通过run方法结束，线程结束的方式结束。<br>不同点：当进程中所有的前台进程都结束了，无论后台处于什么样的状态，都会结束，从而进程会结束，进程的结束都是依赖于前台进程。</p>
<p><strong>4.  线程的优先级</strong><br>用数字标识。1-10，其中默认的初始优先级是5，最明显的优先级是1，5，10。</p>
<p><strong>5.  线程组ThreadGroup</strong><br>可以通过Thread的构造函数明确新线程对象所属的线程组。线程组的好处是，可以对多个同组线程进行统一的操作，效率高，默认是都属于main线程组。</p>
<p><strong>6.  jion()方法和yield()方法</strong><br>Thread1.jion()：主线程执行到这里，知道Thread1线程要加入执行，主线程释放了执行权、执行资格，并处于冻结状态。什么时候能恢复呢？等Thread1线程执行完后。<br>Thread2.yield()：线程临时暂停，将执行权释放，让其他线程有机会获得cpu的执行权。</p>
<p><strong>7. 开发中，线程的匿名内部类体现</strong><br>第一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new Thread()&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int x=0; x&lt;40; x++)&#123;</div><div class="line">		System.out.println(Thread.currentThread().getName()+ &quot;...X...&quot; +x);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure>
<p>第二种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Runnable r = new Runnable()&#123;</div><div class="line">	public void run()&#123;</div><div class="line">		for(int x=0; x&lt;40; x++)&#123;</div><div class="line">		System.out.println(Thread.currentThread().getName()+ &quot;...Y...&quot; +x);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">new Thread(r).start();</div></pre></td></tr></table></figure>
<p><strong>8.  关于成员变量与局部变量</strong><br>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他的线程。</p>
<p>  <strong>先总结这么多，刚买了《Java并发编程实战》，后面肯定要通过好好读这本书对并发有个更好的理解，大家多多交流，一起努力！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、多线程的引入&quot;&gt;&lt;a href=&quot;#1、多线程的引入&quot; class=&quot;headerlink&quot; title=&quot;1、多线程的引入&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、多线程的引入&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;  多线程的相关内容是Java基础中非常重要的一部分，这两
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
