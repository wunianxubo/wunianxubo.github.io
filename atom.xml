<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wunian&#39;s Blog</title>
  <subtitle>清风徐来，水波不兴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-14T03:22:23.190Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xu Bo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring源码解析之AOP设计与实现</title>
    <link href="http://yoursite.com/2018/07/14/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BAOP%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/07/14/Spring源码解析之AOP设计与实现/</id>
    <published>2018-07-14T03:20:00.000Z</published>
    <updated>2018-07-14T03:22:23.190Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>AOP即面向切面编程，底层通过策略模式选择JDK动态代理还是CGLIB动态代理的方式实现，通过AOP可以在不修改原代码的基础上完成对类的功能的增强。相较于继承这种纵向抽取机制，AOP采用的横向抽取机制更加符合高内聚低耦合的思想。  </p>
<h3 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h3><ul>
<li>连接点：类中哪些方法可以被增强，这些方法称为连接点</li>
<li>切入点(Pointcut)：类中有很多可以被增强的方法，而实际选用的被增强方法就是切入点</li>
<li>通知(Advice)：定义增强的逻辑，即在切入点做什么增强操作，有BeforeAdvice、AfterAdvice、ThrowsAdvice等</li>
<li>通知器(Advisor)：将目标方法的切面增强设计(Advice)和切入点(Pointcut)结合起来。通过Advisor，可以定义使用哪个通知并在哪个Pointcut使用它，也就是给指定的Pointcut指定对应的Advice  </li>
</ul>
<a id="more"></a>
<h4 id="1、Advice"><a href="#1、Advice" class="headerlink" title="1、Advice"></a>1、Advice</h4><p>通知，是AOP的一个基本接口，BeforeAdvice、AfterAdvice、ThrowsAdvice都继承于它。下面以BeforeAdvice为例，在其继承体系中，定义了为待增强目标方法设置的前置增强接口MethodBeforeAdvice。  </p>
<p>使用这个前置接口需要实现一个回调函数<strong>before</strong>()，before方法的实现在Advice中被配置到目标方法后，会在调用木变方法时被回调。  </p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void before(<span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>, <span class="title">Object</span> <span class="title">target</span>) <span class="title">throws</span> <span class="title">Throwable</span>;</span></div></pre></td></tr></table></figure>
<p>参数：<br>Method，是目标方法的反射对象；Object数组，是目标方法的输入参数。  </p>
<h4 id="2、Pointcut"><a href="#2、Pointcut" class="headerlink" title="2、Pointcut"></a>2、Pointcut</h4><p>从Pointcut的接口定义中可以知道，需要返回一个<strong>MethodMatcher</strong>，对于Pointcut的匹配判断（即是否需要对当前方法进行增强），都是由这个MethodMatcher来完成的。  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Pointcut&#123;</div><div class="line">    ClassFilter getClassFilter();</div><div class="line">    MethodMatcher getMethodMatcher();</div><div class="line">    Pointcut <span class="literal">TRUE</span> = TruePointcut.INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在MethodMatcher接口中，有一个<strong>matches()</strong> 方法，matches方法在匹配连接点的过程中有着至关重要的作用。  </p>
<p>在Pointcut的继承体系中，MethodMatcher可以配置成JdkRegexpMethodPointcut和NameMatchMethodPointcut来完成方法的匹配判断。  </p>
<p><strong>JdkRegexpMethodPointcut</strong> 通过使用正则表达式来对方法名进行匹配判断的。而<strong>NameMatchMethodPointcut</strong> 通过根据方法的全限定名称来进行匹配判断。  </p>
<h4 id="3、Advisor通知器"><a href="#3、Advisor通知器" class="headerlink" title="3、Advisor通知器"></a>3、Advisor通知器</h4><p>以DefaultPointcutAdvisor为例：  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPointcutAdvisor</span> ...</span>&#123;</div><div class="line">    <span class="keyword">private</span> Pointcut <span class="keyword">pointcut</span> = Pointcut.TRUE;</div><div class="line">    </div><div class="line">    //创建一个匹配所有方法的DefaultPointcutAdvisor</div><div class="line">    public <span class="title">DefaultPointcutAdvisor</span>(Advice advice)&#123;</div><div class="line">        <span class="keyword">this</span>(Pointcut.TRUE, advice);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//为指定的pointcut和advice创建一个DefaultPointcutAdvisor</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultPointcutAdvisor</span><span class="params">(Pointcut pointcut, Advice advice)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.pointcut = <span class="keyword">pointcut</span>;</div><div class="line">        <span class="title">setAdvice</span>(advice);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AOP的设计与实现"><a href="#AOP的设计与实现" class="headerlink" title="AOP的设计与实现"></a>AOP的设计与实现</h3><p>在使用Spring AOP的过程中，我们可以通过配置达到在目标方法执行前或执行后进行其他操作的目的。这也是AOP完成的流程，首先为目标对象建立代理对象，然后启动代理对象的拦截器来完成各种切面的注入过程。同时，这一系列的织入设计是通过一系列的Adapter来实现的（不同的Advice有不同的Adapter来适配），比如MethodBeforeAdvice就有MethodBeforeAdviceAdapter与之匹配。<br><img src="http://osrmzp0jr.bkt.clouddn.com/aopproxy%20generate.jpg" alt="image"><br>在AOP模块中，代理对象的生成主要是通过ProxyFactoryBean来完成的，在其中封装了代理对象的生成过程。在ProxyFactoryBean中，代理对象的生成是以<strong>getObject()</strong> 方法为入口的。  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>&#123;</div><div class="line">    <span class="comment">//在此完成为Proxy对象配置Advisor链</span></div><div class="line">    <span class="comment">//这个初始化的过程发生在第一次通过ProxyFactoryBean去获取代理对象的时候</span></div><div class="line">    initializeAdvisorChain();</div><div class="line">    </div><div class="line">    <span class="comment">//对单例和多例类型加以区分，调用不同方法生成代理对象</span></div><div class="line">    <span class="keyword">if</span>(isSingleton())&#123;</div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">getSingletonInstance</span><span class="params">()</span></span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">newPrototypeInstance</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如getObject方法中展现的那样，如果是单例对象，那么调用<strong>getSingletonInstance()</strong> 方法生成单例的代理对象，否则调用<strong>newPrototypeInstance()</strong> 生成对象。我们来分析下getSingletonInstance：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> synchronized Object getSingletonInstance()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.singletonInstance == <span class="literal">null</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.targetSource = freshTargetSource();</div><div class="line">        ...</div><div class="line">        <span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面方法通过createAopProxy()返回的AopProxy传入getProxy方法来得到代理对象</span></div><div class="line"><span class="keyword">protected</span> Object getProxy(AopProxy aopProxy)&#123;</div><div class="line">    <span class="keyword">return</span> aopProxy.getProxy(<span class="keyword">this</span>.proxyClassLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>关键就在于通过createAopProxy()方法获取到AopProxy</strong>，最终调用的是<strong>DefaultAopProxyFactory</strong>的createAopProxy(config)方法来完成创建AopProxy。  </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> AopProxy createAopProxy(AdvisedSupport <span class="built_in">config</span>) throws AopConfigException &#123;</div><div class="line">        <span class="built_in">if</span> (<span class="built_in">config</span>.isOptimize() || <span class="built_in">config</span>.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(<span class="built_in">config</span>)) &#123;</div><div class="line">            Class&lt;?&gt; targetClass = <span class="built_in">config</span>.getTargetClass();</div><div class="line">            <span class="built_in">if</span> (targetClass == null) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</div><div class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果 targetClass 是接口类，使用JDK来生成AopProxy</span></div><div class="line">            <span class="built_in">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">                <span class="built_in">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 否则使用CGLIB来生成AopProxy对象</span></div><div class="line">            <span class="built_in">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(<span class="built_in">config</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">else</span> &#123;</div><div class="line">            <span class="built_in">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到在这个方法中，对是否为接口类进行了判断。如果是接口类，就会使用Jdk动态代理生成代理对象；否则，会使用cglib动态代理生成代理对象。通过这个AopProxy对象，将AOP代理对象的生成和框架的其他部门进行了分离。  </p>
<p>这样之后，ProxyFactoryBean的getObject方法返回得到的就不是一个普通的Java对象了，而是一个AopProxy代理对象。这时候就不会让应用只是调用目标方法实现，而是会作为AOP实现的一部分(参照invoke方法的实现)。  </p>
<h3 id="AOP拦截器链的实现"><a href="#AOP拦截器链的实现" class="headerlink" title="AOP拦截器链的实现"></a>AOP拦截器链的实现</h3><p>Spring AOP在通过动态代理生成代理对象的时候，相关的拦截器就已经被配置到代理对象中去了，拦截器在代理对象中起作用是通过对这些方法的回调来完成的。  </p>
<h4 id="拦截器链的获取"><a href="#拦截器链的获取" class="headerlink" title="拦截器链的获取"></a>拦截器链的获取</h4><p>在DefaultAdvisorChainFactory中实现了拦截器链的获取过程。首先设置一个List，长度是由配置的通知器的个数决定的，之后通过AdvisorAdapterRegistry来实现拦截器的注册，通过AdvisorAdapterRegistry就行适配，获取到Advisor通知器对应的拦截器，再把它加入到前面的List中去，这样就完成了拦截器的注册。  </p>
<h4 id="拦截器链的调用"><a href="#拦截器链的调用" class="headerlink" title="拦截器链的调用"></a>拦截器链的调用</h4><p>如果通过Jdk动态代理的方式生成代理对象，那么需要通过<strong>InvocationHandler的invoke</strong>方法来设置拦截器的回调；如果通过Cglib动态代理的方式生成代理对象，那么就需要通过<strong>DynamicAdvisedInterceptor的intercept</strong>方法来实现拦截器的回调。  </p>
<p>但不管是哪种方式，它们对拦截器链的调用都是在<strong>ReflectiveMethodInvocation</strong>中通过<strong>proceed</strong>方法实现的。在proceed方法中，会逐个运行拦截器的拦截方法。在运行拦截方法之前，需要对代理方法完成一个匹配判断，来决定拦截器是否满足切面增强的要求（通过前面提到的matches方法实现）。在proceed方法中，先进行判断，如果现在运行到拦截器的末尾，那么就会直接调用目标对象的实现方法。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;AOP即面向切面编程，底层通过策略模式选择JDK动态代理还是CGLIB动态代理的方式实现，通过AOP可以在不修改原代码的基础上完成对类的功能的增强。相较于继承这种纵向抽取机制，AOP采用的横向抽取机制更加符合高内聚低耦合的思想。  &lt;/p&gt;
&lt;h3 id=&quot;AOP相关概念&quot;&gt;&lt;a href=&quot;#AOP相关概念&quot; class=&quot;headerlink&quot; title=&quot;AOP相关概念&quot;&gt;&lt;/a&gt;AOP相关概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;连接点：类中哪些方法可以被增强，这些方法称为连接点&lt;/li&gt;
&lt;li&gt;切入点(Pointcut)：类中有很多可以被增强的方法，而实际选用的被增强方法就是切入点&lt;/li&gt;
&lt;li&gt;通知(Advice)：定义增强的逻辑，即在切入点做什么增强操作，有BeforeAdvice、AfterAdvice、ThrowsAdvice等&lt;/li&gt;
&lt;li&gt;通知器(Advisor)：将目标方法的切面增强设计(Advice)和切入点(Pointcut)结合起来。通过Advisor，可以定义使用哪个通知并在哪个Pointcut使用它，也就是给指定的Pointcut指定对应的Advice  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring源码解析" scheme="http://yoursite.com/categories/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡那些事</title>
    <link href="http://yoursite.com/2018/06/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/06/25/负载均衡那些事/</id>
    <published>2018-06-25T08:55:00.000Z</published>
    <updated>2018-06-25T09:56:39.829Z</updated>
    
    <content type="html"><![CDATA[<p>在网站的架构设计中，应用服务器应该被设计成无状态的，也就是说应用服务器不存储请求上下文信息。这样子的话，如果将部署相同应用的服务器组成一个集群，每次用户请求都可以发送到集群中任何一台服务器上进行请求处理，任何一台服务器的处理结果都是相同的。通过使用这种方式，让网站的可用性、伸缩性更好，能够处理更大的流量，这种方式称为”负载均衡”。在这篇文章中，我们一起来学习负载均衡，主要分下面三个部分来将，会依次介绍常用的负载均衡技术，常用的负载均衡算法以及这些负载均衡层在实际案例中的使用方式。<br><a id="more"></a></p>
<h3 id="一、常用负载均衡技术"><a href="#一、常用负载均衡技术" class="headerlink" title="一、常用负载均衡技术"></a>一、常用负载均衡技术</h3><h4 id="1-HTTP重定向负载均衡"><a href="#1-HTTP重定向负载均衡" class="headerlink" title="1. HTTP重定向负载均衡"></a>1. HTTP重定向负载均衡</h4><p>这种方式利用HTTP重定向协议来实现负载均衡，如下图所示：<br><img src="http://osrmzp0jr.bkt.clouddn.com/http.png" alt="image"><br>HTTP重定向服务器是一台普通的应用服务器，它唯一的功能就是根据用户的HTTP请求计算一台真实的Web服务器地址，并将该Web服务器的地址写入HTTP重定向响应（302状态吗）中返回给用户浏览器，之后浏览器自动重新请求该Web服务器地址。  </p>
<p>这种方式的负载均衡的优点是比较简单。缺点是：  </p>
<ul>
<li>浏览器需要两次请求服务器才能完成一次访问，性能较差；</li>
<li>重定向服务器自身的处理能力可能会成为瓶颈，整个集群的伸缩性规模有限；</li>
<li>使用302响应吗重定向，有可能使搜索引擎判断为SEO作弊，降低搜索排名。</li>
</ul>
<p>此种方式在实践中并不多见。  </p>
<h4 id="2-DNS域名解析负载均衡"><a href="#2-DNS域名解析负载均衡" class="headerlink" title="2. DNS域名解析负载均衡"></a>2. DNS域名解析负载均衡</h4><p>这种方式利用DNS进行域名解析的同时进行负载均衡处理，如下图所示：<br><img src="http://osrmzp0jr.bkt.clouddn.com/dns.png" alt="image"><br>在DNS服务器中配置多个A记录，每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置的多个服务器就构成集群，就可以实现负载均衡。  </p>
<p>这种方式的优点是：  </p>
<ul>
<li>将负载均衡的工作转交给DNS，省掉了网站管理维护负载均衡服务器的麻烦，同时许多DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理最近的一个服务器地址，这样可加快用户访问速度，改善性能。  </li>
</ul>
<p>但是这种方式同样也存在一些缺点：  </p>
<ul>
<li>目前的DNS解析是多级解析，每一级DNS都可能缓存A记录，当下线某台服务器时，A记录的修改生效具有滞后性；</li>
<li>DNS负载均衡的控制权在域名服务商，网站无法对其做更多的改善和管理。</li>
</ul>
<p><strong>实际上，网站会采用部分使用DNS域名解析的方式，利用域名解析作为第一级负载均衡手段，就是说域名解析得到的一组服务器并不是实际提供Web服务的物理处理器，而是同样提供负载均衡服务的内部服务器，这组内部负载均衡服务器再进行负载均衡，将请求发到真实的Web服务器。</strong> 具体的形式可以看下面的案例。  </p>
<h4 id="3-反向代理负载均衡（七层负载均衡）"><a href="#3-反向代理负载均衡（七层负载均衡）" class="headerlink" title="3. 反向代理负载均衡（七层负载均衡）"></a>3. 反向代理负载均衡（七层负载均衡）</h4><p>利用反向代理服务器进行负载均衡。如下图所示：<br><img src="http://osrmzp0jr.bkt.clouddn.com/nginxs.png" alt="image">  </p>
<p>首先解释下正向代理和反向代理：  </p>
<p><strong>正向代理：</strong><br>我想访问一个网站，但是这个网站我没有权限访问，但是我可以访问一个代理服务器，它可以访问我要访问的网站，于是我连上这个代理服务器，告诉代理服务器我要访问的地址，代理服务器取到结果后返回给我。<br>也就是说，正向代理 是一个位于客户端和原始服务器(originserver)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。  </p>
<p><strong>反向代理：</strong><br>对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容 原本就是它自己的一样。对用户来说，真正的原始服务器是透明的。</p>
<p>由于反向代理服务器转发请求在HTTP协议层面，因此也叫七层负载均衡（应用层负载均衡）。优点是和反向代理服务器功能集成在一起，部署简单。缺点是反向代理服务器是所有请求和响应的中转站，它的性能可能成为瓶颈。  </p>
<h4 id="4-IP负载均衡（四层负载均衡）"><a href="#4-IP负载均衡（四层负载均衡）" class="headerlink" title="4. IP负载均衡（四层负载均衡）"></a>4. IP负载均衡（四层负载均衡）</h4><p>这种方式的原理是在网络层通过修改请求的目标地址来进行负载均衡。如下图所示：<br><img src="http://osrmzp0jr.bkt.clouddn.com/iplb.png" alt="image">  </p>
<p>这种方式中，真实服务器将响应数据包返回给负载均衡服务器有两种方式：  </p>
<ol>
<li>负载均衡服务器在修改目的IP地址的同时，将源地址修改为自身IP，即源地址转换（SNAT），这样Web服务器的相应会回到负载均衡服务器。  </li>
<li>将负载均衡服务器同时作为真实物理器集群的网关服务器，这样所有响应的数据都会到达负载均衡服务器。  </li>
</ol>
<p>IP负载均衡在内核进程完成数据分发，较反向代理负载均衡（在应用程序中分发数据）有更好的性能。但是由于所有请求的响应也都需要经过负载均衡服务器返回，集群中的最大响应数据吞吐量受限制于负载均衡服务器的网卡带宽的大小。  </p>
<h4 id="5-数据链路层负载均衡（二层负载均衡）"><a href="#5-数据链路层负载均衡（二层负载均衡）" class="headerlink" title="5. 数据链路层负载均衡（二层负载均衡）"></a>5. 数据链路层负载均衡（二层负载均衡）</h4><p>这种方式，指的是在通信协议的数据链路层修改mac地址进行负载均衡。如下图所示：<br><img src="http://osrmzp0jr.bkt.clouddn.com/maclb.png" alt="image">  </p>
<p><strong>这种数据传输方式又称作三角传输模式，负载均衡数据分发的过程中不修改IP地址，只修改目的mac地址，通过配置真实物理服务器集群所有机器的虚拟IP和负载均衡服务器IP地址一致，达到了不用修改数据包的源地址和目的地址就可以进行数据分发的目的。由于实际处理请求的真实物理服务器IP和数据请求目的IP一致，所以不需要通过负载均衡服务器进行地址转换，可以将响应数据包直接返回给用户的浏览器，从而避免了负载均衡服务器网卡宽带成为瓶颈。这种负载均衡方式又称为直接路由方式（DR）</strong>  </p>
<p>使用三角传输模式的链路层负载均衡是目前大型网站使用最广的一种负载均衡手段。其中有优秀的开源产品LVS（Linux Virtual Server），创始人是滴滴现任副总裁章文嵩。  </p>
<h3 id="二、负载均衡算法"><a href="#二、负载均衡算法" class="headerlink" title="二、负载均衡算法"></a>二、负载均衡算法</h3><p>负载均衡算法的作用是与服务器列表一起计算得到集群冲的一台Web服务器的地址，就是说给请求分配一个可处理的服务器。  </p>
<h4 id="1-轮询"><a href="#1-轮询" class="headerlink" title="1. 轮询"></a>1. 轮询</h4><p>所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数目都相同，适合于所有服务器硬件都相同的场景。  </p>
<h4 id="2-加权轮询"><a href="#2-加权轮询" class="headerlink" title="2.加权轮询"></a>2.加权轮询</h4><p>根据应用服务器硬件性能的情况，在轮询的基础上，按照配置的权重将请求分发到每个服务器，性能好的服务器处理更多的请求。  </p>
<h4 id="3-随机"><a href="#3-随机" class="headerlink" title="3.随机"></a>3.随机</h4><p>请求被随机分配到各个应用服务器，这种方式在很多场合下，简单易用。  </p>
<h4 id="4-最少连接"><a href="#4-最少连接" class="headerlink" title="4. 最少连接"></a>4. 最少连接</h4><p>记录每个服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上。  </p>
<h4 id="5-源地址散列"><a href="#5-源地址散列" class="headerlink" title="5.源地址散列"></a>5.源地址散列</h4><p>根据请求来源的IP地址进行Hash计算，得到应用服务器，这样来自同一个ip地址的请求总是在同一个服务器上处理，该请求的上下文信息可以存到这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。  </p>
<h3 id="三、负载均衡方案"><a href="#三、负载均衡方案" class="headerlink" title="三、负载均衡方案"></a>三、负载均衡方案</h3><p>下面是以一个货运订单和物流管理的系统为例，看看各个阶段的负载均衡方案是怎样的，来看看实际案例中，我们应该怎么结合使用负载均衡。  </p>
<h4 id="第一阶段：独立的Nginx-HAProxy方案"><a href="#第一阶段：独立的Nginx-HAProxy方案" class="headerlink" title="第一阶段：独立的Nginx/HAProxy方案"></a>第一阶段：独立的Nginx/HAProxy方案</h4><p>在这个阶段，系统压力不大，但为了以后更好的扩展，我们将业务进行拆分，分成用户信息、订单信息、车辆信息三大模块。如下图所示：  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/nginx1.png" alt="image">  </p>
<p>这时负载均衡层的作用是按照设定的访问规则，将不同系统的请求转发给对应的系统。  </p>
<h4 id="第二阶段：Nginx-HAProxy-KeepAlived方案"><a href="#第二阶段：Nginx-HAProxy-KeepAlived方案" class="headerlink" title="第二阶段：Nginx/HAProxy + KeepAlived方案"></a>第二阶段：Nginx/HAProxy + KeepAlived方案</h4><p>这个阶段，系统的访问压力进一步加大，我们在单节点处还能满足业务要求的情况下，为负载层引入热备方案，以此来保证在节点崩溃时，另一个节点可以接替其工作，提高系统的可用性。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/nginx2.png" alt="image">  </p>
<h4 id="第三阶段：LVS-DR-Nginx-KeepAlived方案"><a href="#第三阶段：LVS-DR-Nginx-KeepAlived方案" class="headerlink" title="第三阶段：LVS(DR) + Nginx + KeepAlived方案"></a>第三阶段：LVS(DR) + Nginx + KeepAlived方案</h4><p>在这个阶段，为了追求更大的吞吐量和更大的请求流量，我们加入LVS技术。LVS技术负载第一层负载，然后再将访问请求转发到后台若干台Nginx上。在收到请求并处理完成后，Nginx将直接发送结果到请求方，不会再经LVS回发。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/nginx3.png" alt="image">  </p>
<p>加入LVS后，Nginx就不再需要使用热备方案。因为首先Nginx不再是一个单个节点进行负载处理，而是作为一个集群，可用性提升；另外LVS对于后端的服务器自带基于端口的健康检查功能。  </p>
<p>这样子LVS就变成了是单节点处理的，虽然LVS十分稳定，但是为了保证高可用性和高稳定性，我们还是为LVS做一个热备节点，以备不时之需。  </p>
<h4 id="第四阶段：DNS轮询-LVS-DR-Nginx-KeepAlived方案"><a href="#第四阶段：DNS轮询-LVS-DR-Nginx-KeepAlived方案" class="headerlink" title="第四阶段：DNS轮询 + LVS(DR) + Nginx + KeepAlived方案"></a>第四阶段：DNS轮询 + LVS(DR) + Nginx + KeepAlived方案</h4><p><img src="http://osrmzp0jr.bkt.clouddn.com/nginx4.png" alt="image">  </p>
<p>为了满足更高的并发需求，更大的访问量，在对业务进行外网暴露的基础上，我们在最前端做了一个DNS轮询，然后将对用户信息系统的访问压力首先分摊到两个对称LVS组上面，再由LVS继续向下分拆访问压力。  </p>
<p>注意到，这里的负载均衡方案和上面不同：  </p>
<ul>
<li>首先不向前面方案中，使用目录名来分割业务系统了，而是直接将业务系统的访问使用不同的二级域名进行拆分。这样子有利于每个业务系统都拥有自己独立的负载均衡层。在这只是用户信息子系统的负载均衡层，订单子系统、物流子系统也会有相应的负载均衡层。</li>
<li>理论上，在LVS下方的Nginx服务可以实现无限制的扩展，Nginx本身也不需要KeepAlived保持热备，而是全部交给上层的LVS进行健康状态检查。  </li>
</ul>
<p>可以看到，没有独立的LVS方案，这是由于LVS为了保证其高性能对可配置性有所牺牲，单独使用的话往往无法满足业务层对负载层灵活分配请求的要求。  </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇文章主要先介绍了常用的负载均衡的技术，以及常用的负载均衡的方法。在实际的网站系统架构中，会将多种负载均衡技术结合在一起，从而使系统具有更好的性能，更好的可用性。所以我们在第三部分以一个货运订单物流管理系统为例，分析了在实际案例中负载均衡技术的使用。当然，这些都是停留在理论阶段，在具体实施过程中，可能会遇到具体的负载均衡服务器的配置问题，负载均衡算法的选择问题，或是其他各种各样的问题，我还没有深入接触过这样的大型系统，希望在以后工作学习中进行更深的学习。  </p>
<p>参考文章：  </p>
<ol>
<li>《大型网站技术架构原理》 李智慧  </li>
<li>架构设计：负载均衡层设计方案（1）——负载场景和解决方式 <a href="https://blog.csdn.net/yinwenjie/article/details/46605451" target="_blank" rel="external">https://blog.csdn.net/yinwenjie/article/details/46605451</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网站的架构设计中，应用服务器应该被设计成无状态的，也就是说应用服务器不存储请求上下文信息。这样子的话，如果将部署相同应用的服务器组成一个集群，每次用户请求都可以发送到集群中任何一台服务器上进行请求处理，任何一台服务器的处理结果都是相同的。通过使用这种方式，让网站的可用性、伸缩性更好，能够处理更大的流量，这种方式称为”负载均衡”。在这篇文章中，我们一起来学习负载均衡，主要分下面三个部分来将，会依次介绍常用的负载均衡技术，常用的负载均衡算法以及这些负载均衡层在实际案例中的使用方式。&lt;br&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="大型网站技术架构" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty之EventLoop与线程模型</title>
    <link href="http://yoursite.com/2018/06/16/Netty%E4%B9%8BEventLoop%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%20/"/>
    <id>http://yoursite.com/2018/06/16/Netty之EventLoop与线程模型 /</id>
    <published>2018-06-16T13:53:00.000Z</published>
    <updated>2018-06-25T09:07:57.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先，线程模型指定了操作系统、编程语言或者应用程序的<em>上下文中的线程管理</em>的关键方面。Netty的线程模型，强大而又易用，在简化代码的同时，最大限度的提高性能和可维护性。学习这部分可能需要有一定的多线程的知识的基础，可以看看《Java并发编程实战》或者《并发编程的艺术》这两本书。<br><a id="more"></a></p>
<h3 id="线程模型概述"><a href="#线程模型概述" class="headerlink" title="线程模型概述"></a>线程模型概述</h3><p>在这里，我们先看看常见的线程模型是怎样的，然后我们再看看Netty的线程模型如何，看看他们各自的优缺点。  </p>
<p>早期Java语言中，我们使用多线程处理的主要方式是按需创建和启动新的Thread来执行并发的任务——在高负载下性能很差，需要重复的创建和销毁线程。  </p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>所以，在Java5之后引入了Executor API，使用线程池通过缓存和重用Thread极大地提高了性能。线程池的具体原理可参考我之前的文章<a href="http://xiaonanbobo.com/2017/08/30/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/" target="_blank" rel="external">《Java中的线程池》</a>。线程池的工作模式如下：  </p>
<ul>
<li>从池的空闲线程列表中选择一个Thread，并且指派它去运行一个已提交的任务。（一个Runnable的实现）</li>
<li>当任务完成时，将该Thread返回给该列表，使其可被重用。  </li>
</ul>
<p><em>虽然池化和重用线程相对于每次都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来的开销，随着线程数量的增加很快变得明显，并且会越来越严重。</em>  </p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>运行任务来处理在连接的生命周期内发生的事件是网络框架的基本功能。与之对应的编程上的构造称为事件循环——在Netty中通过EventLoop来适配，一个EventLoop对应一个Selector和一个TaskQueue。<br><img src="https://upload-images.jianshu.io/upload_images/2184951-2e248d85df2a1a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/490" alt="image">   </p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(!terminated)&#123;</div><div class="line">    <span class="comment">//阻塞，直到有事件已经就绪可以被执行</span></div><div class="line">    <span class="keyword">List</span>&lt;Runnable&gt; readyEvents = blockUntilEventReady();</div><div class="line">    <span class="comment">//循环遍历，并处理所有的事件</span></div><div class="line">    <span class="keyword">for</span>(Runnable ev : readyEvents)&#123;</div><div class="line">        ev.<span class="keyword">run</span>();   </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个模型中，一个EventLoop将由一个不会改变的Thread驱动，同时任务（Runnable或Callable）可以直接提交给EventLoop实现，以立即执行或者调度执行。根据配置或者CPU核心数的不同，可能会创建多个EventLoop实例用以优化资源的使用，并且EventLoop与Channel之间可以是一对多的关系，即多个Channel公用一个EventLoop。  </p>
<p>在Netty4中，Channel所有的I/O操作和事件都交给分配给了EventLoop的那个不会变的Thread来处理。由于至始至终都在同一个线程中进行处理，这样也避免了一些线程安全的问题。  </p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h4><p>Netty线程模型的优越性能取决于对于当前执行的Thread的身份的确定，也就是确定当前执行的Thread是不是分配给当前Channel以及其对应的EventLoop的那一个线程（EventLopp与一个Thread至始至终绑定）。  </p>
<p>如果当前调用线程正好是支撑EventLoop的线程，那么所提交的代码块就会被该线程直接执行。否则，EventLoop将调度该任务以便稍后执行，并将它放入到内部队列中（上图的taskQueue）。当EventLoop下次处理它的事件时，它会执行队列中的那些任务。  </p>
<h4 id="EventLoop-线程的分配"><a href="#EventLoop-线程的分配" class="headerlink" title="EventLoop/线程的分配"></a>EventLoop/线程的分配</h4><p>服务于Channel的I/O事件的EventLoop包含在EventLoopGroup中，根据不同的传输实现，EventLoop的分配方式也不同。  </p>
<h5 id="1-非阻塞传输"><a href="#1-非阻塞传输" class="headerlink" title="1.非阻塞传输"></a>1.非阻塞传输</h5><p>异步传输实现只使用了少量的EventLoop以及他们相关联的Thread，而且它们可能被多个Channel共享。这使得可以通过少量的Thread来支撑大量的Channel，而不是每个Channel分配一个Thread。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/1eventloop_meitu_2.jpg" alt="image">  </p>
<h6 id="2-阻塞传输"><a href="#2-阻塞传输" class="headerlink" title="2.阻塞传输"></a>2.阻塞传输</h6><p>会为每一个Channel分配一个EventLoop，和非阻塞`传输一样的是，每个Channel的I/O事件只会被与之对应的EventLoop的那个Thread所处理。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;首先，线程模型指定了操作系统、编程语言或者应用程序的&lt;em&gt;上下文中的线程管理&lt;/em&gt;的关键方面。Netty的线程模型，强大而又易用，在简化代码的同时，最大限度的提高性能和可维护性。学习这部分可能需要有一定的多线程的知识的基础，可以看看《Java并发编程实战》或者《并发编程的艺术》这两本书。&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty之组件与设计</title>
    <link href="http://yoursite.com/2018/06/15/Netty%20%E4%B9%8B%E7%BB%84%E4%BB%B6%E4%B8%8E%E8%AE%BE%E8%AE%A1%20/"/>
    <id>http://yoursite.com/2018/06/15/Netty 之组件与设计 /</id>
    <published>2018-06-15T13:53:00.000Z</published>
    <updated>2018-06-25T09:06:33.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Channel、EventLoop、ChannelFuture"><a href="#一、Channel、EventLoop、ChannelFuture" class="headerlink" title="一、Channel、EventLoop、ChannelFuture"></a>一、Channel、EventLoop、ChannelFuture</h3><p>这些类合在一起，可以被认为是Netty网络抽象的代表：  </p>
<ul>
<li>Channel——Socket</li>
<li>EventLoop——控制流、多线程处理、并发处理</li>
<li>ChannelFuture——异步通知<a id="more"></a>
<h4 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h4>EventLoop定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件。之后在Netty的线程模型中还会做更详细的讲解，我们先来看看EventLoop、Channel之间是怎样的关系。  </li>
</ul>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/EventLoopGroup.png" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/2184951-2e248d85df2a1a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/490" alt="image"><br>首先有EventLoopGroup，用来管理EventLoop的生命周期，默认情况下，一个EventLoopGroup中有两倍线程的EventLoop。创建Channel后，将Channel注册到EventLoop，之后在Channel的整个生命周期中，都由这个EventLoop来处理I/O事件。而实际上，每个EventLoop都会维护一个Selector和TaskQueue（之后的文章会进一步讨论）。  </p>
<p>EventLoop和Channel一般是一对多的形式，他们之间关系可总结为以下几点：  </p>
<ul>
<li>一个EventLoopGroup包含一个或者多个EventLoop；  </li>
<li>一个EventLoop在它的生命周期内只和一个Thread绑定；  </li>
<li>与EventLoop绑定的Thread会处理所有EventLoop要处理的I/O事件，也就是注册在EventLoop上Channel需要处理的事件；  </li>
<li>一个Channel在它的生命周期内只注册于一个EventLoop；  </li>
<li>一个EventLoop可能会被分配给一个或多个Channel。  </li>
</ul>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>Netty中所有的I/O操作都是异步的，因此一个操作不会立刻返回，我们需要一种在之后的某个时间点确定其结果的方法。Netty提供了ChannelFuture接口，它的addListener()方法注册了一个ChannelFutureListener，用于在某个操作完成时（无论是否成功）得到通知。这个异步是指编程模型上的异步，基于reactor模式的事件驱动，事件处理器的注册和处理器的执行都是异步的。  </p>
<p>如上一篇文章中的代码实例，bind()用于异步的绑定服务器，ctx.write(in)用于异步的将缓存中数据写到context等等。  </p>
<h3 id="二、ChannelHandler和ChannelPipeline"><a href="#二、ChannelHandler和ChannelPipeline" class="headerlink" title="二、ChannelHandler和ChannelPipeline"></a>二、ChannelHandler和ChannelPipeline</h3><h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p>ChannelHandler派生出ChannelInboundHandler和ChannelOutboundHandler接口。<br>如果有入站事件被读取，那么它会从ChannelPipeline的头部开始流动，并传递给第一个ChannelInboundHandler。这个handler具体会做怎样的处理，取决于它的具体功能，处理完之后，数据将会被传递给handler链中的下一个ChannelInboundHandler。最终到达ChannelPipeline的尾端，这样所有的入站事件处理就完成了。出站事件的处理与之相反。  </p>
<h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p><img src="https://upload-images.jianshu.io/upload_images/2184951-beacd91367f1f4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/629" alt="image">  </p>
<p>ChannelPipeline为ChannelHandler链提供了容器，并且定义了用于在该链上传播入站和出站事件流的API。每个Channel在创建时，会分配一个专属的ChannelPipeline。ChannelHandler安装到ChannelPipeline的过程如下：  </p>
<ul>
<li>一个ChannelInitializer的实现被注册到ServerBootstrap中；</li>
<li>当ChannelIntializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler，这些handler与Channel想关联，也可以根据需要进行动态的添加和删除；</li>
<li>ChannelIntializer将它自己从ChannelPipeline中移除。  </li>
</ul>
<p>ChannelHandler的执行顺序是由它们被添加的顺序决定的，第一个执行完会传递给下一个handler。  </p>
<h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>ChannelHandler被添加到ChannelPipeline时，它会被分配一个ChannelHandlerContext，它代表了ChannelHandler和ChannelPipeline之间的绑定，它的主要功能是管理它所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。</p>
<h4 id="Channel和ChannelHandlerContext相同方法调用的区别："><a href="#Channel和ChannelHandlerContext相同方法调用的区别：" class="headerlink" title="Channel和ChannelHandlerContext相同方法调用的区别："></a>Channel和ChannelHandlerContext相同方法调用的区别：</h4><p>Channel和ChannelHandlerContext有一些共同的方法，但是它们的调用存在一些差别：</p>
<ul>
<li>如果调用Channel或者ChannelPipeline上的这些方法，它们将沿着整个ChannelPipeline进行传播；</li>
<li>而如果调用位于ChannelHandlerContext上的这些相同方法，就会从ctx关联的ChannelHandler开始，并且只会传播给位于该ChannelPipeline中的下一个能够处理这个事件的ChannelHandler。  </li>
</ul>
<h3 id="三、ServerBootstrap和Bootstrap"><a href="#三、ServerBootstrap和Bootstrap" class="headerlink" title="三、ServerBootstrap和Bootstrap"></a>三、ServerBootstrap和Bootstrap</h3><p>Netty的引导类主要为应用程序提供了网络层的配置。对于服务端，涉及到将一个进程绑定到某个指定的端口；对于客户端，涉及到将一个进程连接到另一个运行在某个指定主机的指定端口上的进程。分为ServerBootstrap和Bootstrap这两种引导类。    </p>
<p>这两个是两种类型的引导：一个用于客户端（Bootstrap），一个用于服务器（ServerBootstrap），无论你的应用程序是使用哪种协议或者处理哪种类型的数据，唯一决定它该使用哪种引导类的是它是客户端还是服务端。  </p>
<p>两者最大的区别在于：引导一个客户端只需要一个EventLoopGroup，但是引导一个服务端需要两个EventLoopGroup，这是为什么呢？<br>原因在于服务器需要两组不同的Channel，第一组只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字Socket；而第二组将包含所有已创建的用来处理传入客户端连接的Channel。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/evenloop_meitu_2.jpg" alt="image">  </p>
<p>与ServerChannel相关联的EventLoopGroup将分配一个为传入连接请求创建Channel的EventLoop，一旦连接被接收，第二个EventLoopGroup就会给它的Channel分配一个EventLoop。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Channel、EventLoop、ChannelFuture&quot;&gt;&lt;a href=&quot;#一、Channel、EventLoop、ChannelFuture&quot; class=&quot;headerlink&quot; title=&quot;一、Channel、EventLoop、ChannelFuture&quot;&gt;&lt;/a&gt;一、Channel、EventLoop、ChannelFuture&lt;/h3&gt;&lt;p&gt;这些类合在一起，可以被认为是Netty网络抽象的代表：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channel——Socket&lt;/li&gt;
&lt;li&gt;EventLoop——控制流、多线程处理、并发处理&lt;/li&gt;
&lt;li&gt;ChannelFuture——异步通知
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty之构建Netty应用程序</title>
    <link href="http://yoursite.com/2018/06/14/Netty%E4%B9%8B%E6%9E%84%E5%BB%BANetty%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/14/Netty之构建Netty应用程序/</id>
    <published>2018-06-14T13:53:00.000Z</published>
    <updated>2018-06-25T09:02:57.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、编写Netty服务器"><a href="#一、编写Netty服务器" class="headerlink" title="一、编写Netty服务器"></a>一、编写Netty服务器</h3><p>所有的Netty服务器都需要以下两个部分：  </p>
<ul>
<li>至少一个ChannelHandler——用于处理服务器从客户端接收的数据  </li>
<li>引导Bootstrap——这是配置服务器的启动代码，会将服务器绑定到它要监听连接请求的端口上  <a id="more"></a>
</li>
</ul>
<h4 id="ChanneleHandler和业务逻辑"><a href="#ChanneleHandler和业务逻辑" class="headerlink" title="ChanneleHandler和业务逻辑"></a>ChanneleHandler和业务逻辑</h4><p>Netty服务器会响应传入的消息，所以它需要实现ChannelInboundHandler接口，用来定义响应入站事件的方法。简单的应用程序继承ChannelInboundHandlerAdapter类就可以了，它提供了ChannelInboundHandler的默认实现。<br>其中，我们感兴趣的方法是：</p>
<ul>
<li>channelRead()——对于每个传入的消息都要调用</li>
<li>channelReadComplete()——通知handler最后一次对channelRead()的调用是当前批量读取中的最后一条消息</li>
<li>exceptionCaught()——在读取操作期间，有异常抛出时会调用</li>
</ul>
<p>下面来编写这个EchoServerHandler：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//表示ChannelHandler可以被多个Channel安全的共享</span></div><div class="line"><span class="meta">@Sharable</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span>&#123;</span></div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> channelRead(ChannelHandlerContext ctx, Object msg)&#123;</div><div class="line">        ByteBuf <span class="keyword">in</span> = (ByteBuf) msg;</div><div class="line">        System.out.println(<span class="string">"Server received: "</span> + <span class="keyword">in</span>.toString(CharasetUtil.UTF_8));</div><div class="line">        ctx.write(<span class="keyword">in</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> channelReadComplete(ChannelHandlerContext ctx)&#123;</div><div class="line">        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</div><div class="line">        .addListener(ChannelFutureListener.CLOSE);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause)&#123;</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个Channel都拥有与之相关联的ChannelPipeline，其持有一个ChannelHandler的实例链。如果没有捕获异常，那么所接收的异常会被传递到ChannelPipeline的尾端并被记录。  </p>
<h4 id="引导服务器"><a href="#引导服务器" class="headerlink" title="引导服务器"></a>引导服务器</h4><p>下面编写EchoServer类：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> clasee EchoServer&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">new</span> EchoServer(port).start();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</div><div class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">            b.group(group)</div><div class="line">            .channel(NioServerSocketChannel.class)</div><div class="line">            .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</div><div class="line">            <span class="comment">//当一个新的连接接受时，就会创建一个新的子Channel，</span></div><div class="line">            <span class="comment">//ChannelInitializer会把serverHandler实例添加到该Channel的ChannelPipeline中</span></div><div class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123; </div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">                    ch.pipeline().addLast(serverHandler);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="comment">//异步绑定服务器，调用sync()阻塞等待直到绑定完成</span></div><div class="line">            ChannelFuture f = b.bind().sync();</div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            <span class="comment">//关闭EventLoopGroup，释放所有资源</span></div><div class="line">            group.shutdownGracefully().sync();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、编写客户端"><a href="#二、编写客户端" class="headerlink" title="二、编写客户端"></a>二、编写客户端</h3><p>客户端主要完成以下工作：  </p>
<ul>
<li>连接到服务器</li>
<li>发送一个或多个消息</li>
<li>对于每个消息，等待并接收从服务器发回的相同的消息</li>
<li>关闭连接</li>
</ul>
<h4 id="通过ChannelHandler实现客户端逻辑"><a href="#通过ChannelHandler实现客户端逻辑" class="headerlink" title="通过ChannelHandler实现客户端逻辑"></a>通过ChannelHandler实现客户端逻辑</h4><p>跟服务器类似，客户端需要一个用来处理数据的ChannelInboundHandler，在此场景，我们扩展SimpleChannelInboundHandler类来处理所有必须的任务，我们要重写下面几个方法：  </p>
<ul>
<li>channelActive()——在跟服务器的连接已经建立之后会被调用</li>
<li>channelRead0()——从服务器接收到一条消息时会被调用</li>
<li>exceptionCaught()——在处理过程中引发异常时调用  </li>
</ul>
<p>客户端EchoClientHandler如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Sharable</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;</span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//在一个连接被建立时调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</div><div class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty works!"</span>, CharasetUtil.UTF_8));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//每当接收数据时，都会调用这个方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span></span>&#123;</div><div class="line">        System.out.print(<span class="string">"Client received :"</span> + in.toString(CharasetUtil.UTF_8));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="SimpleChannelInboundHandler与ChannelInboundHandler的区别"><a href="#SimpleChannelInboundHandler与ChannelInboundHandler的区别" class="headerlink" title="SimpleChannelInboundHandler与ChannelInboundHandler的区别"></a>SimpleChannelInboundHandler与ChannelInboundHandler的区别</h5><p>在客户端，当channelRead0()方法完成后，客户端已经有了传入消息，并且已经处理完成了，在这个方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用；  </p>
<p>而在服务端中，仍然需要将传入的消息回送给发送者。而ctx.write(in)是异步的，直到channelRead()方法返回后可能仍然没有完成，所以serverHandler扩展了ChannelInboundHandler，它不会再这个时间点上释放消息的ByteBuf。</p>
<h4 id="引导客户端"><a href="#引导客户端" class="headerlink" title="引导客户端"></a>引导客户端</h4><p>与引导服务端类似，知识客户端需要用主机和端口参数连接远程地址。<br>EchoClient类如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.host = host;</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</div><div class="line">            b.group(group)</div><div class="line">            .channel(NioSocketChannel.class)</div><div class="line">            .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</div><div class="line">            .<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelIntializer&lt;SocketChannel&gt;()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="comment">//阻塞等待连接完成</span></div><div class="line">            ChannelFuture d = b.connect().sync();</div><div class="line">            <span class="comment">//阻塞直到关闭</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            group.shutdownGracefully().sync();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        String host = args[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">new</span> EchoClient(host, port).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Server</span> received: Netty works!</div></pre></td></tr></table></figure></p>
<p>这样，我们的Netty应用程序就编写好了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、编写Netty服务器&quot;&gt;&lt;a href=&quot;#一、编写Netty服务器&quot; class=&quot;headerlink&quot; title=&quot;一、编写Netty服务器&quot;&gt;&lt;/a&gt;一、编写Netty服务器&lt;/h3&gt;&lt;p&gt;所有的Netty服务器都需要以下两个部分：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;至少一个ChannelHandler——用于处理服务器从客户端接收的数据  &lt;/li&gt;
&lt;li&gt;引导Bootstrap——这是配置服务器的启动代码，会将服务器绑定到它要监听连接请求的端口上
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty剖析之核心组件</title>
    <link href="http://yoursite.com/2018/06/13/Netty%E5%89%96%E6%9E%90%E4%B9%8B%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/06/13/Netty剖析之核心组件/</id>
    <published>2018-06-13T13:53:00.000Z</published>
    <updated>2018-06-14T09:18:37.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的博文《Java NIO原理解析》里面，主要讲了NIO的一些原理，几种IO模型的对比，NIO中三个重要的组件Channel，Selector以及Buffer，通过Selector单线程轮询状态实现了IO复用机制，这些在这就不重新讨论了。  </p>
<p>然而，原生的NIO方法比较复杂，Netty进行了很好的封装，提供更易于使用的API，性能更好，健壮性、安全性也很好，在很多地方都能见到Netty的身影，比如阿里的Dubbo分布式框架，底层就使用Netty作为网络通信框架，接下来会用几篇博文来详细讲下Netty这个高性能的网络框架。<br><a id="more"></a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Netty是什么呢？Netty是一款<strong>异步</strong>的<strong>事件驱动</strong>的网络应用程序框架，支持快速地开发可维护的<strong>高性能</strong>面向协议的服务器和客户端。  </p>
<p>从下面Netty的框架图可以看出Netty支持很多协议，安全协议的支持，高性能Google序列化协议protobuf的支持等等，可以说很强大了。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/netty.png" alt="image">  </p>
<p><strong>异步，事件驱动，高性能</strong>是Netty关键词。  </p>
<ul>
<li><p><strong>异步</strong>就是发出请求之后就会返回，而不用等到请求都完成后再返回，异步主要通过回调通知来实现，即事件完成后会有回调来告诉发出请求的线程；比如发出读请求后，线程就直接返回了，待读工作完成后会有回调通知线程读的工作已经完成好了。  </p>
</li>
<li><p><strong>事件驱动</strong>就是说，如果可读这个事件发生了，那么就会驱动进行读事件；同样，如果已经可写了，那么就会驱动写事件的发生，这些会涉及到ChannelHandler等，后面会一一介绍的。  </p>
</li>
</ul>
<h2 id="Netty的核心组件"><a href="#Netty的核心组件" class="headerlink" title="Netty的核心组件"></a>Netty的核心组件</h2><h3 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1. Channel"></a>1. Channel</h3><p>Java NIO中就有Channel这个概念，可以一同理解。它代表一个可以到实体的开放连接（这里的实体可以指一个硬件设备，一个文件，一个套接字等），又可以称作”通道”，是传入（入站）或者传出（出站）数据的载体。</p>
<h3 id="2-回调"><a href="#2-回调" class="headerlink" title="2. 回调"></a>2. 回调</h3><p>一个回调就是一个方法，就是在完成某种操作时执行的方法，当一个回调被触发时，相关的事件会被一个ChannelHandler的实现处理。比如数据准备好可以开始读时，就可以回调进行读操作。  </p>
<h3 id="3-Future"><a href="#3-Future" class="headerlink" title="3. Future"></a>3. Future</h3><p>Future提供另一种在操作完成时通知应用程序的方式，会在未来某个时刻完成，并提供对其结果的访问，与ChannelFutureListener配合使用。  </p>
<h3 id="4-事件和ChannelHandler"><a href="#4-事件和ChannelHandler" class="headerlink" title="4. 事件和ChannelHandler"></a>4. 事件和ChannelHandler</h3><p>Netty使用不同的事件来通知我们状态的改变或者操作的改变，使得我们可以基于发生的事件来激活适当的动作。这些动作可以是：记录日志、数据转换、流控制、应用程序逻辑、数据的读写等。  </p>
<p>Netty的事件是按照与入站或出站数据流相关性进行分类的。<br>Netty定义了两个重要的ChannelHandler子接口，后面还会经常碰到的：  </p>
<ul>
<li>ChannelInboundHandler：处理入站数据以及各种状态变化  </li>
<li>ChannelOutboundHandler：处理出站苏沪并且允许拦截所有的操作</li>
</ul>
<p>对于入站数据或者相关状态更改而出发的事件有： </p>
<ul>
<li>连接被激活或者连接失活</li>
<li>数据读取</li>
<li>用户事件</li>
<li>错误事件，期间发生的exception</li>
</ul>
<p>对于出站事件，包括：</p>
<ul>
<li>打开或者关闭到远程节点的连接</li>
<li>将数据写到或者冲刷到套接字</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文中，主要简单论述了Netty是什么，几个核心组件，其实Netty中还有几个很重要的概念，EventLoopGroup，EventLoop，ChannelHandler，ChannelHandlerContext，ChannelPipeline等很重要的概念。  </p>
<p>Netty通过触发事件将Selector从应用程序中抽象出来，消除了所有本来需要手动派写的派发代码，比如selector单线程循环判断是否有需要处理的新事件，之后根据事件的具体类型做进一步处理，如果可读就分配线程去进行读操作。后面会写个Java NIO和Netty在写网络通信时代码上的区别对比。  </p>
<p>在Netty内部，会为每个Channel分配一个EventLoop，用来处理所有事件，包括：  </p>
<ul>
<li>注册感兴趣的事件</li>
<li>将事件派发给ChannelHandler</li>
<li>安排进一步的动作  </li>
</ul>
<p>需要注意的是，下面这句话可能还会在之后的文章出现，因为很重要。EventLoop本身只由一个线程驱动，该线程处理了一个Channel的所有I/O事件，并且在该EventLoop在整个生命周期内不会改变，这样带来的优越性会在之后的线程模型相关文章中再具体说，而本身其实若干个EventLoop又会放在一个EventLoopGroup中。  </p>
<p>一个Channel的EventLoop是唯一的，但是多个Channel可以指向同一个EventLoop。一个Channel会有一个ChannelPipeline与之绑定，在ChannelPipeline中会被放置一个或多个ChannelHandler，pipeline嘛就是管道，用于放多个handler，handler是干啥的呢，就是用来进行对入站或出站的处理。简单来说，就是对一个Channel的ChannelPipeline中若干个ChannelHandler的调用以及其他一些处理都是通过一个EventLoop来完成的，具体的，会在之后的文章进行更详细的分析。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前的博文《Java NIO原理解析》里面，主要讲了NIO的一些原理，几种IO模型的对比，NIO中三个重要的组件Channel，Selector以及Buffer，通过Selector单线程轮询状态实现了IO复用机制，这些在这就不重新讨论了。  &lt;/p&gt;
&lt;p&gt;然而，原生的NIO方法比较复杂，Netty进行了很好的封装，提供更易于使用的API，性能更好，健壮性、安全性也很好，在很多地方都能见到Netty的身影，比如阿里的Dubbo分布式框架，底层就使用Netty作为网络通信框架，接下来会用几篇博文来详细讲下Netty这个高性能的网络框架。&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析之IOC容器（二）</title>
    <link href="http://yoursite.com/2018/05/11/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIOC%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/11/Spring源码解析之IOC容器（二）/</id>
    <published>2018-05-11T03:53:00.000Z</published>
    <updated>2018-06-14T06:14:01.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇，我们主要分析了IOC容器初始化过程中，BeanDifinitions的定位、载入解析以及注册的流程。在这篇文章，我们会来谈一谈IOC容器的依赖注入及其他相关特性的分析。</p>
<h2 id="IOC容器的依赖注入"><a href="#IOC容器的依赖注入" class="headerlink" title="IOC容器的依赖注入"></a>IOC容器的依赖注入</h2><p>依赖注入的过程是用户第一次向IOC容器索要Bean时出发的，即使用getBean()方法时。当然也有例外，当我们设置了lazy-init属性后，会让容器完成对Bean的预实例化，这个这个预实例化其实也是一个依赖注入的过程，只是时机和场景不同。（可见refresh方法中的注解）<br><a id="more"></a></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">pulic <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>&#123;</div><div class="line">    ...</div><div class="line">    prepareRefresh();</div><div class="line">    </div><div class="line">    <span class="comment">//这里是子类中启动refreshBeanFactory()的地方，这个方法主要负责：</span></div><div class="line">    <span class="comment">//①BeanFactory如何已存在就更新，不存在就创建。</span></div><div class="line">    <span class="comment">//②其中有个loadBeanDefinitions(beanFactory)方法，在第一篇中提到了该方法，用来加载解析Bean的定义，把用户自定义的数据结构转换成容器中特定的数据结构。</span></div><div class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line">    </div><div class="line">    <span class="comment">//此方法用来添加一些Spring本身需要的工具类</span></div><div class="line">    prepareBeanFactory(beanFactory);</div><div class="line">    </div><div class="line">    <span class="comment">//下面两个方法用于对已经构建的BeanFactory的配置做修改</span></div><div class="line">    <span class="comment">//设置BeanFactory的后置处理</span></div><div class="line">    postProcessBeanFactory(beanFactory);</div><div class="line">    <span class="comment">//调用BeanFactory的后处理器，这些后处理器是在Bean定义中向容器注册的</span></div><div class="line">    invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">    </div><div class="line">    <span class="comment">//注册Bean的后处理器，在Bean的创建过程中调用。</span></div><div class="line">    <span class="comment">//获取用户定义的实现了BeanPostProcessors接口的子类，接口中实现了两个方法postProcessBeforeInitialization和</span></div><div class="line">    <span class="comment">//postProcessAfterInitialization分别在Bean对象初始化时和初始化后执行，在此可自己定义操作。（可结合下面Bean的生命周期一起理解）</span></div><div class="line">    registerBeanPostProcessors(beanFactory);</div><div class="line">    </div><div class="line">    <span class="comment">//对上下文中的消息源进行初始化</span></div><div class="line">    initMessageSource();</div><div class="line">    </div><div class="line">    <span class="comment">//初始化上下文中的事件机制</span></div><div class="line">    initApplicationEventMulticaster();</div><div class="line">    </div><div class="line">    <span class="comment">//初始化其他特殊Bean</span></div><div class="line">    onRefresh();</div><div class="line">    </div><div class="line">    <span class="comment">//检查监听Bean并且将这些Bean向容器注册</span></div><div class="line">    registerListeners();</div><div class="line">    </div><div class="line">    <span class="comment">//实例化所有的（non-lazy-init）单例，一般情况下不会进行依赖注入；如果设置了lazy-init属性，会直接在这使用getBean()去触发依赖注入，</span></div><div class="line">    <span class="comment">//而一般依赖注入是发生在IOC容器初始化后，第一次执行getBean时，两者时机不同，场景不同。</span></div><div class="line">    <span class="comment">//在这里只是完成Bean生命周期的第一步——实例化</span></div><div class="line">    finishBeanFactoryInitialization(beanFactory);</div><div class="line">    </div><div class="line">    <span class="comment">//发布容器事件，结束refresh过程</span></div><div class="line">    finishRefresh;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一、Bean对象关系依赖注入的流程"><a href="#一、Bean对象关系依赖注入的流程" class="headerlink" title="一、Bean对象关系依赖注入的流程"></a>一、Bean对象关系依赖注入的流程</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<h3 id="二、Spring-bean的生命周期"><a href="#二、Spring-bean的生命周期" class="headerlink" title="二、Spring bean的生命周期"></a>二、Spring bean的生命周期</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/spring.jpg" alt="image"><br>首先，Bean的生命周期可以简单分为以下几步：  </p>
<ul>
<li>Bean实例的创建（对应下面的1）  </li>
<li>为Bean实例设置属性（对应下面的2~5）  </li>
<li>调用Bean的初始化方法（对应下面的6~8）  </li>
<li>应用通过Ioc容器使用Bean（对应下面的9）  </li>
<li>当容器关闭时，调用Bean的销毁方法（对应下面的10）    </li>
</ul>
<h4 id="具体步骤如下"><a href="#具体步骤如下" class="headerlink" title="具体步骤如下"></a>具体步骤如下</h4><ol>
<li>Spring对Bean进行实例化（相当于程序中的new Xx()）  </li>
<li>Spring将值和Bean的引用注入进Bean对应的属性中（polulateBean()对对象依赖关系进行注入）<br>//3~5 Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean</li>
<li>如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()方法（实现BeanNameAware清主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的）  </li>
<li>如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等）  </li>
<li>如果Bean实现了ApplicationContextAware接口，Spring容器将调用setApplicationContext(ApplicationContext ctx)方法，把y应用上下文作为参数传入.(作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory )  </li>
<li>如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）  </li>
<li>如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。  </li>
<li>如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )  </li>
<li>经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁  </li>
<li>如果Bean实现了DispostbleBean接口，Spring将调用它的destory方法，作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法。  </li>
</ol>
<h3 id="三、FactoryBean"><a href="#三、FactoryBean" class="headerlink" title="三、FactoryBean"></a>三、FactoryBean</h3><p>FactoryBean是特殊的Bean，是一个工厂Bean，可以产生Bean的Bean。如果一个类继承FactoryBean，用户可以自己定义产生实例对象的方法，只需实现这个类的getObject方法。通过调用这个对象的getObject方法就能获取用户自定义产生的对象，为Spring提供了很好的扩展性。  </p>
<h4 id="FactoryBean和BeanFactory的区别？"><a href="#FactoryBean和BeanFactory的区别？" class="headerlink" title="FactoryBean和BeanFactory的区别？"></a>FactoryBean和BeanFactory的区别？</h4><p>BeanFactory是Ioc容器最基本的实现，负责生产和管理bean，为其他具体的Ioc容器提供了最基本的规范，例如DefaultListableBeanFactory,XmlBeanFactory,ApplicationContext 等具体的容器都是实现了BeanFactory，再在其基础之上附加了其他的功能。  </p>
<p>FactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。要想获取FactoryBean的实现类，就要getBean(&amp;BeanName)，在BeanName之前加上&amp;。FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单工厂模式和装饰模式，我们可以在getObject()方法中灵活配置。  </p>
<p>FactoryBean（通常情况下，Bean无须自己实现工厂模式，Spring容器担任工厂角色；但少数情况下容器的Bean本身就是工厂，其左右是产生其他Bean实例），这种情况下，bean不需要特别的要求，只需提供一个工厂方法，该方法用来返回其他Bean实例，由工厂bean产生的bean实例，不再由Spring容器产生，所以不用在配置文件中提供class元素。   </p>
<h3 id="四、BeanPostProcessor"><a href="#四、BeanPostProcessor" class="headerlink" title="四、BeanPostProcessor"></a>四、BeanPostProcessor</h3><p>这是Bean的后置处理器，是一个监听器，可以监听容器触发的事件。将它向IOC容器注册后，容器中管理的Bean具备了接收IOC容器事件回调的能力。BeanPostProcessor是一个接口类，有两个接口方法，分别是postProcessBeforeInitialization和postProcessAfterInitialization，分别在Bean的初始化前和初始化后提供回调入口。postProcessBeforeInitialization和populateBean之间的关系如下：  </p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Object</span> exposedObject = <span class="keyword">bean; </span> </div><div class="line"><span class="keyword">populateBean(beanName, </span>mbd, instanceWrapper)<span class="comment">;  </span></div><div class="line">//在完成对<span class="keyword">Bean的生成和依赖注入时候，开始对Bean进行初始化，这个初始化过程包括了对</span></div><div class="line">//postProcessBeforeInitialization的回调。即<span class="keyword">Bean生命周期中before </span>- initialize - after这种顺序</div><div class="line"><span class="symbol">exposedObject</span> = initializeBean(<span class="keyword">beanName, </span>exposedObject, mbd)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h3 id="五、autowiring（自动依赖装配）"><a href="#五、autowiring（自动依赖装配）" class="headerlink" title="五、autowiring（自动依赖装配）"></a>五、autowiring（自动依赖装配）</h3><p>在自动装配中，不需要对Bean属性做显式的依赖关系声明，只需要配置好autowiring属性，IOC容器会根据这个属性的配置，使用反射自动查找属性的类型或者名字，然后基于属性的类型或者名字来自动匹配IOC容器中的Bean，从而自动的完成依赖注入。  </p>
<p>在populateBean的实现中，在处理一般的Bean之前，先对autowiring属性进行处理。如果当前的Bean配置了autowire_by_name和autowire_by_type，会相应的调用autowireByName或者autowireByType方法。  </p>
<p>以autowireByName为例，进行以下几个步骤：  </p>
<ul>
<li>首先得到Bean的属性名，这些信息在BeanWrapper和BeanDefinition中已经封装好了</li>
<li>使用属性名作为Bean名字使用getBean()方法向容器索取Bean，这个操作会触发当前Bean依赖的Bean的依赖注入，从而得到属性对应的依赖Bean</li>
<li>最后，把这个依赖Bean注入到当前Bean的属性中去。完成操作！</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇，我们主要分析了IOC容器初始化过程中，BeanDifinitions的定位、载入解析以及注册的流程。在这篇文章，我们会来谈一谈IOC容器的依赖注入及其他相关特性的分析。&lt;/p&gt;
&lt;h2 id=&quot;IOC容器的依赖注入&quot;&gt;&lt;a href=&quot;#IOC容器的依赖注入&quot; class=&quot;headerlink&quot; title=&quot;IOC容器的依赖注入&quot;&gt;&lt;/a&gt;IOC容器的依赖注入&lt;/h2&gt;&lt;p&gt;依赖注入的过程是用户第一次向IOC容器索要Bean时出发的，即使用getBean()方法时。当然也有例外，当我们设置了lazy-init属性后，会让容器完成对Bean的预实例化，这个这个预实例化其实也是一个依赖注入的过程，只是时机和场景不同。（可见refresh方法中的注解）&lt;br&gt;
    
    </summary>
    
      <category term="Spring源码解析" scheme="http://yoursite.com/categories/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码解析之IOC容器（一）</title>
    <link href="http://yoursite.com/2018/04/20/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIOC%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/20/Spring源码解析之IOC容器（一）/</id>
    <published>2018-04-20T10:45:00.000Z</published>
    <updated>2018-04-20T11:02:02.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直想阅读下Spring的源码，但是翻翻书又感觉这个好复杂，不想去看，所以一直拖到现在，昨天定下心看了下书，觉得并没有那么晦涩难懂，还是要克服惧怕未接触的事物，敢于去克服自己的弱点。主要先看Spring的两大核心IOC和AOP，参考书籍是计文柯的《Spring技术内幕》。这篇文章主要先讲下IOC容器的内部实现。  </p>
<h2 id="IOC容器简介"><a href="#IOC容器简介" class="headerlink" title="IOC容器简介"></a>IOC容器简介</h2><p>IOC即控制反转，这里的反转指的是对象依赖关系的管理被反转了，转到IOC容器上了，对象之间的相互依赖关系由IOC容器进行管理，并由容器完成对象的注入。  </p>
<a id="more"></a>
<h2 id="一、IOC容器的设计与实现"><a href="#一、IOC容器的设计与实现" class="headerlink" title="一、IOC容器的设计与实现"></a>一、IOC容器的设计与实现</h2><p>在Spring容器的设计中，有两个主要的容器系列，一个是实现<strong>BeanFactory</strong>接口的简单容器系列，这系列的容器只实现了容器的<strong>最基本功能</strong>；另一个是<strong>ApplicationContext应用上下文</strong>，作为<strong>容器的高级形态而存在</strong>。应用上下文在简单容器的基础上，增加了许多面向框架的特性，同时对应用环境作了许多适配。  </p>
<h3 id="BeanDefintion"><a href="#BeanDefintion" class="headerlink" title="BeanDefintion"></a>BeanDefintion</h3><p>在Spring提供的基本容器的接口定义和实现的基础上，通过定义BeanDefintion来管理Spring应用中的各种对象以及它们之间的相互依赖关系。BeanDefintion抽象了我们对Bean的定义，是让容器起作用的主要数据类型。  </p>
<p>BeanDefintion就是对依赖反转模式中管理的对象依赖关系的数据抽象，是容器实现依赖反转功能的核心数据结构，依赖反转功能都是围绕对这个BeanDefintion的处理来完成的。BeanDefintion就像是容器里装的水，有了这些基本数据，容器才能够发挥作用。</p>
<h2 id="二、Spring-IOC容器的实现"><a href="#二、Spring-IOC容器的实现" class="headerlink" title="二、Spring IOC容器的实现"></a>二、Spring IOC容器的实现</h2><p><img src="http://osrmzp0jr.bkt.clouddn.com/ioc1.png" alt="image">  </p>
<ul>
<li><p>从接口BeanFactory到HierarchicalBeanFactory到ConfigurableBeanFactory，是一条主要的BeanFactory设计路径。  </p>
<ul>
<li>BeanFactory定义了基本的IOC容器规范，包含了像getBean()这样的IOC容器基本方法。  </li>
<li>HierarchicalBeanFactory继承BeanFactory的基本接口之后，增加了getParentBeanFactory()的接口功能，使BeanFactory具备了双亲IOC容器的管理功能。</li>
<li>ConfigurableBeanFactory接口中，主要定义一些对BeanFactory的配置功能，如setParentBeanFactory()设置双亲IOC容器，通过addBeanPostProcessor()配置Bean后处理器等。  </li>
</ul>
</li>
<li><p>第二条设计主线是，以ApplicationContext应用上下文接口为核心的接口设计，涉及的主要接口设计有，从BeanFactory到ListableBeanFactory，再到ApplicationContext，再到我们常用的应用上下文WebApplicationContext和ConfigurableApplicationContext。</p>
<ul>
<li>在ListableBeanFactory接口中，细化了许多BeanFactory的接口功能，比如getBeanDafiinitions()。</li>
<li>对于ApplicationContext接口，通过继承MessageSource、ResourceLoader、ApplicationEventPublisher接口，在BeanFactory简单容器基础上添加了许多对高级容器特性的支持。</li>
</ul>
</li>
<li><p>在ApplicationContext的设计中，一方面，可以看到它集成了BeanFactory接口体系中的ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory等BeanFactory的接口，具备了BeanFactory IOC容器的基本功能；另一方面，通过继承MessageSource、ResourceLoader、ApplicationEventPublisher接口，具备更高级的特性。  </p>
</li>
</ul>
<h3 id="①BeanFactory"><a href="#①BeanFactory" class="headerlink" title="①BeanFactory"></a>①BeanFactory</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/beanF.png" alt="image"><br>上图中定义的接口方法勾画出了IOC容器的基本特性。</p>
<h4 id="BeanFactory的设计原理"><a href="#BeanFactory的设计原理" class="headerlink" title="BeanFactory的设计原理"></a>BeanFactory的设计原理</h4><p>以XmlBeanFactory为例，说明简单IOC容器的设计原理。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/xmlbf.png" alt="image"><br>XmlBeanFactory继承自<strong>DefaultListableBeanFactory</strong>这个类，DefaultListableBeanFactory十分重要，是经常要用到的一个IOC容器的实现，包含了基本IOC容器所具有的重要功能。在Spring中，DefaultListableBeanFactory作为一个默认的功能完整的IOC容器来使用，在其他容器，如ApplicationContext中，也是通过持有或扩展DefaultListableBeanFactory来获得基本的IOC容器的功能的。  </p>
<p>XmlBeanFactory是一个可以读取以XML文件方式定义的BeanDefinition的IOC容器。XML读取功能是如何实现的呢？<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%883.56.21.png" alt="image"><br>在XmlBeanFactory中，初始化一个XmlBeanDefinitionReader对象用于处理XML，在构造XmlBeanFactory时，指定BeanDefinition的信息来源，这个信息来源需要封装成Resource类来给出，然后将Resource作为构造参数传递给XmlBeanFactory构造函数，这样IOC容器就可以方便的定位到需要的BeanDefinition信息，来对Bean完成容器的初始化和依赖注入的过程。  </p>
<h3 id="②ApplicationContext"><a href="#②ApplicationContext" class="headerlink" title="②ApplicationContext"></a>②ApplicationContext</h3><p>ApplicationContext在BeanFactory的基础上添加了附加功能，使其成为高级形态意义的容器。提供了以下BeanFactory不具备的特性：  </p>
<ul>
<li>支持不同的信息源。ApplicationContext扩展了MessageSource接口，使其可以支持国际化的实现，为开发多语言版本的应用提供服务。</li>
<li>访问资源。体现在对ResourceLoader和Resource的支持上，这样我们可以从不同地方得到Bean定义资源。</li>
<li>支持应用事件。继承接口ApplicationEventPublisher，在上下文中引入了事件机制。与Bean生命周期的结合为Bean的管理提供便利。</li>
<li>在ApplicationContext中提供的附加服务。</li>
</ul>
<h4 id="ApplicationContext设计原理"><a href="#ApplicationContext设计原理" class="headerlink" title="ApplicationContext设计原理"></a>ApplicationContext设计原理</h4><p>以FileSystemXmlApplicationContext的实现为例来说明设计原理。主要基本功能已经在其基类AbstractXmlApplicationContext中实现了，作为一个具体的应用上下文，只需要实现和它自身设计相关的两个功能。  </p>
<ul>
<li>一个功能是：如果直接使用FileSystemXmlApplicationContext，对于实例化这个应用上下文的支持，同时会启动IOC容器的refresh()过程，这个refresh()过程会涉及到IOC容器启动的一系列复杂操作。</li>
<li>另一个功能是：是FileSystemXmlApplicationContext设计具体相关的功能，这部分定义如何从文件系统中加载XML的Bean定义资源。</li>
</ul>
<p>通过这个过程，可以为在文件系统中读取以XML形式存在的BeanDefinition做准备，由于不同的应用上下文实现对应着不同的读取BeanDefinition的方式。FileSystemXmlApplicationContext的读取方式如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected<span class="built_in"> Resource </span>getResourceByPath(String path)&#123;</div><div class="line">    <span class="keyword">if</span>(path != <span class="literal">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>))&#123;</div><div class="line">        path = path.substring(1);</div><div class="line">    &#125;</div><div class="line">    return new FileSystemResource(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，就可以得到FileSystemResource的资源定位了。</p>
<h2 id="二、IOC容器的初始化过程"><a href="#二、IOC容器的初始化过程" class="headerlink" title="二、IOC容器的初始化过程"></a>二、IOC容器的初始化过程</h2><p>IOC容器的初始化是通过refresh()方法来启动的，这个启动包括BeanDefinition的Resource定位、载入和注入三个基本过程。  </p>
<ol>
<li>第一个过程：Resource的定位过程。指的是BeanDefinition的资源定位，由ResourceLoader通过统一的Resource接口来完成，这个Resource对各种形式的BeanDefinition的使用提供了统一接口。  </li>
<li>第二个过程：BeanDefinition的载入。这个载入过程是把定义好的Bean表示成IOC容器内部的数据结构，而这个容器的内部数据结构就是BeanDefinition。</li>
<li>第三个过程：向IOC容器注册这些BeanDefinition的过程。这个过程通过BeanDefinitionRegistry接口的实现来完成。在IOC容器内部把BeanDefinition注入到一个HashMap中去，IOC容器就是通过这个HahshMap来持有这些BeanDefinition数据的。  </li>
</ol>
<p>这里谈的IOC容器初始化的过程，一般不包含Bean的依赖注入的实现，<strong>依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候</strong>。除非设置了lazyinit属性，那么这个Bean的依赖注入在IOC容器初始化时就预先完成了。  </p>
<h3 id="1、BeanDefinition的Resource定位"><a href="#1、BeanDefinition的Resource定位" class="headerlink" title="1、BeanDefinition的Resource定位"></a>1、BeanDefinition的Resource定位</h3><p>以编程的方式实现DefaultListableBeanFactory时，首先要定义一个Resource来定位容器使用的BeanDefinition，这时使用的是ClassPathResource，意味着Spring会在类路径中去寻找以文件形式存在的BeanDefinition信息。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%883.56.31.png" alt="image">  </p>
<p>在ApplicationContext中，Spring已经提供好了一系列加载不同Resource的读取器的实现，不需要为它再配置特定的读取器才能完成功能。</p>
<p>以FileSystemApplicationContext为例，看看是如何实现Resource定位的：  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%884.47.21.png" alt="image">  </p>
<p>refreshBeanFactory()在refresh中被调用，在该方法中，首先通过createBeanFactory构建一个IOC容器供ApplicationContext使用，即前面提到的DefaultListableBeanFactory，同时启动loadBeanDefinitions来载入BeanDefinition。  </p>
<h3 id="2、BeanDefinition的载入与解析"><a href="#2、BeanDefinition的载入与解析" class="headerlink" title="2、BeanDefinition的载入与解析"></a>2、BeanDefinition的载入与解析</h3><p>在完成对BeanDefinition的Resource定位的分析后，进行整个BeanDefinition信息的载入过程，这个载入过程，相当于将定义好的BeanDefinition在IOC容器中转化为一个Spring内部表示的数据结构的过程。refresh()方法是IOC容器初始化的开始：  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%885.13.45.png" alt="image">  </p>
<p>载入过程的开始，可以从FileSystemApplicationContext的基类AbstractRefreshableApplicationContext的loadBeanDefinitons()方法中看到，可以从这个基类的refreshBeanFactory()开始，了解这个Bean定义信息载入的过程。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%885.22.02.png" alt="image">  </p>
<p>在读取器reader中，得到代表XML文件的Resource，读取器在打开IO流后得到XML的文件对象。有了这个文件对象后，就可以按照Spring的Bean定义规则来对这个XML文档树进行解析了，这个<strong>解析是交给BeanDefinitionParserDelegate的registerBeanDefinitions来完成的</strong>。  </p>
<p>使用DefaultDocumentLoader得到Document对象，<strong>那么Spring是怎样按照Bean的语义进行解析并转化为容器内部数据结构的？</strong> 这个过程在registerBeanDefinitions(doc, resource)中完成的。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%885.33.10.png" alt="image"><br>载入过程分为两部分：首先通过调用XML解析器得到document对象；完成XML解析后，按照Spring的Bean规则进行解析，这个解析是在documentReader.registerBeanDefinitions()中具体实现的（见上面代码）。  </p>
<p>解析处理完成后，解析结果会放到BeanDefinition对象中，并由BeanDefinitionHolder对象来持有，这个BeanDefinitionHolder除了持有BeanDefinition对象外，还持有其他相关信息，如Bean的名字、别名集合等。  </p>
<p>通过逐层的解析，我们在XML文件中定义的BeanDefinition就被整个载入到了IOC容器中，并在容器中建立数据映射。通过以上的载入过程，IOC容器大致完成了管理Bean对象的数据准备工作。</p>
<h3 id="3、BeanDefinition在IOC容器中的注册"><a href="#3、BeanDefinition在IOC容器中的注册" class="headerlink" title="3、BeanDefinition在IOC容器中的注册"></a>3、BeanDefinition在IOC容器中的注册</h3><p>经过BeanDefinition在IOC容器的载入和解析，用户定义的BeanDefinition信息已经在IOC容器里建立起了自己的数据结构以及对应的数据表示，但此时这些数据还不能供IOC容器直接使用，需要在IOC容器进行注册。在DefaultListableBeanFactory中，是通过一个HashMap来持有载入的BeanDefinition的。</p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%886.02.19.png" alt="image">  </p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>今天主要看完了IOC容器系列的设计和实现，包括BeanFactory和ApplicationContext；以及IOC容器的初始化过程，包括BeanDefinition的Resource定位，BeanDefinition的载入与解析，还有BeanDefinition的注册。  </p>
<p>其中BeanDefinition比较抽象，它是对象依赖关系的一种数据抽象，通过定义BeanDefinition来管理Spring应用中各种对象以及它们之间的相互依赖关系。  </p>
<p>IOC容器初始化的过程，下面这段代码是一个基本思路。通过Resource读取器读取Resource，进行载入。得到Resource后，按照Spring的Bean定义规则来对这个XML文档树进行解析，解析是交给BeanDefinitionParserDelegate类下的registerBeanDefinitions(doc, resource)，内部又调用了documentReader.registerBeanDefinitions(doc, resource)（内部具体实现又为processBeanDefinition()）来完成（见2-14代码），最后通过registerBeanDefinition（无s，与上面不同）来进行BeanDefinition的注册。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%883.56.31.png" alt="image">   </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-20%20%E4%B8%8B%E5%8D%885.33.10.png" alt="image">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一直想阅读下Spring的源码，但是翻翻书又感觉这个好复杂，不想去看，所以一直拖到现在，昨天定下心看了下书，觉得并没有那么晦涩难懂，还是要克服惧怕未接触的事物，敢于去克服自己的弱点。主要先看Spring的两大核心IOC和AOP，参考书籍是计文柯的《Spring技术内幕》。这篇文章主要先讲下IOC容器的内部实现。  &lt;/p&gt;
&lt;h2 id=&quot;IOC容器简介&quot;&gt;&lt;a href=&quot;#IOC容器简介&quot; class=&quot;headerlink&quot; title=&quot;IOC容器简介&quot;&gt;&lt;/a&gt;IOC容器简介&lt;/h2&gt;&lt;p&gt;IOC即控制反转，这里的反转指的是对象依赖关系的管理被反转了，转到IOC容器上了，对象之间的相互依赖关系由IOC容器进行管理，并由容器完成对象的注入。  &lt;/p&gt;
    
    </summary>
    
      <category term="Spring源码解析" scheme="http://yoursite.com/categories/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>谈谈分布式事务</title>
    <link href="http://yoursite.com/2018/04/16/%E8%B0%88%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/04/16/谈谈分布式事务/</id>
    <published>2018-04-16T14:17:00.000Z</published>
    <updated>2018-04-16T14:19:35.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>一个事务由多个不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要确保这些小的操作要么全部成功，要么全部失败。从本质上说，分布式事务是为了保证不同数据库之间的一致性。分布式事务的应用场景主要是在支付和在线下单，支付涉及到扣款和加钱，而在线下单则涉及到扣库存和更新账单，需要分布式事务来保证一致性。    </p>
<a id="more"></a>
<h2 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="headerlink" title="分布式事务产生的原因"></a>分布式事务产生的原因</h2><h3 id="数据库的分库分表"><a href="#数据库的分库分表" class="headerlink" title="数据库的分库分表"></a>数据库的分库分表</h3><p>分库分表后，原来的一个数据库分为了多个数据库，如果一个操作既要更新库01，又要更新库02，而且要保证数据的一致性，那么就需要用到分布式事务。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/shiwu1.png" alt="image">  </p>
<h3 id="应用SOA化"><a href="#应用SOA化" class="headerlink" title="应用SOA化"></a>应用SOA化</h3><p>即业务的服务化。以前单机支撑了整个电商网站，现在对整个网站进行拆解，分离出了订单中心，用户中心，库存中心等，对于每个中心有专门的数据库进行信息的存储。如果同时涉及到对订单和库存的操作，那么为了保证数据的一致性，需要用到分布式事务。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/shiwu2.png" alt="image">  </p>
<h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><ul>
<li>原子性<br>在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。</li>
<li>一致性<br>事务的执行必须保证系统的一致性，就拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元。</li>
<li>隔离性<br>所谓的隔离性就是说，事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。</li>
<li>持久性<br>持久性，就是说一单事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。  </li>
</ul>
<h2 id="一致性理论"><a href="#一致性理论" class="headerlink" title="一致性理论"></a>一致性理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>在分布式系统中，一致性（Consistency）、可用性（Availabilty）和分区容忍性（Partition Tolerance）三个要素最多只能同时满足两个，不可兼得，而对于分布式系统，分区容忍性是不可或缺的。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/cap.png" alt="image"></p>
<ul>
<li>一致性：分布式环境下多个节点的数据是否强一致。  </li>
<li>可用性：分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果。  </li>
<li>分区容忍性：特指对网络分区的容忍性。  </li>
</ul>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ul>
<li>基本可用（Basically Available）：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用。</li>
<li>软状态（Soft State）：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性。</li>
<li>最终一致性（Eventual Consistency）：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态</li>
</ul>
<h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><ul>
<li>强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。</li>
<li>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li>
<li>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。</li>
</ul>
<h2 id="常见的分布式事务解决方案"><a href="#常见的分布式事务解决方案" class="headerlink" title="常见的分布式事务解决方案"></a>常见的分布式事务解决方案</h2><h3 id="1、基于XA协议的两阶段提交（2PC）"><a href="#1、基于XA协议的两阶段提交（2PC）" class="headerlink" title="1、基于XA协议的两阶段提交（2PC）"></a>1、基于XA协议的两阶段提交（2PC）</h3><p>XA协议分为两部分：事务管理器和本地资源管理器，本地资源管理器主要由数据库实现，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/2pc%20tb.jpg" alt="image">  </p>
<p>这种方式实现难度不算高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，能保证强一致性。但对性能的影响比较大，不适合高并发和高性能要求的场景。  </p>
<h3 id="2、消息事务-最终一致性"><a href="#2、消息事务-最终一致性" class="headerlink" title="2、消息事务 - 最终一致性"></a>2、消息事务 - 最终一致性</h3><p>消息事务是基于消息中间件的两阶段提交，将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功并且对外发消息成功，要么两个操作都失败。  </p>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆分成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作。其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，之后B会受到消息去执行本地操作，如果本地操作失败，消息会重投，知道B操作成功，这样就变相的完成了A与B的分布式事务。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/message%20tx.png" alt="image">  </p>
<h3 id="3、事务补偿型（TCC事务）"><a href="#3、事务补偿型（TCC事务）" class="headerlink" title="3、事务补偿型（TCC事务）"></a>3、事务补偿型（TCC事务）</h3><p>在一个长事务中，由两台服务器一起参与，服务器A发起事务，服务器B参与事务。如果服务器A的事务执行顺利，那么事务A先行提交，如果事务B也执行顺利，则事务B也提交，整个事务完成。如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行事务A的状态。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/tcc.jpg" alt="image">  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/tcc2.jpg" alt="image">  </p>
<p>参考文章：<br>分布式事务的典型处理方式 <a href="https://blog.csdn.net/mine_song/article/details/64118963" target="_blank" rel="external">https://blog.csdn.net/mine_song/article/details/64118963</a><br>大规模SOA系统中的分布事务处理  <a href="https://wenku.baidu.com/view/be946bec0975f46527d3e104.html" target="_blank" rel="external">https://wenku.baidu.com/view/be946bec0975f46527d3e104.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是分布式事务&quot;&gt;&lt;a href=&quot;#什么是分布式事务&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式事务&quot;&gt;&lt;/a&gt;什么是分布式事务&lt;/h2&gt;&lt;p&gt;一个事务由多个不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要确保这些小的操作要么全部成功，要么全部失败。从本质上说，分布式事务是为了保证不同数据库之间的一致性。分布式事务的应用场景主要是在支付和在线下单，支付涉及到扣款和加钱，而在线下单则涉及到扣库存和更新账单，需要分布式事务来保证一致性。    &lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="大型网站技术架构" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈分库分表</title>
    <link href="http://yoursite.com/2018/04/12/%E6%B5%85%E8%B0%88%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/04/12/浅谈分库分表/</id>
    <published>2018-04-12T08:40:00.000Z</published>
    <updated>2018-04-12T08:45:57.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是分库分表？"><a href="#什么是分库分表？" class="headerlink" title="什么是分库分表？"></a>什么是分库分表？</h3><p>从字面上简单理解，就是把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。  </p>
<h3 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h3><p>数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，由于无法进行分布式部署，而一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。  </p>
<h3 id="常用的分库分表中间件"><a href="#常用的分库分表中间件" class="headerlink" title="常用的分库分表中间件"></a>常用的分库分表中间件</h3><p>简单易用的组件：  </p>
<ul>
<li>当当sharding-jdbc  </li>
<li>蘑菇街TSharding  </li>
</ul>
<p>强悍重量级的中间件：  </p>
<ul>
<li>sharding  </li>
<li>TDDL Smart Client的方式（淘宝）  </li>
<li>Atlas(Qihoo 360)  </li>
<li>alibaba.cobar(是阿里巴巴（B2B）部门开发)  </li>
<li>MyCAT（基于阿里开源的Cobar产品而研发）  </li>
<li>Oceanus(58同城数据库中间件)  </li>
<li>OneProxy(支付宝首席架构师楼方鑫开发)  </li>
<li>vitess（谷歌开发的数据库中间件）  </li>
</ul>
<a id="more"></a>
<h2 id="一、分库分表的实施策略"><a href="#一、分库分表的实施策略" class="headerlink" title="一、分库分表的实施策略"></a>一、分库分表的实施策略</h2><p>分库分表有垂直切分和水平切分两种。</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>即大表拆小表，拆分是基于关系型数据库中的”列字段”进行的。通常情况，某个表的字段比较多时，可以新建立一张扩展表，将不经常使用或者长度较大的字段拆分出去放到扩展表中。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%9E%82%E7%9B%B4%E5%88%86%E8%A1%A8.jpg" alt="image"></p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>基本思路是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。例如，我们会建立定义数据库workDB、商品数据库payDB、用户数据库userDB、日志数据库logDB等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93.jpg" alt="image"></p>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，以此来降低单表数据量，优化查询性能。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E6%B0%B4%E5%B9%B3%E5%88%86%E8%A1%A8.jpg" alt="image"></p>
<h3 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h3><p>与水平分表思想一致，不同在于这些拆分出来的表保存在不同的数据库中。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.jpg" alt="image"></p>
<h2 id="二、分库分表的难点"><a href="#二、分库分表的难点" class="headerlink" title="二、分库分表的难点"></a>二、分库分表的难点</h2><p>在高并发和海量数据的场景下，通过使用分库分表的手段，能够解决单机或者单库单表的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入硬件资源会更多，同时也会带来一些技术问题和挑战：如跨分片的复杂查询，跨分片事务等。  </p>
<h3 id="1、跨节点Join的问题"><a href="#1、跨节点Join的问题" class="headerlink" title="1、跨节点Join的问题"></a>1、跨节点Join的问题</h3><h4 id="①全局表"><a href="#①全局表" class="headerlink" title="①全局表"></a>①全局表</h4><p>全局表意思就是有可能系统中所有模块都可能会依赖到的一些表。为避免跨库join查询，可以将这类表在每个数据库中均保存一份。同时这类数据很少修改，不用太担心一致性的问题。  </p>
<h4 id="②字段冗余"><a href="#②字段冗余" class="headerlink" title="②字段冗余"></a>②字段冗余</h4><p>是典型的反范式手段，以空间换事件的方式，来避免join查询。例如订单表在保存卖家id的同时，将卖家的name字段也冗余。这样查询订单详情的时候就不需要再去查询卖家用户表。  </p>
<h4 id="③系统层拼装"><a href="#③系统层拼装" class="headerlink" title="③系统层拼装"></a>③系统层拼装</h4><p>将一次查询分为两次查询，在第一次查询的结果集中找出关联数据的id，根据这些id发起第二次请求得到关联数据。</p>
<h3 id="2、跨节点的count，order-by，group-by以及聚合函数的问题"><a href="#2、跨节点的count，order-by，group-by以及聚合函数的问题" class="headerlink" title="2、跨节点的count，order by，group by以及聚合函数的问题"></a>2、跨节点的count，order by，group by以及聚合函数的问题</h3><p>这类问题，需要基于全部的数据集进行计算。解决方案：与跨节点join问题类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个节点的查询可以并行处理，因此很多时候比单一大表快很多，但对应用内存消耗较大。  </p>
<h3 id="3、数据迁移，容量规划，扩容等问题"><a href="#3、数据迁移，容量规划，扩容等问题" class="headerlink" title="3、数据迁移，容量规划，扩容等问题"></a>3、数据迁移，容量规划，扩容等问题</h3><p>淘宝TDDL中，利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是仍然需要进行表级别的迁移，同时对扩容规模（需为2的倍数）和分表数量都有限制。<br>参考文章：<a href="https://www.cnblogs.com/tommyli/p/3767362.html" target="_blank" rel="external">https://www.cnblogs.com/tommyli/p/3767362.html</a>  </p>
<p>总而言之，主要基于两种规则映射：  </p>
<ol>
<li>离散映射：如mod或dayofweek（一周七天），这种类型的映射能够很好的解决热点问题，但带来了数据迁移和历史数据问题。  </li>
<li>连续映射：如按id或create_time的连续范围做映射，比如id范围0-1000在库1，1000-2000在库2.这种类型的映射可以避免数据迁移，但又会带来热点问题。</li>
</ol>
<h3 id="4、分布式事务问题"><a href="#4、分布式事务问题" class="headerlink" title="4、分布式事务问题"></a>4、分布式事务问题</h3><p>分布式事务是个较复杂的问题，后续会添加文章专门讲解分布式事务及其解决方案。  </p>
<h3 id="5、分布式全局唯一ID"><a href="#5、分布式全局唯一ID" class="headerlink" title="5、分布式全局唯一ID"></a>5、分布式全局唯一ID</h3><p>在复杂的分布式系统中，往往需要对大量的数据和消息进行唯一标识。如外卖系统中的订单、骑手、优惠券等都需要有唯一的ID做标识（因为分库分表的原因，比如订单表不放在一个库一个表中，那么就无法通过使用数据库自增ID这种简单方式来实现订单的唯一标识）。此时一个能生成全局唯一ID的系统是十分必要的。后续会补上相关文章，也可参考美团的文章：<a href="https://tech.meituan.com/MT_Leaf.html" target="_blank" rel="external">https://tech.meituan.com/MT_Leaf.html</a>   </p>
<p>参考文章：<br><a href="https://www.jianshu.com/p/32b3e91aa22c?from=timeline" target="_blank" rel="external">https://www.jianshu.com/p/32b3e91aa22c?from=timeline</a><br><a href="http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;什么是分库分表？&quot;&gt;&lt;a href=&quot;#什么是分库分表？&quot; class=&quot;headerlink&quot; title=&quot;什么是分库分表？&quot;&gt;&lt;/a&gt;什么是分库分表？&lt;/h3&gt;&lt;p&gt;从字面上简单理解，就是把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上。  &lt;/p&gt;
&lt;h3 id=&quot;为什么要分库分表？&quot;&gt;&lt;a href=&quot;#为什么要分库分表？&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表？&quot;&gt;&lt;/a&gt;为什么要分库分表？&lt;/h3&gt;&lt;p&gt;数据库中的数据量不一定是可控的，在未进行分库分表的情况下，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地，数据操作，增删改查的开销也会越来越大；另外，由于无法进行分布式部署，而一台服务器的资源（CPU、磁盘、内存、IO等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。  &lt;/p&gt;
&lt;h3 id=&quot;常用的分库分表中间件&quot;&gt;&lt;a href=&quot;#常用的分库分表中间件&quot; class=&quot;headerlink&quot; title=&quot;常用的分库分表中间件&quot;&gt;&lt;/a&gt;常用的分库分表中间件&lt;/h3&gt;&lt;p&gt;简单易用的组件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当当sharding-jdbc  &lt;/li&gt;
&lt;li&gt;蘑菇街TSharding  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;强悍重量级的中间件：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sharding  &lt;/li&gt;
&lt;li&gt;TDDL Smart Client的方式（淘宝）  &lt;/li&gt;
&lt;li&gt;Atlas(Qihoo 360)  &lt;/li&gt;
&lt;li&gt;alibaba.cobar(是阿里巴巴（B2B）部门开发)  &lt;/li&gt;
&lt;li&gt;MyCAT（基于阿里开源的Cobar产品而研发）  &lt;/li&gt;
&lt;li&gt;Oceanus(58同城数据库中间件)  &lt;/li&gt;
&lt;li&gt;OneProxy(支付宝首席架构师楼方鑫开发)  &lt;/li&gt;
&lt;li&gt;vitess（谷歌开发的数据库中间件）  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="大型网站技术架构" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO 原理解析</title>
    <link href="http://yoursite.com/2018/04/11/Java%20NIO%20%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/04/11/Java NIO 原理解析/</id>
    <published>2018-04-11T09:05:00.000Z</published>
    <updated>2018-06-25T09:56:18.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>NIO（Non-blocking I/O，在Java领域，也成为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，Netty其实就是对NIO的一种封装，以实现高性能。<br>那么NIO的本质是怎样的？它是怎样与事件模型结合来解放线程、提高系统吞吐的呢？<br><a id="more"></a></p>
<h2 id="传统BIO模型分析"><a href="#传统BIO模型分析" class="headerlink" title="传统BIO模型分析"></a>传统BIO模型分析</h2><pre>
{
 ExecutorService executor = Excutors.newFixedThreadPollExecutor(100);//线程池

 ServerSocket serverSocket = new ServerSocket();
 serverSocket.bind(8088);
 while(!Thread.currentThread.isInturrupted()){//主线程死循环等待新连接到来
 Socket socket = serverSocket.accept();
 executor.submit(new ConnectIOnHandler(socket));//为新的连接创建新的线程
}

class ConnectIOnHandler extends Thread{
    private Socket socket;
    public ConnectIOnHandler(Socket socket){
       this.socket = socket;
    }
    public void run(){
      while(!Thread.currentThread.isInturrupted()&&!socket.isClosed()){死循环处理读写事件
          String someThing = socket.read()....//读取数据
          if(someThing!=null){
             ......//处理数据
             socket.write()....//写数据
          }
      }
    }
}
</pre>

<p>这是一个经典的一个连接一个线程的模型，主线程死循环等待新连接的到来，到来后accept阻塞等待数据的到来，到来后便开启新的线程来处理数据。    </p>
<p>这里使用线程池，来让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。    </p>
<p>但是，这个模型最本质的问题在于，严重依赖于线程。但是线程是很昂贵的资源，主要体现在：  </p>
<ol>
<li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。  </li>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。  </li>
<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU 使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。  </li>
<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。  </li>
</ol>
<p>所以，在面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的，我们需要更高效的I/O处理模型。    </p>
<h2 id="常见I-O模型对比"><a href="#常见I-O模型对比" class="headerlink" title="常见I/O模型对比"></a>常见I/O模型对比</h2><p>所有的系统I/O都分为两个阶段：等待就绪和操作。比方说，读函数就分为等待系统可读和真正的读；写函数与之类似。  </p>
<p>需要说明的是等待就绪的阻塞是不使用CPU的，是在<strong>空等</strong>。而真正的读写操作的阻塞是使用CPU的，真正在干活，而且这个过程非常快，属于memory copy，带宽通常在1GB/s以上，可以理解为基本不耗时。  </p>
<p>下图是几种常见I/O模型的对比：<br><img src="http://osrmzp0jr.bkt.clouddn.com/io%20moxing.jpg" alt="image">  </p>
<p>以socket.read()为例：  </p>
<p>对于BIO：如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。  </p>
<p>对于NIO：如果TCP RecvBuffer里有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，不会造成阻塞。  </p>
<p>对于AIO：不但等待就绪时非阻塞的，就连数据从网卡到内存的过程都是异步的，由操作系统去完成一系列的操作。  </p>
<p>换句话说，BIO中用户最关心”我要读”，NIO中用户最关心”我可以读了”，AIO中用户更关注的是”读完了”。</p>
<p>NIO的重要特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作时同步阻塞的（消耗CPU但是性能非常高）。  </p>
<h2 id="如何结合事件模型使用NIO同步非阻塞特性"><a href="#如何结合事件模型使用NIO同步非阻塞特性" class="headerlink" title="如何结合事件模型使用NIO同步非阻塞特性"></a>如何结合事件模型使用NIO同步非阻塞特性</h2><pre>
interface ChannelHandler{
      void channelReadable(Channel channel);
      void channelWritable(Channel channel);
   }
   class Channel{
     Socket socket;
     Event event;//读，写或者连接
   }

   //IO线程主循环:
   class IoThread extends Thread{
   public void run(){
   Channel channel;
   while(channel=Selector.select()){//选择就绪的事件和对应的连接
      if(channel.event==accept){
         registerNewChannelHandler(channel);//如果是新连接，则注册一个新的读写处理器
      }
      if(channel.event==write){
         getChannelHandler(channel).channelWritable(channel);//如果可以写，则执行写事件
      }
      if(channel.event==read){
          getChannelHandler(channel).channelReadable(channel);//如果可以读，则执行读事件
      }
    }
   }
   Map<channel，channelhandler> handlerMap;//所有channel的对应事件处理器
  }
</channel，channelhandler></pre>

<p>由上面的示例可以看出NIO是怎样解决掉线程的瓶颈并处理连接的：NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（只需要单线程），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。  </p>
<p>单线程处理I/O的效率确实很高，没有线程的切换，只是拼命的读、写、选择事件。但现在的服务器都是多核服务器，充分利用多核心进行I/O，无疑对效率有更大提升。  </p>
<p>我们需要的线程，主要包括以下几种：  </p>
<ol>
<li>事件分发起，单线程选择就绪的事件。  </li>
<li>I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。  </li>
<li>业务线程，在处理完I/O后，业务还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等，只要有阻塞，就需要单独的线程。  </li>
</ol>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/reactor.jpg" alt="image"></p>
<h2 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h2><p>一般情况下，I/O复用机制都需要事件分发器（event dispatcher）。事件分发器的作用是，将那些读写事件源分发给各读写事件的处理者（handler）。就像快递到了之后在楼下喊：谁谁谁的快递到了，快来拿吧！  </p>
<p>开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者或者回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。  </p>
<p>涉及到事件分发器的两种模式是：Proactor和Reactor。Reactor是基于同步I/O的，而Proactor是和异步I/O相关的。在Reactor模式中，事件分发器等待某个事件发生，就会把事件传给事先注册的事件处理函数或回调函数，由后者来做实际的读写操作。  </p>
<p>而在Proactor模式中，事件处理者（或者由事件分发器发起）直接发起一个异步读写操作，而实际的工作是由操作系统完成的。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给后续相应的事件处理者或回调。这种异步模式基于操作系统底层异步API，我们可称之为”系统级别”或者真正意义上的异步，因为具体的读写都是由操作系统代劳的。</p>
<h3 id="在Reactor中实现读"><a href="#在Reactor中实现读" class="headerlink" title="在Reactor中实现读"></a>在Reactor中实现读</h3><ul>
<li>注册读就绪事件和相应的事件处理器。</li>
<li>事件分发器等待事件。</li>
<li>事件到来，激活分发器，分发器调用事件对应的处理器。</li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<h3 id="在Proactor中实现读："><a href="#在Proactor中实现读：" class="headerlink" title="在Proactor中实现读："></a>在Proactor中实现读：</h3><ul>
<li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li>
<li>事件分发器等待操作完成事件。在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li>
<li>事件分发器呼唤处理器。事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。  </li>
</ul>
<p>通俗易懂来谈两者区别：<br>reactor：能收了你跟俺说一声。<br>proactor: 你给我收十个字节，收好了跟俺说一声。  </p>
<h2 id="Buffer的选择"><a href="#Buffer的选择" class="headerlink" title="Buffer的选择"></a>Buffer的选择</h2><p>通常情况下，操作系统的一次写操作分为两步：  </p>
<ol>
<li>将数据从用户空间拷贝到系统空间。  </li>
<li>从系统空间往网卡写。同理，读操作也分为两步：<br> ① 将数据从网卡拷贝到系统空间；<br> ② 将数据从系统空间拷贝到用户空间。    </li>
</ol>
<p>对于NIO来说，缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能。  </p>
<p>如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer。  </p>
<p>两者区别：<br>DirectBuffer（直接缓冲区）：缓冲区建立在物理内存中，可提高效率。<br>HeapBuffer：将缓冲区建立在JVM的内存中。  </p>
<h2 id="NIO存在的问题"><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h2><p>使用NIO != 高性能，当连接数&lt;1000，并发程度不高或者局域网环境下NIO并没有显著的性能优势。  </p>
<p>NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。  </p>
<p>推荐大家使用成熟的NIO框架，如Netty，MINA等。解决了很多NIO的陷阱，并屏蔽了操作系统的差异，有较好的性能和编程模型。  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>Java NIO浅析 <a href="https://zhuanlan.zhihu.com/p/23488863" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23488863</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;NIO（Non-blocking I/O，在Java领域，也成为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，Netty其实就是对NIO的一种封装，以实现高性能。&lt;br&gt;那么NIO的本质是怎样的？它是怎样与事件模型结合来解放线程、提高系统吞吐的呢？&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析volatile</title>
    <link href="http://yoursite.com/2018/04/10/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90volatile/"/>
    <id>http://yoursite.com/2018/04/10/深入剖析volatile/</id>
    <published>2018-04-10T02:54:00.000Z</published>
    <updated>2018-04-11T09:17:48.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、volatile的性质"><a href="#一、volatile的性质" class="headerlink" title="一、volatile的性质"></a>一、volatile的性质</h1><h2 id="1、volatile保证可见性"><a href="#1、volatile保证可见性" class="headerlink" title="1、volatile保证可见性"></a>1、volatile保证可见性</h2><ol>
<li>volatile关键字保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对于其他线程来说是立即可见的。  </li>
</ol>
<pre> 
//线程1
boolean stop =false;
while(!stop)
  doSomething();

//线程2
stop=true;  
</pre>

<p>上面的代码，可能导致无法中断线程。当线程2更改了stop变量的值后，还没来得及写入内存中，线程2就转去做其他事情了，线程1由于不知道线程2对stop变量的修改，会一直循环下去。<br>&nbsp;&nbsp;使用volatile修饰后，发生变化：<br>第一：使用volatile会强制将修改的值写入主内存。<br>第二：使用volatile的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效。<br>第三：由于线程1的工作内存中的缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主内存读取。<br><a id="more"></a></p>
<h2 id="2、volatile保证有序性"><a href="#2、volatile保证有序性" class="headerlink" title="2、volatile保证有序性"></a>2、volatile保证有序性</h2><pre> 
//x、y不是volatile变量
//flag为volatile变量
x=2;            //语句1
y=0;            //语句2
flag=true;      //语句3
x=4;            //语句4
y=-1            //语句5
</pre>

<p>①由于flag为volatile变量，在进行指令重排序时，不会将语句3放到语句1、2前面，也不会将语句3放到语句4、5的后面，但是语句1、2的顺序，语句4、5的执行顺序是不做任何保证的。<br>②并且volatile保证：执行到语句3时，语句1、2必定是执行完毕类的，而且语句1、2的执行结果对语句3、4、5是可见的。  </p>
<h2 id="3、volatile不能保证原子性"><a href="#3、volatile不能保证原子性" class="headerlink" title="3、volatile不能保证原子性"></a>3、volatile不能保证原子性</h2><p>&emsp;&emsp;原子性：即一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>&emsp;&emsp;可以通过synchronized或Lock进行加锁，来保证操作的原子性。也可以通过使用java.util.concurrent.atomic包下提供的原子操作类（对基本数据类型的一些操作进行了封装）来实现。<br>&emsp;&emsp;atomic是利用CAS（Compare And Swap）来实现原子性操作的，CAS实际上利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性的操作。  </p>
<h2 id="4、volatile的应用场景"><a href="#4、volatile的应用场景" class="headerlink" title="4、volatile的应用场景"></a>4、volatile的应用场景</h2><p>&emsp;&emsp;相较于synchronized，volatile是较为轻量级的同步策略，使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但volatile无法代替synchronized，因为volatile无法保证操作的原子性。<br>&emsp;&emsp;使用volatile的两个条件：<br>1、对变量的写操作不依赖于当前值<br>2、 该变量没有包含在具有其他变量的不变式中  </p>
<h1 id="二、volatile的实现原理"><a href="#二、volatile的实现原理" class="headerlink" title="二、volatile的实现原理"></a>二、volatile的实现原理</h1><h2 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h2><p>&emsp;&emsp;处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据读到内部缓存后再进行操作，但操作完后不知道何时才会写到内存中。<br>&emsp;&emsp;对声明了volatile变量进行写操作时，<strong>JVM会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。</strong> 这一步确保了如果有其他线程对声明了volatile的变量进行修改时，则立即更新主内存中的数据。<br>&emsp;&emsp;但此时其他处理器的缓存的数据还是旧数据，<strong>所以在多处理器的环境下，为了保证各个处理器的缓存一致，每个处理器会通过嗅探在总线上传播的数据来检查自己的缓存是否过期。当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个数据进行修改时，会强制重新从系统内存把数据读到处理器缓存里。</strong> 这一步确保了其他线程获得的声明了volatile的变量都是从主内存中获取的最新的。  </p>
<h2 id="2、有序性"><a href="#2、有序性" class="headerlink" title="2、有序性"></a>2、有序性</h2><p>&emsp;&emsp;Lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障之后的位置，即在执行到内存屏障这句指令时，在它之前的操作已经全部完成。  </p>
<h2 id="3、Lock前缀指令"><a href="#3、Lock前缀指令" class="headerlink" title="3、Lock前缀指令"></a>3、Lock前缀指令</h2><p>在多处理器下会引发两件事：<br>①将当前处理器缓存行的数据写回到系统内存。<br>②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。  </p>
<h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-10%20%E4%B8%8A%E5%8D%8810.32.06.png" alt="image"></p>
<ul>
<li>第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。  </li>
<li>第一个操作时volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。  </li>
<li>当第一个操作时volatile写，第二个操作时volatile读时，不能重排序。<h3 id="内存屏障类型"><a href="#内存屏障类型" class="headerlink" title="内存屏障类型"></a>内存屏障类型</h3><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-10%20%E4%B8%8A%E5%8D%8810.42.48.png" alt="image"><br>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。基于保守策略的JMM内存屏障插入策略如下（<strong>在实际的执行中，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略一些不必要的屏障</strong>）：  </li>
<li>在每个volatile写操作的前面插入一个StoreStore屏障，用于禁止上面的普通写和下面的volatile写重排序。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障，用于禁止上面的volatile写操作和下面可能有的volatile读/写重排序。<br><img src="http://osrmzp0jr.bkt.clouddn.com/volatile%E5%86%99.png" alt="image"></li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障，用于禁止下面的普通读操作和上面的volatile读重排序。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障，用于禁止下面的普通写操作和上面的volatile读重排序。<br><img src="http://osrmzp0jr.bkt.clouddn.com/volatile%E8%AF%BB.png" alt="image"></li>
</ul>
<h3 id="volatile写-读的内存语义"><a href="#volatile写-读的内存语义" class="headerlink" title="volatile写-读的内存语义"></a>volatile写-读的内存语义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</div><div class="line">        a = <span class="number">1</span>;        <span class="comment">//1</span></div><div class="line">        flag = <span class="keyword">true</span>;  <span class="comment">//2</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(flag)&#123;      <span class="comment">//3</span></div><div class="line">            <span class="keyword">int</span> i = a; <span class="comment">//4</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-10%20%E4%B8%8A%E5%8D%889.48.12.png" alt="image"></p>
<ul>
<li>volatile写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。（包含volatile变量flag和定义在flag之前的共享变量a）  </li>
<li>volatile读：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。<br>综合来看的话，即读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3></li>
<li>线程A写一个volatile变量，实际上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-10%20%E4%B8%8A%E5%8D%889.48.27.png" alt="image">  </li>
</ul>
<h2 id="4、JSR-133为什么要增强volatile的内存语义"><a href="#4、JSR-133为什么要增强volatile的内存语义" class="headerlink" title="4、JSR-133为什么要增强volatile的内存语义"></a>4、JSR-133为什么要增强volatile的内存语义</h2><p>在JSR-133之前的JMM中，虽然不允许volatile变量之间重排序，但旧的JMM允许volatile变量与普通变量重排序。则上面VolatileExample程序可能被重排序成下列时序运行。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-10%20%E4%B8%8A%E5%8D%8810.13.36.png" alt="image"><br>&emsp;&emsp;此时，步骤3和4重排序，造成结果：读线程B执行4时，不一定能看到写线程A在执行1时对共享变量的修改。而正确的结果应该是线程A对volatile的写，使得共享变量和volatile变量刷新到主内存，之后步骤3对volatile的读使得线程B本地内存数据失效，并从主内存中取出最新数据。<br>&emsp;&emsp;在旧的JMM中，volatile的写-读不具有锁的释放-获取所具有的内存语义<br>。（<strong>volatile写对应锁的释放，volatile读对应锁的获取</strong>），所以专家组决定增强volatile的内存语义，严格限制编程器和处理器对volatile变量与普通变量的重排序，让volatile的写-读具有锁的释放-获取所具有的内存语义。  </p>
<h1 id="三、volatile和synchronized的区别"><a href="#三、volatile和synchronized的区别" class="headerlink" title="三、volatile和synchronized的区别"></a>三、volatile和synchronized的区别</h1><p>1、volatile的本质实在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中去获取。synchronized则是锁定当前线程才可以访问该变量，其他线程被阻塞住；<br>2、volatile只能使用在变量，synchronized可以使用在变量和方法上；<br>3、volatile只能实现变量的修改可见性，synchronized可以保证变量修改的可见性和原子性；<br>4、volatile不会造成线程的阻塞，synchronized会造成线程的阻塞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、volatile的性质&quot;&gt;&lt;a href=&quot;#一、volatile的性质&quot; class=&quot;headerlink&quot; title=&quot;一、volatile的性质&quot;&gt;&lt;/a&gt;一、volatile的性质&lt;/h1&gt;&lt;h2 id=&quot;1、volatile保证可见性&quot;&gt;&lt;a href=&quot;#1、volatile保证可见性&quot; class=&quot;headerlink&quot; title=&quot;1、volatile保证可见性&quot;&gt;&lt;/a&gt;1、volatile保证可见性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;volatile关键字保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对于其他线程来说是立即可见的。  &lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt; 
//线程1
boolean stop =false;
while(!stop)
  doSomething();

//线程2
stop=true;  
&lt;/pre&gt;

&lt;p&gt;上面的代码，可能导致无法中断线程。当线程2更改了stop变量的值后，还没来得及写入内存中，线程2就转去做其他事情了，线程1由于不知道线程2对stop变量的修改，会一直循环下去。&lt;br&gt;&amp;nbsp;&amp;nbsp;使用volatile修饰后，发生变化：&lt;br&gt;第一：使用volatile会强制将修改的值写入主内存。&lt;br&gt;第二：使用volatile的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效。&lt;br&gt;第三：由于线程1的工作内存中的缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主内存读取。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统互斥性与幂等性问题的分析和解决</title>
    <link href="http://yoursite.com/2018/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BA%92%E6%96%A5%E6%80%A7%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/04/09/分布式系统互斥性与幂等性问题的分析和解决/</id>
    <published>2018-04-09T01:26:00.000Z</published>
    <updated>2018-04-16T15:08:37.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式系统由独立的服务器通过网络松散耦合组成。在这个系统中，每个服务器都是一个独立的主机，服务器之间通过内部网络连接。分布式系统有以下几个特点：  </p>
<ul>
<li>可扩展性：可通过横向水平扩展来提高系统的性能和吞吐量。  </li>
<li>高可靠性：高容错，即使系统中一台或几台故障，系统通过失效转移仍然可以提供服务。  </li>
<li>高并发性：各机器并行独立处理和计算。  </li>
<li>廉价高效：多台小型机而非单台高性能机。  </li>
</ul>
<p>在分布式系统中，环境复杂、网络不稳定性会造成诸如时钟不一致的问题，存在于集中式系统中机器宕机、消息丢失等问题也会在分布式环境中变得更加复杂。有两个问题是分布式环境中需要重点关注和解决的典型问题：  </p>
<ul>
<li>互斥性问题</li>
<li>幂等性问题  </li>
</ul>
<a id="more"></a>
<h2 id="一、互斥性问题"><a href="#一、互斥性问题" class="headerlink" title="一、互斥性问题"></a>一、互斥性问题</h2><p>看个例子：<br>某服务器提供一组任务，A请求随机从任务组中获取一个任务；B请求随机从任务组中获取一个任务。在理想情况下，A从任务组中挑选一个任务，任务组删除该任务，B从剩下的任务组中再挑一个，之后任务组再删除。<br>但在真实情况下，如不做任何处理，可能出现A和B挑中了同一个任务的情况。  </p>
<p>上面这个例子，存在操作互斥性的问题，其实就是对共享资源的抢占问题。如果不同的请求对同一个或者同一组资源读取并修改时，无法保证其按序执行，无法保证一个操作的原子性，那么就很有可能会出现预期外的情况。所以操作的互斥性问题可以理解为一个需要保证时序性、原子性的问题。  </p>
<p>在传统的基于数据库的架构中，对于数据的抢占问题往往是通过数据库事务（ACID）来保证的。在分布式环境中，<strong>分布式锁</strong>是一种比较常见和高效的解决方案。在传统的多线程、多进程情况下，已有比较好的解决方案，我们先来看看传统情况下是怎么解决的。  </p>
<h3 id="多线程环境下的解决方案"><a href="#多线程环境下的解决方案" class="headerlink" title="多线程环境下的解决方案"></a>多线程环境下的解决方案</h3><p><strong>基本上所有的并发模式在解决线程冲突的问题上，都是采用序列化访问共享资源的方式。</strong><br>在多线程环境下，最普遍的方式就是用互斥锁把该资源或对资源的操作保护起来。Java中提供两种互斥锁Lock和synchronized。不同线程之间对同一资源进行抢占，该资源通常表现为某个类的普通成员变量，使用Lock和synchronized将共享的变量及其操作锁住，就可以解决资源抢占的问题。  </p>
<h3 id="多进程的解决方案"><a href="#多进程的解决方案" class="headerlink" title="多进程的解决方案"></a>多进程的解决方案</h3><p>在多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用，这便是临界资源。多进程中的临界资源大致可以分为两类，一类是物理上的真实资源，如打印机；一类是硬盘或内存中的共享数据，如共享内存等。进程内互斥访问临界资源的代码称为<strong>临界区</strong>。<br>对于临界资源的互斥访问，JVM层面的锁已经失去作用了。在多进程情况下，主要还是利用操作系统层面的进程间通信原理来解决临界资源的抢占问题。比较常见的一种方法是使用信号量（Semaphores）<br>信号量分为有名信号量和无名信号量。无名信号量通常保存在共享内存中，而有名信号量是于一个特定的文件夹名称相关联。对信号量的操作主要是P操作（wait）和V操作（signal）。  </p>
<ul>
<li>P操作：先检查信号量的大小，若值大于零，则将信号量减1，同时进程获得共享资源的访问权限，继续执行；若小于或者等于零，则该进程被阻塞后，进入等待队列。  </li>
<li>V操作：该操作将信号量的值加1，如果有进程阻塞着等待该信号量，那么其中一个进程被唤醒。  </li>
</ul>
<p>对共享资源的操作前后（进入和退出临界区）进行加锁和解锁，保证不同线程或进程可以互斥有序的操作资源。  </p>
<h3 id="分布式环境下的解决方案——分布式锁"><a href="#分布式环境下的解决方案——分布式锁" class="headerlink" title="分布式环境下的解决方案——分布式锁"></a>分布式环境下的解决方案——分布式锁</h3><p>不管是多线程还是多进程环境下的锁都有很多共通之处，他们满足一些最基本的条件：  </p>
<ol>
<li>需要有存储锁的空间，并且锁的空间是可以访问到的。  </li>
<li>锁需要被唯一标识（全局唯一）。  </li>
<li>锁至少要有两种状态，如ReetrantLock中的status，0表示没有线程竞争，大于0表示有线程竞争；或者是有锁、没锁这样分类。  </li>
</ol>
<p>有了这三个条件，就可以基本上实现一个简单的分布式锁了。以数据库为例，实现一个简单的分布式锁：数据库表，字段为锁的ID（唯一标识），还有锁的状态（0表示没锁，1表示被锁）。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lock</span> = mysql.<span class="keyword">get</span>(id);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">lock</span>.status == <span class="number">1</span>)  <span class="comment">//已被锁，继续等待获取</span></div><div class="line">    sleep(<span class="number">100</span>);</div><div class="line">mysql.update(<span class="keyword">lock</span>.status = <span class="number">1</span>);  <span class="comment">//获取到锁，更新锁状态为被锁 </span></div><div class="line">doSomthing();  <span class="comment">//执行逻辑</span></div><div class="line">mysql.update(<span class="keyword">lock</span>.status = <span class="number">0</span>);  <span class="comment">//释放锁，更新锁状态</span></div></pre></td></tr></table></figure></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>上面简单的实现了一个分布式锁，但是存在一些问题：  </p>
<ul>
<li>问题1：锁状态判断的原子性无法保证<br>从读取锁的状态，到判断该状态是否为被锁，这两个操作如果不能保证是原子性的，就可能导致不止一个请求获取到了锁，这显然是不行的。  </li>
<li>问题2：网络断开或主机宕机，锁状态无法清除<br>假设主机在获取到锁的情况下，突然出现了网络断开或者主机宕机，如果不做任何处理该锁将仍然处于被锁定的状态。那么之后的所有请求都无法再成功抢占到这个锁。因此，我们需要在持有锁的主机遇到网络断开或者主机宕机时，及时的释放掉这把锁。  </li>
<li>问题3：无法保证释放的是自己上锁的那把锁<br>如果持有锁的主机A在临界区遇到网络抖动而导致网络断开，分布式锁及时的被释放了。之后，另一个主机B占用了这把锁，但是此时主机A网络恢复，退出临界区并解锁。由于都是一把锁，所以数据库中锁的状态会变为无占用状态；如果此时第三个主机C尝试抢占这把锁，也将会成功获得。因此，我们需要在解锁时，确定自己解的这个锁是否还是当前主机还依旧占用的这把锁（因为可能在这之前这把锁已经被释放过了）。  </li>
</ul>
<h4 id="进阶条件"><a href="#进阶条件" class="headerlink" title="进阶条件"></a>进阶条件</h4><p>分布式锁的实现，如果可以解决上面三个问题，可以算是一个相对完整的分布式锁了。在实际情况中，可能有更高级的要求。  </p>
<ol>
<li>可重入：线程中的可重入，指的是外层函数获得锁之后，内层也可以获得锁，Lock和synchronized都是可重入锁；在分布式环境中，一般还是指的线程的可重入。  </li>
<li>惊群效应（Herd Effect）：在分布式锁中，惊群效应指的是，在有多个请求等待获取锁的时候，一旦占有锁的线程释放之后，如果所有等待方都被同时唤醒，尝试抢占锁。但是这样的情况会造成比较大的开销，应避免惊群效应的产生。  </li>
<li>公平锁于非公平锁：不同需求下可能需要不同分布式锁。非公平锁开销较小，但如果业务需求竞争者按顺序获得锁，那么就需要实现公平锁。  </li>
<li>阻塞锁和自旋锁：阻塞锁需要上下文的切换，或并发量高且临界区的操作耗时比较短，那么性能开销会比较大。如果临界区操作耗时比较长，一直保持自旋，也会对CPU造成更大的负荷。  </li>
</ol>
<h4 id="典型实现"><a href="#典型实现" class="headerlink" title="典型实现"></a>典型实现</h4><h5 id="Zookeeper的实现"><a href="#Zookeeper的实现" class="headerlink" title="Zookeeper的实现"></a>Zookeeper的实现</h5><p>Zookeeper中有一种节点叫做顺序节点，假如我们在/lock/目录下创建三个节点，zk集群会按照发起创建的顺序来创建节点，节点分别为/lock/00000001、/lock/00000002、/lock/00000003。<br>zk中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端于zk集群断开连接，则该节点自动被删除。  </p>
<p>根据zk中节点是否存在，可以作为分布式锁的锁状态，以此来实现一个分布式锁，下面是分布式锁的基本逻辑：  </p>
<ol>
<li>客户端调用create()方法创建名为”/dlm-locks/lockname/lock-“的临时顺序节点。  </li>
<li>客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。</li>
<li>客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么久认为这个客户端获得了锁。  </li>
<li>如果创建的节点不是所有节点中最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。  </li>
</ol>
<p>释放锁的过程相对比较简单，就是删除自己创建的那个子节点即可。  </p>
<h5 id="Redis的实现"><a href="#Redis的实现" class="headerlink" title="Redis的实现"></a>Redis的实现</h5><p>Redis的分布式缓存特性使其成为了分布式锁的一种基础实现。通过Redis中是否存在某个锁ID，则可以判断是否已经上锁。为了保证判断锁是否存在的原子性，保证只有一个县城获取同一把锁，Redis有SETNX(set if not exist)和GETSET（先写新值，返回旧值，原子性操作，用于分辨是不是首次操作）。  </p>
<p>为了防止主机宕机和网络断开之后的死锁，Redis没有zk那种天然的实现方式，只能依赖设置超时时间来规避。  </p>
<p>下面是一种比较普遍但不太完善的Redis分布式锁的实现步骤：  </p>
<ol>
<li>线程A发送SETNX lock.orderid尝试获得锁，如果锁不存在，则set并获得锁。  </li>
<li>如果锁存在，则再判断锁的值（时间戳）是否大于当前时间，如果没有超时，则等待下再重试。  </li>
<li>如果已经超时，再用GETSET lock.orderid来尝试获取锁，如果这时候拿到的时间戳仍然超时，那么说明已经获得锁了。  </li>
<li>如果在此之前，另一个线程C快一步执行了上面的操作，那么A拿到的时间戳是个未超时的值，这是A没有如期获得锁，需要再次等待或重试。</li>
</ol>
<h5 id="Tair的实现"><a href="#Tair的实现" class="headerlink" title="Tair的实现"></a>Tair的实现</h5><p>实现与Redis类似，Tair客户端封装了一个expireLock的方法：通过锁状态和过期时间戳来共同判断锁是否存在，只有锁已经存在且没有过期的状态才判定为有锁状态。在有锁的情况下，不能加锁，能通过大于或等于过期时间的时间戳进行解锁。  </p>
<p>采用这种方式，可以不用再Value中存储时间戳，并且保证了判断是否有锁的原子性。并且，由于超时时间由Tair判断，所以避免了不同主机时钟不一致的情况。  </p>
<h5 id="分布式锁的弊端"><a href="#分布式锁的弊端" class="headerlink" title="分布式锁的弊端"></a>分布式锁的弊端</h5><ul>
<li>强依赖于外部组件：分布式锁的实现都依赖于外部数据存储如zk、Redis等，因此一旦这些外部组件出现故障，那么分布式锁就不可用了。  </li>
<li>无法完全满足需求：不同分布式锁的实现，都有相应的特点，对于一些需求并不能很好的满足，如实现公平锁、给等待锁加超时时间等等。  </li>
</ul>
<p>基于以上的问题，结合多种的实现方式，美团开发了Cerberus，提供更灵活可靠的分布式锁。Cerberus有以下特点：  </p>
<ol>
<li>一套接口多种引擎。使用了多种引擎实现方式（Tair、ZK、未来支持Redis），可自主选择所需的一种或多种引擎。</li>
<li>使用灵活，学习成本低。提供一套API，方便使用。  </li>
<li>支持一键降级。可以实时切换引擎的接口，用于应对所依赖主引擎的故障发生。</li>
</ol>
<h2 id="二、幂等性问题"><a href="#二、幂等性问题" class="headerlink" title="二、幂等性问题"></a>二、幂等性问题</h2><p>幂等，就是对接口的多次调用所产生的结果和调用一次是一致的。这里的接口，可以是对外发布的HTTP接口或者Thrift接口，也可以是接收消息的内部接口，或者是一个内部方法或操作。<br>比如以下例子：  </p>
<ul>
<li>在App下单的时候，点击确认之后没反应，就又点击几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题。  </li>
</ul>
<p>在分布式环境中，网络环境更加复杂，因前端操作抖动、网络故障、消息重复、响应速度慢等原因，对接口重复调用概率会比集中式环境下更大，尤其是重复消息在分布式环境中很难避免。  </p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li>业务操作本身就具有幂等性。</li>
<li>系统缓存所有请求与处理结果，检测到重复请求之后，自动返回之前的处理结果。</li>
</ul>
<p>分布式环境中，有些接口是天然保证幂等性的，如查询操作。有些对数据的修改是一个常量，并且无其他记录和操作，那么也可以说是具有幂等性的。其他情况下，会涉及对数据的修改、状态的变更就有必要防止重复性操作的发生，我们需要通过实现接口的幂等性来防止重复操作所带来的影响。 </p>
<h3 id="GTIS"><a href="#GTIS" class="headerlink" title="GTIS"></a>GTIS</h3><p>是分布式环境下幂等性的一个解决方案，能确保在分布式环境下操作的唯一性。  </p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>GTIS实现思路是将每一个不同的业务操作赋予其唯一性。这个唯一性通过对不同操作所对应的唯一的内容特性生成一个唯一的全局ID来实现的。基本原则是：相同的操作生成相同的全局ID；不同的操作生成不同的全局ID。  </p>
<p>生成的全局ID需要存储在外部存储引擎中，数据库、Redis或者是Tair均可以实现。考虑到Tair天生分布式和持久化的优势，目前GTIS存储在Tair中。其对应的key和value如下：  </p>
<ul>
<li>key：将对于不同的业务，采用APP_KEY + 业务操作内容特性生成一个唯一标识trans_contents。然后对唯一标识进行加密生成全局ID作为Key。  </li>
<li>value：current_timestamp + trans_contents，current_timestamp用于标识当前的操作线程。  </li>
</ul>
<p>判断是否重复，主要采用Tair的SETNX方法，如果原来没有值则set且返回成功，如果已经有值则返回失败。  </p>
<h4 id="内部流程"><a href="#内部流程" class="headerlink" title="内部流程"></a>内部流程</h4><p>GTIS内部的实现流程为：  </p>
<ol>
<li>业务方在业务操作之前，生成一个能够唯一标识该操作的transContents，传入GTIS；</li>
<li>GTIS根据传入的transContents，用MD5生成全局ID；</li>
<li>GTIS将全局ID作为key，current_timestamp + trans_contents作为value放入Tair进行setNx，将结果返回给业务方；</li>
<li>业务方根据返回结果确定能否开始进行业务操作；</li>
<li>若能，开始进行操作；若不能，则结束当前操作；</li>
<li>业务方将操作结果和请求结果传入GTIS，系统进行一次请求结果的检验；</li>
<li>若盖茨操作成功，GTIS根据Key取出value值，跟传入的返回结果进行对比，如果两者相同，则将全局ID的过期时间改为较长时间；</li>
<li>GTIS返回最终结果。  </li>
</ol>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/gtis_principle.jpg" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分布式系统由独立的服务器通过网络松散耦合组成。在这个系统中，每个服务器都是一个独立的主机，服务器之间通过内部网络连接。分布式系统有以下几个特点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可扩展性：可通过横向水平扩展来提高系统的性能和吞吐量。  &lt;/li&gt;
&lt;li&gt;高可靠性：高容错，即使系统中一台或几台故障，系统通过失效转移仍然可以提供服务。  &lt;/li&gt;
&lt;li&gt;高并发性：各机器并行独立处理和计算。  &lt;/li&gt;
&lt;li&gt;廉价高效：多台小型机而非单台高性能机。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在分布式系统中，环境复杂、网络不稳定性会造成诸如时钟不一致的问题，存在于集中式系统中机器宕机、消息丢失等问题也会在分布式环境中变得更加复杂。有两个问题是分布式环境中需要重点关注和解决的典型问题：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥性问题&lt;/li&gt;
&lt;li&gt;幂等性问题  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="大型网站技术架构" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>大型网站的架构模式</title>
    <link href="http://yoursite.com/2018/01/04/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/01/04/大型网站的架构模式/</id>
    <published>2018-01-04T03:24:00.000Z</published>
    <updated>2018-04-09T03:37:19.880Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;为了解决大型网站面临的高并发访问、海量数据的处理、高可靠运行等问题，提出了许多解决方案，来使网站达到高性能、高可用、易伸缩、可扩展、安全。这些大公司的解决方案，被更多网站重复使用，形成了大型网站的架构模式。主要通过以下几种方式来实现：<br><a id="more"></a></p>
<h3 id="1、分层"><a href="#1、分层" class="headerlink" title="1、分层"></a>1、分层</h3><p>&nbsp;<strong>分层是最常见的一种架构模式，将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统。</strong> 网络的七层通信协议也是一种分层结构。<br>&nbsp;通过分层，可以将一个庞大的系统切分成多个不同的部分，便于分工合作开发和维护；各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体的问题独立演化发展而不需要其他层必须作出相应的调整。  </p>
<h3 id="2、分割"><a href="#2、分割" class="headerlink" title="2、分割"></a>2、分割</h3><p>&nbsp;<strong>分层是横向的切分，而分割是在纵向进行切分。网站越大，其功能越复杂，服务和数据处理的种类也越多，通过分割，将这些不同的服务和功能切分开来，不仅有利于软件的开发和维护，也便于不同模块的分布式部署，来提高网站的并发处理能力和功能扩展能力。</strong><br>&nbsp;比如购物业务，可分割成机票酒店业务、3C业务、小商品业务等更小的粒度。在这个粒度上，还可以继续分割成首页、搜索列表、商品详情等模块，这些模式不管是物理上还是逻辑上都可以是独立的。  </p>
<h3 id="3、分布式"><a href="#3、分布式" class="headerlink" title="3、分布式"></a>3、分布式</h3><p>&nbsp;<strong>分层和分割可以更好的便于分布式部署，将不同模块部署在不同的服务器上，通过远程调用协同工作。</strong> 分布式意味着可以使用更多的计算机完成同样的功能，计算机越多，CPU、内存、存储资源也越多，能够处理的并发访问和数据量就越大，可以为更多的用户服务。  </p>
<h3 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h3><p>&nbsp;使用分布式将分层和分割后的模块进行独立部署，但是<strong>对于用户访问集中的模块（比如首页），还需要将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务</strong> 。当某台服务器发生故障时，负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用。  </p>
<h3 id="5、缓存"><a href="#5、缓存" class="headerlink" title="5、缓存"></a>5、缓存</h3><p>&nbsp;<strong>缓存就是将数据存放在距离计算最近的位置以加快处理速度</strong>，是改善软件性能的第一手段。<br><strong>CDN：</strong> 即内容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商哪里，在这里缓存网站的一些静态资源，可以就近以最快速度返回给用户，如将用户访问量很大的热点内容缓存在CDN。<br><strong>反向代理：</strong> 反向代理部署在网站的前端，当用户请求到达网站的数据中心时，最先访问的就是反向代理服务器，这里缓存网站的静态资源，无需将请求转发给应用服务器就可以返回给用户。<br><strong>本地缓存：</strong> 在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而不需要访问数据库。<br><strong>分布式缓存：</strong> 单机无法承受大量的缓存，需要将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。<br>使用缓存的两个前提：一个是数据访问热点不均衡，某些数据会被更频繁的访问，将这部分数据进行缓存；还有一个是数据在某个时间段内是有效的，不会很快过期，否则会产生脏读，影响结果的正确性。  </p>
<h3 id="6、异步"><a href="#6、异步" class="headerlink" title="6、异步"></a>6、异步</h3><p>&nbsp;<strong>异步架构是典型的生产者-消费者模式，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理，两者不存在直接调用，彼此功能可以随意变化而互不影响。</strong> 异步还有其他几点优势：<br><strong>1.提供系统可用性：</strong> 消费者服务器发生故障，数据会在消息队列器中存储的堆积，生产者服务器可以继续处理业务请求，等消费者服务器恢复后可以继续从队列中取数据进行处理。<br><strong>2.加快网站的响应速度：</strong> 处在业务前端的生产者服务器在处理完业务请求后，将数据写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟小。<br><strong>3.消除并发访问高峰：</strong> 使用消息队列将突然增加的访问请求数据放入消息队列，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力。  </p>
<h3 id="7、冗余"><a href="#7、冗余" class="headerlink" title="7、冗余"></a>7、冗余</h3><p>&nbsp;网站需要24小时的运行，但是服务器可能随时都会出现故障，<strong>要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样在某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。</strong> 数据库除了要定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份。为抵御自然灾害，还需要对整个数据中心进行备份，全球范围内部署灾备数据中心，网站程序和数据实时同步到多个灾备数据中心。  </p>
<h3 id="8、自动化"><a href="#8、自动化" class="headerlink" title="8、自动化"></a>8、自动化</h3><p>&nbsp;通过减少认为的干预，使发布过程自动化可以有效减少故障。自动化的代码管理，自动化的测试，自动化的安全检测，及最后自动化的部署。此外，还需要，对生产环境进行自动化监控，出现异常、超出预设阈值，会自动化报警，故障发生时自动化的失效转移，故障消除时自动化的失效恢复等等等。  </p>
<h3 id="9、安全"><a href="#9、安全" class="headerlink" title="9、安全"></a>9、安全</h3><p>&nbsp;通过密码和手机验证码进行身份认证；登录交易等操作对网络通信进行加密；为防止机器人程序滥用网络资源攻击网站，使用验证码进行识别；对于常用的攻击网络的XSS攻击，SQL注入进行编码转换等处理；对垃圾信息、敏感信息进行过滤；对交易转账等重要操作根据交易模式和交易信息进行风险控制。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;为了解决大型网站面临的高并发访问、海量数据的处理、高可靠运行等问题，提出了许多解决方案，来使网站达到高性能、高可用、易伸缩、可扩展、安全。这些大公司的解决方案，被更多网站重复使用，形成了大型网站的架构模式。主要通过以下几种方式来实现：&lt;br&gt;
    
    </summary>
    
      <category term="大型网站技术架构核心原理" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="大型网站技术架构" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java内存溢出与内存泄漏</title>
    <link href="http://yoursite.com/2017/12/08/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2017/12/08/（转）Java内存溢出和内存泄漏/</id>
    <published>2017-12-08T02:23:00.000Z</published>
    <updated>2018-04-09T03:37:52.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、为什么要了解内存泄露和内存溢出？"><a href="#一、为什么要了解内存泄露和内存溢出？" class="headerlink" title="一、为什么要了解内存泄露和内存溢出？"></a>一、为什么要了解内存泄露和内存溢出？</h2><p>1、内存泄露一般是代码设计存在缺陷导致的，通过了解内存泄露的场景，可以避免不必要的内存溢出和提高自己的代码编写水平；<br>2、通过了解内存溢出的几种常见情况，可以在出现内存溢出的时候快速的定位问题的位置，缩短解决故障的时间。<br><a id="more"></a></p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p><strong>内存泄露</strong>：无用对象持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄漏。<br><strong>内存溢出</strong>：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段（老年代）或Perm段（永久代）垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。  </p>
<h2 id="三、Java中主要的内存泄漏场景"><a href="#三、Java中主要的内存泄漏场景" class="headerlink" title="三、Java中主要的内存泄漏场景"></a>三、Java中主要的内存泄漏场景</h2><ul>
<li><p>静态集合类，容器中的对象在程序结束之前都不会释放。这些静态变量的生命周期和应用程序一致，他们所引用的对象Object也不能被释放，因为他们也将一直被Vector引用。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Vector v = <span class="keyword">new</span> Vector();</div><div class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)&#123;</div><div class="line">    <span class="keyword">Object</span> o = <span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">    v.<span class="built_in">add</span>(o);</div><div class="line">    o = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>修改hashset中对象的参数值，且参数是计算哈希值的字段。<br>  当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中删除当前对象，造成内存泄露。</p>
</li>
<li>数据库连接、网络连接、IO连接，不再使用时需要close方法释放</li>
<li>监听器，用到的监听器在释放的时候没有去删除，从而增加了内存泄漏的可能性</li>
<li>变量不合理的作用域，成员变量在使用后依然存在（结局：将变量设为局部变量）</li>
<li>单例造成内存泄漏，单例对象在初始化后将在JVM的整个生命周期内存在，如果外部对象（生命周期比较短）持有该引用，那么该外部对象就不能被回收，从而导致内存泄漏</li>
</ul>
<h2 id="四、内存溢出的几种情况："><a href="#四、内存溢出的几种情况：" class="headerlink" title="四、内存溢出的几种情况："></a>四、内存溢出的几种情况：</h2><h3 id="1、堆内存溢出（outOfMemoryError：java-heap-space）"><a href="#1、堆内存溢出（outOfMemoryError：java-heap-space）" class="headerlink" title="1、堆内存溢出（outOfMemoryError：java heap space）"></a>1、堆内存溢出（outOfMemoryError：java heap space）</h3><p>&nbsp;&nbsp;分为两种情况：一种是堆内存确实不够，还有一种是由于内存的泄漏而造成的内存溢出。<br>&nbsp;&nbsp;在jvm规范中，堆中的内存是用来生成对象实例和数组的。我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，当对象数量达到最大堆容量限制后产生内存溢出异常。    如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个eden区和两个survivor区。<br><img src="http://osrmzp0jr.bkt.clouddn.com/20141107224401036.png" alt="image"><br>当生成新对象时，内存的申请过程如下：<br>a、jvm先尝试在eden区分配新建对象所需的内存；<br>b、如果内存大小足够，申请结束，否则下一步；<br>c、jvm启动Minor GC，试图将eden区中不活跃的对象释放掉，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区；如果整个新生代都放不下对象时，可以直接在老年代分配内存；<br>d、Survivor区被用来作为Eden及old的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区；<br>e、当OLD区空间不够时，JVM会在OLD区进行full GC；<br>f、full GC后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class MemoryLeak &#123;</div><div class="line">   </div><div class="line">    <span class="keyword">private</span> <span class="keyword">String</span>[] s = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">1000</span>];</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        Map&lt;<span class="keyword">String</span>,<span class="keyword">Object</span>&gt; m =<span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>,<span class="keyword">Object</span>&gt;();</div><div class="line">        <span class="built_in">int</span> i =<span class="number">0</span>;</div><div class="line">        <span class="built_in">int</span> j=<span class="number">10000</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(;i&lt;j;i++)&#123;</div><div class="line">                MemoryLeak memoryLeak = <span class="keyword">new</span> MemoryLeak();</div><div class="line">                m.put(<span class="keyword">String</span>.valueOf(i), memoryLeak);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>&nbsp;&nbsp;出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。<br>&nbsp;&nbsp;如果是内存泄漏，可进一步通过工具（如Jrockit等工具）查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。<br>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p>
<h3 id="2、方法区内存溢出（outOfMemoryError：permgem-space）"><a href="#2、方法区内存溢出（outOfMemoryError：permgem-space）" class="headerlink" title="2、方法区内存溢出（outOfMemoryError：permgem space）"></a>2、方法区内存溢出（outOfMemoryError：permgem space）</h3><p>在jvm规范中，方法区主要存放的是类相关信息（如类名、访问修饰符、常量池、字段描述、方法描述等），静态变量，常量，即时编译器编译后的代码等。<br>所以<strong>如果程序加载的类过多，或者使用反射、gclib等这种动态代理生成类的技术，就可能导致该区发生内存溢出。</strong>  在经常动态生成大量Class的应用中，要注意这点。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jvm参数：-XX:<span class="attribute">PermSize</span>=2m -XX:<span class="attribute">MaxPermSize</span>=2m</div><div class="line">将方法区的大小设置很低即可，在启动加载类库时就会出现内存不足的情况</div></pre></td></tr></table></figure></p>
<h3 id="3、线程栈溢出（java-lang-StackOverflowError）"><a href="#3、线程栈溢出（java-lang-StackOverflowError）" class="headerlink" title="3、线程栈溢出（java.lang.StackOverflowError）"></a>3、线程栈溢出（java.lang.StackOverflowError）</h3><p>线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。<br><strong>一般线程栈溢出是由于递归太深或方法调用层级过多导致的。</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StackOverflowTest</span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</div><div class="line">    digui(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">digui</span>(<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;</div><div class="line">    System.<span class="keyword">out</span>.println(i++);</div><div class="line">    String[] s = <span class="keyword">new</span> String[<span class="number">50</span>];</div><div class="line">    digui(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议："><a href="#五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议：" class="headerlink" title="五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议："></a>五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议：</h2><p>1、尽早释放无用对象的引用<br>2、使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域<br>3、尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收<br>4、避免在循环中创建对象<br>5、开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、为什么要了解内存泄露和内存溢出？&quot;&gt;&lt;a href=&quot;#一、为什么要了解内存泄露和内存溢出？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么要了解内存泄露和内存溢出？&quot;&gt;&lt;/a&gt;一、为什么要了解内存泄露和内存溢出？&lt;/h2&gt;&lt;p&gt;1、内存泄露一般是代码设计存在缺陷导致的，通过了解内存泄露的场景，可以避免不必要的内存溢出和提高自己的代码编写水平；&lt;br&gt;2、通过了解内存溢出的几种常见情况，可以在出现内存溢出的时候快速的定位问题的位置，缩短解决故障的时间。&lt;br&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java虚拟机" scheme="http://yoursite.com/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何保证线程的顺序执行？</title>
    <link href="http://yoursite.com/2017/12/05/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/12/05/如何保证线程的顺序执行？/</id>
    <published>2017-12-05T08:43:00.000Z</published>
    <updated>2018-04-11T09:18:12.696Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;有T1，T2，T3三个线程，如何保证T1执行完再执行T2，T2执行完再执行T3？这个问题是面试的常考问题，涉及到了一些java并发知识的实际应用。主要有下面三种方法，依次讲解下：<br><a id="more"></a></p>
<h2 id="1、使用join关键字实现"><a href="#1、使用join关键字实现" class="headerlink" title="1、使用join关键字实现"></a>1、使用join关键字实现</h2><p>join关键字用于让当前线程等待join线程执行完毕后再执行，否则会处于等待阻塞状态。有两种方法：<br>方法一：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="keyword">Task</span> <span class="keyword">implements</span> Runnable&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">Task</span>(<span class="keyword">int</span> taskId)&#123;</div><div class="line">        <span class="keyword">this</span>.taskId = taskId; </div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</div><div class="line">        System.out.<span class="keyword">println</span>(<span class="string">"线程"</span>+taskId+<span class="string">"运行！"</span>)；</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> method1() <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">1</span>));</div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">2</span>));</div><div class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">3</span>));</div><div class="line">    </div><div class="line">    t1.start();</div><div class="line">    t1.<span class="keyword">join</span>();<span class="comment">//阻塞主线程，直到线程1执行完</span></div><div class="line">    t2.start();</div><div class="line">    t2.<span class="keyword">join</span>();<span class="comment">//阻塞主线程，直到线程2执行完</span></div><div class="line">    t3.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)&#123;</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">"线程1运行！"</span>)；</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                t1.<span class="keyword">join</span>();</div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"线程2运行！"</span>);</div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                t2.<span class="keyword">join</span>();</div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"线程3运行！"</span>);</div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    t1.start();</div><div class="line">    t2.start();</div><div class="line">    t3.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2、使用队列"><a href="#2、使用队列" class="headerlink" title="2、使用队列"></a>2、使用队列</h2><p>把线程依次加入到队列里，按顺序执行即可。newSingleThreadExecutor是一个只有一个消费线程的线程池，这个消费线程会按队列FIFO的顺序去任务队列里取任务，只要保证三个线程按顺序放入就可以了。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="keyword">Task</span> <span class="keyword">implements</span> Runnable&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">Task</span>(<span class="keyword">int</span> taskId)&#123;</div><div class="line">        <span class="keyword">this</span>.taskId = taskId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</div><div class="line">        System.out.<span class="keyword">println</span>(<span class="string">"线程"</span>+taskId+<span class="string">"执行！"</span>)；</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> method3()&#123;</div><div class="line">    ExecutorService threadPool = Executors.newSingleThreadExecutor();</div><div class="line">    threadPool.execute(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">1</span>));</div><div class="line">    threadPool.execute(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">2</span>));</div><div class="line">    threadPool.execute(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">3</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3、使用CountDownLatch关键字实现"><a href="#3、使用CountDownLatch关键字实现" class="headerlink" title="3、使用CountDownLatch关键字实现"></a>3、使用CountDownLatch关键字实现</h2><p>执行它的latch.await()方法，如果计数器不为0，那么当前线程就会被阻塞；每完成一个任务，就执行latch.countDown()，计数器减一，当计数器为0时，阻塞的线程恢复执行状态。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">final</span> CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    <span class="keyword">final</span> CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    </div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"线程1执行！"</span>);</div><div class="line">            lacth1.countDown();<span class="comment">//执行完任务后，计数器减一</span></div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">    </div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                latch1.await();<span class="comment">//直到t1中countDown后计数器为0时，t2才继续执行</span></div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程2执行！"</span>);</div><div class="line">            lacth2.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">    </div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                latch2.await();<span class="comment">//直到t2中countDown后计数器为0时，t3才继续执行</span></div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程3执行！"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;有T1，T2，T3三个线程，如何保证T1执行完再执行T2，T2执行完再执行T3？这个问题是面试的常考问题，涉及到了一些java并发知识的实际应用。主要有下面三种方法，依次讲解下：&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java并发" scheme="http://yoursite.com/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式</title>
    <link href="http://yoursite.com/2017/12/01/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/01/工厂方法模式/</id>
    <published>2017-12-01T12:40:00.000Z</published>
    <updated>2018-04-11T09:22:53.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、普通工厂模式"><a href="#一、普通工厂模式" class="headerlink" title="一、普通工厂模式"></a>一、普通工厂模式</h1><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。关系图如下：<br><img src="http://osrmzp0jr.bkt.clouddn.com/factory1.png" alt="image"><br><a id="more"></a><br>举例如下：发送邮件和发送短信的例子</p>
<p><pre><br>//两者的共同接口<br>public interface Sender{<br>    public void Send();<br>}</pre></p>
<p>//创建实现类<br>public class MailSender implements Sender{<br>    @Override<br>    public void Send(){<br>        System.out.println(“this is mailSender!”);<br>    }<br>}</p>
<p>public class SmsSender implements Sender{<br>    @Override<br>    public void Send(){<br>        System.out.println(“this is smsSender!”);<br>    }<br>}</p>
<p>//建工厂类<br>public class SendFactory{<br>    public Sender produce(String type){<br>        if(“mail”.equals(type)){<br>            return new MailSender();<br>        }else if(“sms”.equals(type)){<br>            return new SmsSender();<br>        }else{<br>            System.out.println(“请输入正确的类型！”)<br>            return null;<br>        }<br>    }<br>}</p>
<p>//测试类<br>public class FactoryTest{<br>    public static void main(String[] args){<br>        SendFactory factory = new SendFactory();<br>        Sender sender = factory.produce(“mail”);<br>        sender.Send();<br>    }<br>}<br></p>
<h1 id="二、多个工厂方法模式"><a href="#二、多个工厂方法模式" class="headerlink" title="二、多个工厂方法模式"></a>二、多个工厂方法模式</h1><p>是对普通工厂方法模式的改进，在普通方法的模式中，如果传递的字符串出错，就不能正确的创建对象。而多个工厂方法模式，提供多个工厂方法，分别创建对象。<br><img src="http://osrmzp0jr.bkt.clouddn.com/factory2.png" alt="image">  </p>
<p><pre><br>//只需工厂方法进行修改<br>public class SendFactory{<br>    public Sender produceMail(){<br>        return new MailSender();<br>    }<br>    public Sender produceSms(){<br>        return new SmsSender();<br>    }<br>}</pre></p>
<p>//测试类<br>public class FactoryTest{<br>    public static void main(String[] args){<br>        SendFactory factory = new SendFactory();<br>        Sender sender = factory.produceMail();<br>        sender.Send();<br>    }<br>}<br></p>
<h1 id="三、静态工厂方法模式"><a href="#三、静态工厂方法模式" class="headerlink" title="三、静态工厂方法模式"></a>三、静态工厂方法模式</h1><p>将上面多个工厂方法的模式里的方法设置为静态的，不需要创建实例，直接调用即可。  </p>
<p><pre><br>public class SendFactory{<br>    public static Sender produceMail(){<br>        return new MailSender();<br>    }<br>    public static Sender produceSms(){<br>        return new SmsSender();<br>    }<br>}</pre></p>
<p>//测试类<br>public class FactoryTest{<br>    public static void main(String[] args){<br>        Sender sender = SendFactory.produceMail();<br>        sender.Send();<br>    }<br>}<br></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>如果出现了大量的产品需要创建，并且有共同的接口时，可以通过工厂方法模式来进行创建。第一种如果传入的字符串有错误，不能正确创建对象；第三种相较于第二种，不需要实例化工厂类。大多数情况下，静态工厂方法模式使用较多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、普通工厂模式&quot;&gt;&lt;a href=&quot;#一、普通工厂模式&quot; class=&quot;headerlink&quot; title=&quot;一、普通工厂模式&quot;&gt;&lt;/a&gt;一、普通工厂模式&lt;/h1&gt;&lt;p&gt;就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。关系图如下：&lt;br&gt;&lt;img src=&quot;http://osrmzp0jr.bkt.clouddn.com/factory1.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://yoursite.com/2017/12/01/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/01/抽象工厂模式/</id>
    <published>2017-12-01T12:40:00.000Z</published>
    <updated>2018-04-11T09:20:41.700Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;前面讲的工厂方法模式，存在一个问题：类的创建依赖于工厂类，也就是说，如果需要扩展程序，必须对工厂类进行修改。这时候我们使用抽象工厂类，就可以解决这个问题。创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了。<br><img src="http://osrmzp0jr.bkt.clouddn.com/factory3.png" alt="image"><br><a id="more"></a><br>Sender接口：</p>
<p><pre><br>public interface Sender{<br>    public void Send();<br>}<br></pre><br>两个实现类：  </p>
<p><pre><br>public class MailSender implements Sender{<br>    @Override<br>    public void Send(){<br>        System.out.println(“this is mailSender!”);<br>    }<br>}</pre></p>
<p>public class SmsSender implements Sender{<br>    @Override<br>    public void Send(){<br>        System.out.println(“this is smsSender!”);<br>    }<br>}<br><br>两个工厂类：  </p>
<p><pre><br>public class SendMailFactory implements Provider{<br>    @Override<br>    public Sender produce(){<br>        return new MailSender();<br>    }<br>}</pre></p>
<p>public class SendSmsFactory implements Provider{<br>    @Override<br>    public Sender produce(){<br>        return new SmsSender();<br>    }<br>}<br><br>提供一个接口：  </p>
<p><pre><br>public interface Provider{<br>    public Sender produce();<br>}<br></pre><br>测试类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Provider provider = <span class="keyword">new</span> SendMailFactory();</div><div class="line">        MailSender mailSender = provider.produce();</div><div class="line">        mailSender.Send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;这时如果想要增加一个功能：发及时信息，那么只需要做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就不用过去改动现有的代码。这么做的话，扩展性会更好！  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;前面讲的工厂方法模式，存在一个问题：类的创建依赖于工厂类，也就是说，如果需要扩展程序，必须对工厂类进行修改。这时候我们使用抽象工厂类，就可以解决这个问题。创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了。&lt;br&gt;&lt;img src=&quot;http://osrmzp0jr.bkt.clouddn.com/factory3.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2017/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/01/单例模式/</id>
    <published>2017-12-01T12:40:00.000Z</published>
    <updated>2018-04-11T09:24:08.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式是一套被反复使用、多数人知晓的、代码设计经验的总结。<br>目的：为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。  </p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>保证整个应用中某个实例有且只有一个。  </p>
<h2 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h2><p>有些对象我们只需要一个，比如<strong>配置文件、工具类、线程池、缓存、日志对象</strong>等。如果创造出多个实例，就会导致许多问题，比如占用过多资源，不一致的结果等。<br><a id="more"></a></p>
<h2 id="一、饿汉模式"><a href="#一、饿汉模式" class="headerlink" title="一、饿汉模式"></a>一、饿汉模式</h2><p>第一步：将构造方法私有化，不允许外部直接创建对象<br>第二步：创建类的唯一实例，使用private static修饰，private保证不让外部类直接访问，static保证在第一次加载类的时候就创建了类的唯一实例。<br>第三步：提供一个用于获取实例的方法，使用public static修饰，static保证外部可以用类来调用该方法。<br><strong>所谓饿汉，主要体现在第二步，在加载类的时候就创建了类的唯一实例，而不管你是否会使用到，用空间来换取时间。</strong><br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public calss Singleton&#123;</div><div class="line"></div><div class="line">    //1.将构造方法私有化，不允许外部直接创建对象</div><div class="line">   <span class="keyword"> private</span> Singleton()&#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    //2.创建类的唯一实例，使用private<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</div><div class="line">    </div><div class="line">    //3.提供一个用于获取实例的方法，使用public<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance()&#123;</div><div class="line">       <span class="built_in"> return </span>instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二、懒汉模式"><a href="#二、懒汉模式" class="headerlink" title="二、懒汉模式"></a>二、懒汉模式</h2><p><strong>懒汉主要体现在只有在需要获取实例时，才去创建。判断实例是否为空，为空则创建唯一实例。用时间来换取空间。</strong><br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private class Singleton&#123;</div><div class="line">    //1.将构造方法私有化，不允许外部直接创建对象</div><div class="line">   <span class="keyword"> private</span> Singleton()&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //2.声明类的实例变量，使用private<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton instance;</div><div class="line">    </div><div class="line">    //3.提供一个用于获取实例的方法，使用public<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance()&#123;</div><div class="line">        if(instance==null)&#123;</div><div class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> return </span>instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>饿汉模式的特点是加载类时比较慢，因为需要创建类的实例，但运行时获取对象的速度比较快，是线程安全的。<br>懒汉模式的特点是加载类时比较快，因为不需要在加载时创建类的实例，但运行时获取对象的速度比较慢，是线程不安全的。  </p>
<h2 id="三、懒汉模式的优化"><a href="#三、懒汉模式的优化" class="headerlink" title="三、懒汉模式的优化"></a>三、懒汉模式的优化</h2><p>懒汉模式是线程不安全的，首先我们想到的是在getInstace()方法上加上synchronized关键字，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static synchronized Singleton getInstance()&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="attribute">instance</span>==null)&#123;</div><div class="line">           <span class="built_in"> instance </span>= new Singleton();</div><div class="line">        &#125;</div><div class="line">        return<span class="built_in"> instance;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这样的做法，会让性能下降，原因是每次调用getInstance()，都需要拿到对象上锁，事实上我们只需要在第一次创建对象的时候加锁，之后就不需要了。进行下面的优化，使用双重判断：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance()&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="attribute">instance</span>==null)&#123;</div><div class="line">            synchronized(instance)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="attribute">instance</span>==null)&#123;</div><div class="line">               <span class="built_in"> instance </span>= new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return<span class="built_in"> instance;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实这样问题没有完全解决，instance = new Singleton()，这一句其实包含三个步骤：<br>1.在内存中为实例分配空间<br>2.进行Singleton的初始化动作<br>3.将实例的内存地址赋给instance变量<br>但这三步的顺序是不能保证的，可能在给Singleton分配完空间后就进行了赋值操作，使得没有进行初始化。这时候使用实例时，就会出现问题。  </p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><h4 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h4><p>单例模式可以使用内部类来维护它的实现，jvm内部的机制可以保证一个类被加载时候是线程互斥的，当我们第一次调用getInstance方法时，可以保证Instance只被创建一次，并且保证instance初始化完毕，就不用担心上面的问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></div><div class="line"></div><div class="line">    <span class="comment">//私有构造方法，防止被实例化</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//使用内部类来维护单例</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span>&#123;</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="comment">//获取实例</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonFactory.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第二种方法（推荐）"><a href="#第二种方法（推荐）" class="headerlink" title="第二种方法（推荐）"></a>第二种方法（推荐）</h4><p>将instance变量用volatile关键字修饰，这样做的目的是禁止指令重排序，就不会出现Singleton没有被正常初始化的问题。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line"></div><div class="line">    //私有构造方法</div><div class="line">   <span class="keyword"> private</span> Singleton()&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //volatile修饰instance变量</div><div class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile Singleton<span class="built_in"> instance </span>= null;</div><div class="line">    </div><div class="line">    //获取实例</div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance()&#123;</div><div class="line">        if(instance == null)&#123;</div><div class="line">            synchronized(instance)&#123;</div><div class="line">                if(instance == null)&#123;</div><div class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> return </span>instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是设计模式&quot;&gt;&lt;a href=&quot;#什么是设计模式&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式&quot;&gt;&lt;/a&gt;什么是设计模式&lt;/h1&gt;&lt;p&gt;设计模式是一套被反复使用、多数人知晓的、代码设计经验的总结。&lt;br&gt;目的：为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。  &lt;/p&gt;
&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;保证整个应用中某个实例有且只有一个。  &lt;/p&gt;
&lt;h2 id=&quot;应用场合&quot;&gt;&lt;a href=&quot;#应用场合&quot; class=&quot;headerlink&quot; title=&quot;应用场合&quot;&gt;&lt;/a&gt;应用场合&lt;/h2&gt;&lt;p&gt;有些对象我们只需要一个，比如&lt;strong&gt;配置文件、工具类、线程池、缓存、日志对象&lt;/strong&gt;等。如果创造出多个实例，就会导致许多问题，比如占用过多资源，不一致的结果等。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的四种遍历方式</title>
    <link href="http://yoursite.com/2017/12/01/HashMap%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/12/01/HashMap的四种遍历方式/</id>
    <published>2017-12-01T12:39:00.000Z</published>
    <updated>2018-04-09T01:06:17.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Map的四种遍历方式"><a href="#一、Map的四种遍历方式" class="headerlink" title="一、Map的四种遍历方式"></a>一、Map的四种遍历方式</h1><h2 id="1、foreach-map-entrySet"><a href="#1、foreach-map-entrySet" class="headerlink" title="1、foreach map.entrySet()"></a>1、foreach map.entrySet()</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;();</div><div class="line"><span class="built_in">for</span>(Entry&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; entry : <span class="built_in">map</span>.entrySet())&#123;</div><div class="line">    entry.<span class="built_in">getKey</span>();</div><div class="line">    entry.getValue();</div><div class="line">    </div><div class="line">    <span class="comment">//在遍历过程中删除元素，会抛出异常java.util.ConcurrentModificationException</span></div><div class="line">    <span class="comment">//entry.remove(entry.getKey());</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、调用map-entrySet-的集合迭代器"><a href="#2、调用map-entrySet-的集合迭代器" class="headerlink" title="2、调用map.entrySet()的集合迭代器"></a>2、调用map.entrySet()的集合迭代器</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Iterator&lt;Map.Entry&lt;String,String&gt;&gt; </span><span class="keyword">it </span>= <span class="meta">map</span>.entrySet().<span class="keyword">iterator();</span></div><div class="line"><span class="symbol">while</span>(<span class="keyword">it.hasNext())&#123;</span></div><div class="line">    <span class="meta">Map</span>.Entry&lt;<span class="keyword">String,String&gt; </span><span class="meta">entry</span> = <span class="keyword">it.next();</span></div><div class="line">    <span class="meta">entry</span>.getKey()<span class="comment">;</span></div><div class="line">    <span class="meta">entry</span>.getValue()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、foreach-map-keySet"><a href="#3、foreach-map-keySet" class="headerlink" title="3、foreach map.keySet()"></a>3、foreach map.keySet()</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">key</span> : <span class="built_in">map</span>.keySet())&#123;</div><div class="line">    <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、foreach-map-entrySet-，用临时变量保存map-entrySet"><a href="#4、foreach-map-entrySet-，用临时变量保存map-entrySet" class="headerlink" title="4、foreach map.entrySet()，用临时变量保存map.entrySet()"></a>4、foreach map.entrySet()，用临时变量保存map.entrySet()</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Set</span>&lt;<span class="meta">Entry</span>&lt;<span class="keyword">String,String&gt;&gt; </span>entrySet = <span class="meta">map</span>.entrySet()<span class="comment">;</span></div><div class="line"><span class="symbol">for</span>(<span class="meta">Entry</span>&lt;<span class="keyword">String,String&gt; </span><span class="meta">entry</span> : entrySet())&#123;</div><div class="line">    <span class="meta">entry</span>.getKey()<span class="comment">;</span></div><div class="line">    <span class="meta">entry</span>.getValue()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="二、结论"><a href="#二、结论" class="headerlink" title="二、结论"></a>二、结论</h1><p>1、在foreach map.entrySet()这种遍历方法的遍历过程中，不能删除元素，由于在遍历HashMap中删除了当前元素，下一个待访问的元素的指针也丢失了，所以会抛出java.util.ConcurrentModificationException。<br>2、如果需要在遍历过程中进行删除元素，可以使用调用map.entrySet()的集合迭代器来进行遍历。<br>3、如果只需要遍历key而不需要value的话，可以使用foreach map.keySet()的方式进行遍历。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、Map的四种遍历方式&quot;&gt;&lt;a href=&quot;#一、Map的四种遍历方式&quot; class=&quot;headerlink&quot; title=&quot;一、Map的四种遍历方式&quot;&gt;&lt;/a&gt;一、Map的四种遍历方式&lt;/h1&gt;&lt;h2 id=&quot;1、foreach-map-entrySet&quot;&gt;&lt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="java基础" scheme="http://yoursite.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
