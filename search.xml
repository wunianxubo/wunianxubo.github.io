<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>分布式系统互斥性与幂等性问题的分析和解决</title>
      <link href="/2018/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BA%92%E6%96%A5%E6%80%A7%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>/2018/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BA%92%E6%96%A5%E6%80%A7%E4%B8%8E%E5%B9%82%E7%AD%89%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式系统由独立的服务器通过网络松散耦合组成。在这个系统中，每个服务器都是一个独立的主机，服务器之间通过内部网络连接。分布式系统有以下几个特点：  </p><ul><li>可扩展性：可通过横向水平扩展来提高系统的性能和吞吐量。  </li><li>高可靠性：高容错，即使系统中一台或几台故障，系统通过失效转移仍然可以提供服务。  </li><li>高并发性：各机器并行独立处理和计算。  </li><li>廉价高效：多台小型机而非单台高性能机。  </li></ul><p>在分布式系统中，环境复杂、网络不稳定性会造成诸如时钟不一致的问题，存在于集中式系统中机器宕机、消息丢失等问题也会在分布式环境中变得更加复杂。有两个问题是分布式环境中需要重点关注和解决的典型问题：  </p><ul><li>互斥性问题</li><li>幂等性问题<a id="more"></a><h2 id="一、互斥性问题"><a href="#一、互斥性问题" class="headerlink" title="一、互斥性问题"></a>一、互斥性问题</h2>看个例子：<br>某服务器提供一组任务，A请求随机从任务组中获取一个任务；B请求随机从任务组中获取一个任务。在理想情况下，A从任务组中挑选一个任务，任务组删除该任务，B从剩下的任务组中再挑一个，之后任务组再删除。<br>但在真实情况下，如不做任何处理，可能出现A和B挑中了同一个任务的情况。  </li></ul><p>上面这个例子，存在操作互斥性的问题，其实就是对共享资源的抢占问题。如果不同的请求对同一个或者同一组资源读取并修改时，无法保证其按序执行，无法保证一个操作的原子性，那么就很有可能会出现预期外的情况。所以操作的互斥性问题可以理解为一个需要保证时序性、原子性的问题。  </p><p>在传统的基于数据库的架构中，对于数据的抢占问题往往是通过数据库事务（ACID）来保证的。在分布式环境中，<strong>分布式锁</strong>是一种比较常见和高效的解决方案。在传统的多线程、多进程情况下，已有比较好的解决方案，我们先来看看传统情况下是怎么解决的。  </p><h3 id="多线程环境下的解决方案"><a href="#多线程环境下的解决方案" class="headerlink" title="多线程环境下的解决方案"></a>多线程环境下的解决方案</h3><p><strong>基本上所有的并发模式在解决线程冲突的问题上，都是采用序列化访问共享资源的方式。</strong><br>在多线程环境下，最普遍的方式就是用互斥锁把该资源或对资源的操作保护起来。Java中提供两种互斥锁Lock和synchronized。不同线程之间对同一资源进行抢占，该资源通常表现为某个类的普通成员变量，使用Lock和synchronized将共享的变量及其操作锁住，就可以解决资源抢占的问题。  </p><h3 id="多进程的解决方案"><a href="#多进程的解决方案" class="headerlink" title="多进程的解决方案"></a>多进程的解决方案</h3><p>在多道程序系统中存在许多进程，它们共享各种资源，然而有很多资源一次只能供一个进程使用，这便是临界资源。多进程中的临界资源大致可以分为两类，一类是物理上的真实资源，如打印机；一类是硬盘或内存中的共享数据，如共享内存等。进程内互斥访问临界资源的代码称为<strong>临界区</strong>。<br>对于临界资源的互斥访问，JVM层面的锁已经失去作用了。在多进程情况下，主要还是利用操作系统层面的进程间通信原理来解决临界资源的抢占问题。比较常见的一种方法是使用信号量（Semaphores）<br>信号量分为有名信号量和无名信号量。无名信号量通常保存在共享内存中，而有名信号量是于一个特定的文件夹名称相关联。对信号量的操作主要是P操作（wait）和V操作（signal）。  </p><ul><li>P操作：先检查信号量的大小，若值大于零，则将信号量减1，同时进程获得共享资源的访问权限，继续执行；若小于或者等于零，则该进程被阻塞后，进入等待队列。  </li><li>V操作：该操作将信号量的值加1，如果有进程阻塞着等待该信号量，那么其中一个进程被唤醒。  </li></ul><p>对共享资源的操作前后（进入和退出临界区）进行加锁和解锁，保证不同线程或进程可以互斥有序的操作资源。  </p><h3 id="分布式环境下的解决方案——分布式锁"><a href="#分布式环境下的解决方案——分布式锁" class="headerlink" title="分布式环境下的解决方案——分布式锁"></a>分布式环境下的解决方案——分布式锁</h3><p>不管是多线程还是多进程环境下的锁都有很多共通之处，他们满足一些最基本的条件：  </p><ol><li>需要有存储锁的空间，并且锁的空间是可以访问到的。  </li><li>锁需要被唯一标识（全局唯一）。  </li><li>锁至少要有两种状态，如ReetrantLock中的status，0表示没有线程竞争，大于0表示有线程竞争；或者是有锁、没锁这样分类。  </li></ol><p>有了这三个条件，就可以基本上实现一个简单的分布式锁了。以数据库为例，实现一个简单的分布式锁：数据库表，字段为锁的ID（唯一标识），还有锁的状态（0表示没锁，1表示被锁）。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">lock</span> = mysql.<span class="keyword">get</span>(id);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">lock</span>.status == <span class="number">1</span>)  <span class="comment">//已被锁，继续等待获取</span></div><div class="line">    sleep(<span class="number">100</span>);</div><div class="line">mysql.update(<span class="keyword">lock</span>.status = <span class="number">1</span>);  <span class="comment">//获取到锁，更新锁状态为被锁 </span></div><div class="line">doSomthing();  <span class="comment">//执行逻辑</span></div><div class="line">mysql.update(<span class="keyword">lock</span>.status = <span class="number">0</span>);  <span class="comment">//释放锁，更新锁状态</span></div></pre></td></tr></table></figure></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>上面简单的实现了一个分布式锁，但是存在一些问题：  </p><ul><li>问题1：锁状态判断的原子性无法保证<br>从读取锁的状态，到判断该状态是否为被锁，这两个操作如果不能保证是原子性的，就可能导致不止一个请求获取到了锁，这显然是不行的。  </li><li>问题2：网络断开或主机宕机，锁状态无法清除<br>假设主机在获取到锁的情况下，突然出现了网络断开或者主机宕机，如果不做任何处理该锁将仍然处于被锁定的状态。那么之后的所有请求都无法再成功抢占到这个锁。因此，我们需要在持有锁的主机遇到网络断开或者主机宕机时，及时的释放掉这把锁。  </li><li>问题3：无法保证释放的是自己上锁的那把锁<br>如果持有锁的主机A在临界区遇到网络抖动而导致网络断开，分布式锁及时的被释放了。之后，另一个主机B占用了这把锁，但是此时主机A网络恢复，退出临界区并解锁。由于都是一把锁，所以数据库中锁的状态会变为无占用状态；如果此时第三个主机C尝试抢占这把锁，也将会成功获得。因此，我们需要在解锁时，确定自己解的这个锁是否还是当前主机还依旧占用的这把锁（因为可能在这之前这把锁已经被释放过了）。  </li></ul><h4 id="进阶条件"><a href="#进阶条件" class="headerlink" title="进阶条件"></a>进阶条件</h4><p>分布式锁的实现，如果可以解决上面三个问题，可以算是一个相对完整的分布式锁了。在实际情况中，可能有更高级的要求。  </p><ol><li>可重入：线程中的可重入，指的是外层函数获得锁之后，内层也可以获得锁，Lock和synchronized都是可重入锁；在分布式环境中，一般还是指的线程的可重入。  </li><li>惊群效应（Herd Effect）：在分布式锁中，惊群效应指的是，在有多个请求等待获取锁的时候，一旦占有锁的线程释放之后，如果所有等待方都被同时唤醒，尝试抢占锁。但是这样的情况会造成比较大的开销，应避免惊群效应的产生。  </li><li>公平锁于非公平锁：不同需求下可能需要不同分布式锁。非公平锁开销较小，但如果业务需求竞争者按顺序获得锁，那么就需要实现公平锁。  </li><li>阻塞锁和自旋锁：阻塞锁需要上下文的切换，或并发量高且临界区的操作耗时比较短，那么性能开销会比较大。如果临界区操作耗时比较长，一直保持自旋，也会对CPU造成更大的负荷。  </li></ol><h4 id="典型实现"><a href="#典型实现" class="headerlink" title="典型实现"></a>典型实现</h4><h5 id="Zookeeper的实现"><a href="#Zookeeper的实现" class="headerlink" title="Zookeeper的实现"></a>Zookeeper的实现</h5><p>Zookeeper中有一种节点叫做顺序节点，假如我们在/lock/目录下创建三个节点，zk集群会按照发起创建的顺序来创建节点，节点分别为/lock/00000001、/lock/00000002、/lock/00000003。<br>zk中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端于zk集群断开连接，则该节点自动被删除。  </p><p>根据zk中节点是否存在，可以作为分布式锁的锁状态，以此来实现一个分布式锁，下面是分布式锁的基本逻辑：  </p><ol><li>客户端调用create()方法创建名为”/dlm-locks/lockname/lock-“的临时顺序节点。  </li><li>客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。</li><li>客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，那么久认为这个客户端获得了锁。  </li><li>如果创建的节点不是所有节点中最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。  </li></ol><p>释放锁的过程相对比较简单，就是删除自己创建的那个子节点即可。  </p><h5 id="Redis的实现"><a href="#Redis的实现" class="headerlink" title="Redis的实现"></a>Redis的实现</h5><p>Redis的分布式缓存特性使其成为了分布式锁的一种基础实现。通过Redis中是否存在某个锁ID，则可以判断是否已经上锁。为了保证判断锁是否存在的原子性，保证只有一个县城获取同一把锁，Redis有SETNX(set if not exist)和GETSET（先写新值，返回旧值，原子性操作，用于分辨是不是首次操作）。  </p><p>为了防止主机宕机和网络断开之后的死锁，Redis没有zk那种天然的实现方式，只能依赖设置超时时间来规避。  </p><p>下面是一种比较普遍但不太完善的Redis分布式锁的实现步骤：  </p><ol><li>线程A发送SETNX lock.orderid尝试获得锁，如果锁不存在，则set并获得锁。  </li><li>如果锁存在，则再判断锁的值（时间戳）是否大于当前时间，如果没有超时，则等待下再重试。  </li><li>如果已经超时，再用GETSET lock.orderid来尝试获取锁，如果这时候拿到的时间戳仍然超时，那么说明已经获得锁了。  </li><li>如果在此之前，另一个线程C快一步执行了上面的操作，那么A拿到的时间戳是个未超时的值，这是A没有如期获得锁，需要再次等待或重试。</li></ol><h5 id="Tair的实现"><a href="#Tair的实现" class="headerlink" title="Tair的实现"></a>Tair的实现</h5><p>实现与Redis类似，Tair客户端封装了一个expireLock的方法：通过锁状态和过期时间戳来共同判断锁是否存在，只有锁已经存在且没有过期的状态才判定为有锁状态。在有锁的情况下，不能加锁，能通过大于或等于过期时间的时间戳进行解锁。  </p><p>采用这种方式，可以不用再Value中存储时间戳，并且保证了判断是否有锁的原子性。并且，由于超时时间由Tair判断，所以避免了不同主机时钟不一致的情况。  </p><h5 id="分布式锁的弊端"><a href="#分布式锁的弊端" class="headerlink" title="分布式锁的弊端"></a>分布式锁的弊端</h5><ul><li>强依赖于外部组件：分布式锁的实现都依赖于外部数据存储如zk、Redis等，因此一旦这些外部组件出现故障，那么分布式锁就不可用了。  </li><li>无法完全满足需求：不同分布式锁的实现，都有相应的特点，对于一些需求并不能很好的满足，如实现公平锁、给等待锁加超时时间等等。  </li></ul><p>基于以上的问题，结合多种的实现方式，美团开发了Cerberus，提供更灵活可靠的分布式锁。Cerberus有以下特点：  </p><ol><li>一套接口多种引擎。使用了多种引擎实现方式（Tair、ZK、未来支持Redis），可自主选择所需的一种或多种引擎。</li><li>使用灵活，学习成本低。提供一套API，方便使用。  </li><li>支持一键降级。可以实时切换引擎的接口，用于应对所依赖主引擎的故障发生。</li></ol><h2 id="二、幂等性问题"><a href="#二、幂等性问题" class="headerlink" title="二、幂等性问题"></a>二、幂等性问题</h2><p>幂等，就是对接口的多次调用所产生的结果和调用一次是一致的。这里的接口，可以是对外发布的HTTP接口或者Thrift接口，也可以是接收消息的内部接口，或者是一个内部方法或操作。<br>比如以下例子：  </p><ul><li>在App下单的时候，点击确认之后没反应，就又点击几次。在这种情况下，如果无法保证该接口的幂等性，那么将会出现重复下单问题。  </li></ul><p>在分布式环境中，网络环境更加复杂，因前端操作抖动、网络故障、消息重复、响应速度慢等原因，对接口重复调用概率会比集中式环境下更大，尤其是重复消息在分布式环境中很难避免。  </p><p>分布式环境中，有些接口是天然保证幂等性的，如查询操作。有些对数据的修改是一个常量，并且无其他记录和操作，那么夜可以说是具有幂等性的。其他情况下，会涉及对数据的修改、状态的变更就有必要防止重复性操作的发生，我们需要通过实现接口的幂等性来防止重复操作所带来的影响。 </p><h3 id="GTIS"><a href="#GTIS" class="headerlink" title="GTIS"></a>GTIS</h3><p>是分布式环境下幂等性的一个解决方案，能确保在分布式环境下操作的唯一性。  </p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>GTIS实现思路是将每一个不同的业务操作赋予其唯一性。这个唯一性通过对不同操作所对应的唯一的内容特性生成一个唯一的全局ID来实现的。基本原则是：相同的操作生成相同的全局ID；不同的操作生成不同的全局ID。  </p><p>生成的全局ID需要存储在外部存储引擎中，数据库、Redis或者是Tair均可以实现。考虑到Tair天生分布式和持久化的优势，目前GTIS存储在Tair中。其对应的key和value如下：  </p><ul><li>key：将对于不同的业务，采用APP_KEY + 业务操作内容特性生成一个唯一标识trans_contents。然后对唯一标识进行加密生成全局ID作为Key。  </li><li>value：current_timestamp + trans_contents，current_timestamp用于标识当前的操作线程。  </li></ul><p>判断是否重复，主要采用Tair的SETNX方法，如果原来没有值则set且返回成功，如果已经有值则返回失败。  </p><h4 id="内部流程"><a href="#内部流程" class="headerlink" title="内部流程"></a>内部流程</h4><p>GTIS内部的实现流程为：  </p><ol><li>业务方在业务操作之前，生成一个能够唯一标识该操作的transContents，传入GTIS；</li><li>GTIS根据传入的transContents，用MD5生成全局ID；</li><li>GTIS将全局ID作为key，current_timestamp + trans_contents作为value放入Tair进行setNx，将结果返回给业务方；</li><li>业务方根据返回结果确定能否开始进行业务操作；</li><li>若能，开始进行操作；若不能，则结束当前操作；</li><li>业务方将操作结果和请求结果传入GTIS，系统进行一次请求结果的检验；</li><li>若盖茨操作成功，GTIS根据Key取出value值，跟传入的返回结果进行对比，如果两者相同，则将全局ID的过期时间改为较长时间；</li><li>GTIS返回最终结果。  </li></ol><p><img src="http://osrmzp0jr.bkt.clouddn.com/gtis_principle.jpg" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大型网站技术架构 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>大型网站的架构模式</title>
      <link href="/2018/01/04/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/01/04/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>&nbsp;为了解决大型网站面临的高并发访问、海量数据的处理、高可靠运行等问题，提出了许多解决方案，来使网站达到高性能、高可用、易伸缩、可扩展、安全。这些大公司的解决方案，被更多网站重复使用，形成了大型网站的架构模式。主要通过以下几种方式来实现：<br><a id="more"></a></p><h3 id="1、分层"><a href="#1、分层" class="headerlink" title="1、分层"></a>1、分层</h3><p>&nbsp;<strong>分层是最常见的一种架构模式，将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统。</strong> 网络的七层通信协议也是一种分层结构。<br>&nbsp;通过分层，可以将一个庞大的系统切分成多个不同的部分，便于分工合作开发和维护；各层之间具有一定的独立性，只要维持调用接口不变，各层可以根据具体的问题独立演化发展而不需要其他层必须作出相应的调整。  </p><h3 id="2、分割"><a href="#2、分割" class="headerlink" title="2、分割"></a>2、分割</h3><p>&nbsp;<strong>分层是横向的切分，而分割是在纵向进行切分。网站越大，其功能越复杂，服务和数据处理的种类也越多，通过分割，将这些不同的服务和功能切分开来，不仅有利于软件的开发和维护，也便于不同模块的分布式部署，来提高网站的并发处理能力和功能扩展能力。</strong><br>&nbsp;比如购物业务，可分割成机票酒店业务、3C业务、小商品业务等更小的粒度。在这个粒度上，还可以继续分割成首页、搜索列表、商品详情等模块，这些模式不管是物理上还是逻辑上都可以是独立的。  </p><h3 id="3、分布式"><a href="#3、分布式" class="headerlink" title="3、分布式"></a>3、分布式</h3><p>&nbsp;<strong>分层和分割可以更好的便于分布式部署，将不同模块部署在不同的服务器上，通过远程调用协同工作。</strong> 分布式意味着可以使用更多的计算机完成同样的功能，计算机越多，CPU、内存、存储资源也越多，能够处理的并发访问和数据量就越大，可以为更多的用户服务。  </p><h3 id="4、集群"><a href="#4、集群" class="headerlink" title="4、集群"></a>4、集群</h3><p>&nbsp;使用分布式将分层和分割后的模块进行独立部署，但是<strong>对于用户访问集中的模块（比如首页），还需要将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务</strong> 。当某台服务器发生故障时，负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用。  </p><h3 id="5、缓存"><a href="#5、缓存" class="headerlink" title="5、缓存"></a>5、缓存</h3><p>&nbsp;<strong>缓存就是将数据存放在距离计算最近的位置以加快处理速度</strong>，是改善软件性能的第一手段。<br><strong>CDN：</strong> 即内容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商哪里，在这里缓存网站的一些静态资源，可以就近以最快速度返回给用户，如将用户访问量很大的热点内容缓存在CDN。<br><strong>反向代理：</strong> 反向代理部署在网站的前端，当用户请求到达网站的数据中心时，最先访问的就是反向代理服务器，这里缓存网站的静态资源，无需将请求转发给应用服务器就可以返回给用户。<br><strong>本地缓存：</strong> 在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而不需要访问数据库。<br><strong>分布式缓存：</strong> 单机无法承受大量的缓存，需要将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。<br>使用缓存的两个前提：一个是数据访问热点不均衡，某些数据会被更频繁的访问，将这部分数据进行缓存；还有一个是数据在某个时间段内是有效的，不会很快过期，否则会产生脏读，影响结果的正确性。  </p><h3 id="6、异步"><a href="#6、异步" class="headerlink" title="6、异步"></a>6、异步</h3><p>&nbsp;<strong>异步架构是典型的生产者-消费者模式，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理，两者不存在直接调用，彼此功能可以随意变化而互不影响。</strong> 异步还有其他几点优势：<br><strong>1.提供系统可用性：</strong> 消费者服务器发生故障，数据会在消息队列器中存储的堆积，生产者服务器可以继续处理业务请求，等消费者服务器恢复后可以继续从队列中取数据进行处理。<br><strong>2.加快网站的响应速度：</strong> 处在业务前端的生产者服务器在处理完业务请求后，将数据写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟小。<br><strong>3.消除并发访问高峰：</strong> 使用消息队列将突然增加的访问请求数据放入消息队列，等待消费者服务器依次处理，就不会对整个网站负载造成太大压力。  </p><h3 id="7、冗余"><a href="#7、冗余" class="headerlink" title="7、冗余"></a>7、冗余</h3><p>&nbsp;网站需要24小时的运行，但是服务器可能随时都会出现故障，<strong>要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样在某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。</strong> 数据库除了要定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份。为抵御自然灾害，还需要对整个数据中心进行备份，全球范围内部署灾备数据中心，网站程序和数据实时同步到多个灾备数据中心。  </p><h3 id="8、自动化"><a href="#8、自动化" class="headerlink" title="8、自动化"></a>8、自动化</h3><p>&nbsp;通过减少认为的干预，使发布过程自动化可以有效减少故障。自动化的代码管理，自动化的测试，自动化的安全检测，及最后自动化的部署。此外，还需要，对生产环境进行自动化监控，出现异常、超出预设阈值，会自动化报警，故障发生时自动化的失效转移，故障消除时自动化的失效恢复等等等。  </p><h3 id="9、安全"><a href="#9、安全" class="headerlink" title="9、安全"></a>9、安全</h3><p>&nbsp;通过密码和手机验证码进行身份认证；登录交易等操作对网络通信进行加密；为防止机器人程序滥用网络资源攻击网站，使用验证码进行识别；对于常用的攻击网络的XSS攻击，SQL注入进行编码转换等处理；对垃圾信息、敏感信息进行过滤；对交易转账等重要操作根据交易模式和交易信息进行风险控制。  </p>]]></content>
      
      <categories>
          
          <category> 大型网站技术架构核心原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大型网站技术架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存溢出与内存泄漏</title>
      <link href="/2017/12/08/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2017/12/08/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、为什么要了解内存泄露和内存溢出？"><a href="#一、为什么要了解内存泄露和内存溢出？" class="headerlink" title="一、为什么要了解内存泄露和内存溢出？"></a>一、为什么要了解内存泄露和内存溢出？</h2><p>1、内存泄露一般是代码设计存在缺陷导致的，通过了解内存泄露的场景，可以避免不必要的内存溢出和提高自己的代码编写水平；<br>2、通过了解内存溢出的几种常见情况，可以在出现内存溢出的时候快速的定位问题的位置，缩短解决故障的时间。<br><a id="more"></a></p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p><strong>内存泄露</strong>：无用对象持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄漏。<br><strong>内存溢出</strong>：指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段（老年代）或Perm段（永久代）垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br>从定义上可以看出内存泄露是内存溢出的一种诱因，不是唯一因素。  </p><h2 id="三、Java中主要的内存泄漏场景"><a href="#三、Java中主要的内存泄漏场景" class="headerlink" title="三、Java中主要的内存泄漏场景"></a>三、Java中主要的内存泄漏场景</h2><ul><li><p>静态集合类，容器中的对象在程序结束之前都不会释放。这些静态变量的生命周期和应用程序一致，他们所引用的对象Object也不能被释放，因为他们也将一直被Vector引用。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Vector v = <span class="keyword">new</span> Vector();</div><div class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)&#123;</div><div class="line">    <span class="keyword">Object</span> o = <span class="keyword">new</span> <span class="keyword">Object</span>();</div><div class="line">    v.<span class="built_in">add</span>(o);</div><div class="line">    o = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>修改hashset中对象的参数值，且参数是计算哈希值的字段。<br>  当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段，否则对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中删除当前对象，造成内存泄露。</p></li><li>数据库连接、网络连接、IO连接，不再使用时需要close方法释放</li><li>监听器，用到的监听器在释放的时候没有去删除，从而增加了内存泄漏的可能性</li><li>变量不合理的作用域，成员变量在使用后依然存在（结局：将变量设为局部变量）</li><li>单例造成内存泄漏，单例对象在初始化后将在JVM的整个生命周期内存在，如果外部对象（生命周期比较短）持有该引用，那么该外部对象就不能被回收，从而导致内存泄漏</li></ul><h2 id="四、内存溢出的几种情况："><a href="#四、内存溢出的几种情况：" class="headerlink" title="四、内存溢出的几种情况："></a>四、内存溢出的几种情况：</h2><h3 id="1、堆内存溢出（outOfMemoryError：java-heap-space）"><a href="#1、堆内存溢出（outOfMemoryError：java-heap-space）" class="headerlink" title="1、堆内存溢出（outOfMemoryError：java heap space）"></a>1、堆内存溢出（outOfMemoryError：java heap space）</h3><p>&nbsp;&nbsp;分为两种情况：一种是堆内存确实不够，还有一种是由于内存的泄漏而造成的内存溢出。<br>&nbsp;&nbsp;在jvm规范中，堆中的内存是用来生成对象实例和数组的。我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，当对象数量达到最大堆容量限制后产生内存溢出异常。    如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个eden区和两个survivor区。<br><img src="http://osrmzp0jr.bkt.clouddn.com/20141107224401036.png" alt="image"><br>当生成新对象时，内存的申请过程如下：<br>a、jvm先尝试在eden区分配新建对象所需的内存；<br>b、如果内存大小足够，申请结束，否则下一步；<br>c、jvm启动Minor GC，试图将eden区中不活跃的对象释放掉，释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区；如果整个新生代都放不下对象时，可以直接在老年代分配内存；<br>d、Survivor区被用来作为Eden及old的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区；<br>e、当OLD区空间不够时，JVM会在OLD区进行full GC；<br>f、full GC后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class MemoryLeak &#123;</div><div class="line">   </div><div class="line">    <span class="keyword">private</span> <span class="keyword">String</span>[] s = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">1000</span>];</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        Map&lt;<span class="keyword">String</span>,<span class="keyword">Object</span>&gt; m =<span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>,<span class="keyword">Object</span>&gt;();</div><div class="line">        <span class="built_in">int</span> i =<span class="number">0</span>;</div><div class="line">        <span class="built_in">int</span> j=<span class="number">10000</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">for</span>(;i&lt;j;i++)&#123;</div><div class="line">                MemoryLeak memoryLeak = <span class="keyword">new</span> MemoryLeak();</div><div class="line">                m.put(<span class="keyword">String</span>.valueOf(i), memoryLeak);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>&nbsp;&nbsp;出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。<br>&nbsp;&nbsp;如果是内存泄漏，可进一步通过工具（如Jrockit等工具）查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。<br>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p><h3 id="2、方法区内存溢出（outOfMemoryError：permgem-space）"><a href="#2、方法区内存溢出（outOfMemoryError：permgem-space）" class="headerlink" title="2、方法区内存溢出（outOfMemoryError：permgem space）"></a>2、方法区内存溢出（outOfMemoryError：permgem space）</h3><p>在jvm规范中，方法区主要存放的是类相关信息（如类名、访问修饰符、常量池、字段描述、方法描述等），静态变量，常量，即时编译器编译后的代码等。<br>所以<strong>如果程序加载的类过多，或者使用反射、gclib等这种动态代理生成类的技术，就可能导致该区发生内存溢出。</strong>  在经常动态生成大量Class的应用中，要注意这点。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jvm参数：-XX:<span class="attribute">PermSize</span>=2m -XX:<span class="attribute">MaxPermSize</span>=2m</div><div class="line">将方法区的大小设置很低即可，在启动加载类库时就会出现内存不足的情况</div></pre></td></tr></table></figure></p><h3 id="3、线程栈溢出（java-lang-StackOverflowError）"><a href="#3、线程栈溢出（java-lang-StackOverflowError）" class="headerlink" title="3、线程栈溢出（java.lang.StackOverflowError）"></a>3、线程栈溢出（java.lang.StackOverflowError）</h3><p>线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。<br><strong>一般线程栈溢出是由于递归太深或方法调用层级过多导致的。</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StackOverflowTest</span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</div><div class="line">    digui(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">digui</span>(<span class="params"><span class="keyword">int</span> i</span>)</span>&#123;</div><div class="line">    System.<span class="keyword">out</span>.println(i++);</div><div class="line">    String[] s = <span class="keyword">new</span> String[<span class="number">50</span>];</div><div class="line">    digui(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议："><a href="#五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议：" class="headerlink" title="五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议："></a>五、为了避免内存泄露，在编写代码的过程中可以参考下面的建议：</h2><p>1、尽早释放无用对象的引用<br>2、使用字符串处理，避免使用String，应大量使用StringBuffer，每一个String对象都得独立占用内存一块区域<br>3、尽量少用静态变量，因为静态变量存放在永久代（方法区），永久代基本不参与垃圾回收<br>4、避免在循环中创建对象<br>5、开启大型文件或从数据库一次拿了太多的数据很容易造成内存溢出，所以在这些地方要大概计算一下数据量的最大值是多少，并且设定所需最小及最大的内存空间值。  </p>]]></content>
      
      <categories>
          
          <category> 深入理解Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何保证线程的顺序执行？</title>
      <link href="/2017/12/05/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F/"/>
      <url>/2017/12/05/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;有T1，T2，T3三个线程，如何保证T1执行完再执行T2，T2执行完再执行T3？这个问题是面试的常考问题，涉及到了一些java并发知识的实际应用。主要有下面三种方法，依次讲解下：  </p><h2 id="1、使用join关键字实现"><a href="#1、使用join关键字实现" class="headerlink" title="1、使用join关键字实现"></a>1、使用join关键字实现</h2><p>join关键字用于让当前线程等待join线程执行完毕后再执行，否则会处于等待阻塞状态。有两种方法：<br>方法一：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="keyword">Task</span> <span class="keyword">implements</span> Runnable&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">Task</span>(<span class="keyword">int</span> taskId)&#123;</div><div class="line">        <span class="keyword">this</span>.taskId = taskId; </div><div class="line">    &#125;    </div><div class="line">    </div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</div><div class="line">        System.out.<span class="keyword">println</span>(<span class="string">"线程"</span>+taskId+<span class="string">"运行！"</span>)；</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> method1() <span class="keyword">throws</span> InterruptedException&#123;</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">1</span>));</div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">2</span>));</div><div class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">3</span>));</div><div class="line">    </div><div class="line">    t1.start();</div><div class="line">    t1.<span class="keyword">join</span>();<span class="comment">//阻塞主线程，直到线程1执行完</span></div><div class="line">    t2.start();</div><div class="line">    t2.<span class="keyword">join</span>();<span class="comment">//阻塞主线程，直到线程2执行完</span></div><div class="line">    t3.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)&#123;</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">"线程1运行！"</span>)；</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                t1.<span class="keyword">join</span>();</div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"线程2运行！"</span>);</div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        @<span class="function">Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                t2.<span class="keyword">join</span>();</div><div class="line">                System.<span class="keyword">out</span>.println(<span class="string">"线程3运行！"</span>);</div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    t1.start();</div><div class="line">    t2.start();</div><div class="line">    t3.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="2、使用队列"><a href="#2、使用队列" class="headerlink" title="2、使用队列"></a>2、使用队列</h2><p>把线程依次加入到队列里，按顺序执行即可。newSingleThreadExecutor是一个只有一个消费线程的线程池，这个消费线程会按队列FIFO的顺序去任务队列里取任务，只要保证三个线程按顺序放入就可以了。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="keyword">Task</span> <span class="keyword">implements</span> Runnable&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskId;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">Task</span>(<span class="keyword">int</span> taskId)&#123;</div><div class="line">        <span class="keyword">this</span>.taskId = taskId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</div><div class="line">        System.out.<span class="keyword">println</span>(<span class="string">"线程"</span>+taskId+<span class="string">"执行！"</span>)；</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> method3()&#123;</div><div class="line">    ExecutorService threadPool = Executors.newSingleThreadExecutor();</div><div class="line">    threadPool.execute(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">1</span>));</div><div class="line">    threadPool.execute(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">2</span>));</div><div class="line">    threadPool.execute(<span class="keyword">new</span> <span class="keyword">Task</span>(<span class="number">3</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="3、使用CountDownLatch关键字实现"><a href="#3、使用CountDownLatch关键字实现" class="headerlink" title="3、使用CountDownLatch关键字实现"></a>3、使用CountDownLatch关键字实现</h2><p>执行它的latch.await()方法，如果计数器不为0，那么当前线程就会被阻塞；每完成一个任务，就执行latch.countDown()，计数器减一，当计数器为0时，阻塞的线程恢复执行状态。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">final</span> CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    <span class="keyword">final</span> CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    </div><div class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"线程1执行！"</span>);</div><div class="line">            lacth1.countDown();<span class="comment">//执行完任务后，计数器减一</span></div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">    </div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                latch1.await();<span class="comment">//直到t1中countDown后计数器为0时，t2才继续执行</span></div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程2执行！"</span>);</div><div class="line">            lacth2.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">    </div><div class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                latch2.await();<span class="comment">//直到t2中countDown后计数器为0时，t3才继续执行</span></div><div class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"线程3执行！"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2017/12/01/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/12/01/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;前面讲的工厂方法模式，存在一个问题：类的创建依赖于工厂类，也就是说，如果需要扩展程序，必须对工厂类进行修改。这时候我们使用抽象工厂类，就可以解决这个问题。创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了。<br><img src="http://osrmzp0jr.bkt.clouddn.com/factory3.png" alt="image"><br>Sender接口：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Sender&#123;</div><div class="line">    public void Send();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>两个实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"this is mailSender!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"this is smsSender!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>两个工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSmsFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>提供一个接口：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Provider&#123;</div><div class="line">    public Sender produce();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Provider provider = <span class="keyword">new</span> SendMailFactory();</div><div class="line">        MailSender mailSender = provider.produce();</div><div class="line">        mailSender.Send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;这时如果想要增加一个功能：发及时信息，那么只需要做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就不用过去改动现有的代码。这么做的话，扩展性会更好！  </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2017/12/01/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/12/01/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="一、普通工厂模式"><a href="#一、普通工厂模式" class="headerlink" title="一、普通工厂模式"></a>一、普通工厂模式</h1><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。关系图如下：<br><img src="http://osrmzp0jr.bkt.clouddn.com/factory1.png" alt="image"><br>举例如下：发送邮件和发送短信的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两者的共同接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"this is mailSender!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"this is smsSender!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//建工厂类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="string">"mail"</span>.equals(type))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"sms"</span>.equals(type))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            System.out.println(<span class="string">"请输入正确的类型！"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();</div><div class="line">        Sender sender = factory.produce(<span class="string">"mail"</span>);</div><div class="line">        sender.Send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="二、多个工厂方法模式"><a href="#二、多个工厂方法模式" class="headerlink" title="二、多个工厂方法模式"></a>二、多个工厂方法模式</h1><p>是对普通工厂方法模式的改进，在普通方法的模式中，如果传递的字符串出错，就不能正确的创建对象。而多个工厂方法模式，提供多个工厂方法，分别创建对象。<br><img src="http://osrmzp0jr.bkt.clouddn.com/factory2.png" alt="image"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只需工厂方法进行修改</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span>&#123;</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();</div><div class="line">        Sender sender = factory.produceMail();</div><div class="line">        sender.Send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="三、静态工厂方法模式"><a href="#三、静态工厂方法模式" class="headerlink" title="三、静态工厂方法模式"></a>三、静态工厂方法模式</h1><p>将上面多个工厂方法的模式里的方法设置为静态的，不需要创建实例，直接调用即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Sender sender = SendFactory.produceMail();</div><div class="line">        sender.Send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>如果出现了大量的产品需要创建，并且有共同的接口时，可以通过工厂方法模式来进行创建。第一种如果传入的字符串有错误，不能正确创建对象；第三种相较于第二种，不需要实例化工厂类。大多数情况下，静态工厂方法模式使用较多。</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单例模式</title>
      <link href="/2017/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/12/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式是一套被反复使用、多数人知晓的、代码设计经验的总结。<br>目的：为了可重用代码、让代码更容易被他人理解、保证代码的可靠性。  </p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>保证整个应用中某个实例有且只有一个。  </p><h2 id="应用场合"><a href="#应用场合" class="headerlink" title="应用场合"></a>应用场合</h2><p>有些对象我们只需要一个，比如<strong>配置文件、工具类、线程池、缓存、日志对象</strong>等。如果创造出多个实例，就会导致许多问题，比如占用过多资源，不一致的结果等。  </p><h2 id="一、饿汉模式"><a href="#一、饿汉模式" class="headerlink" title="一、饿汉模式"></a>一、饿汉模式</h2><p>第一步：将构造方法私有化，不允许外部直接创建对象<br>第二步：创建类的唯一实例，使用private static修饰，private保证不让外部类直接访问，static保证在第一次加载类的时候就创建了类的唯一实例。<br>第三步：提供一个用于获取实例的方法，使用public static修饰，static保证外部可以用类来调用该方法。<br><strong>所谓饿汉，主要体现在第二步，在加载类的时候就创建了类的唯一实例，而不管你是否会使用到，用空间来换取时间。</strong><br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public calss Singleton&#123;</div><div class="line"></div><div class="line">    //1.将构造方法私有化，不允许外部直接创建对象</div><div class="line">   <span class="keyword"> private</span> Singleton()&#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    //2.创建类的唯一实例，使用private<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton<span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</div><div class="line">    </div><div class="line">    //3.提供一个用于获取实例的方法，使用public<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance()&#123;</div><div class="line">       <span class="built_in"> return </span>instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="二、懒汉模式"><a href="#二、懒汉模式" class="headerlink" title="二、懒汉模式"></a>二、懒汉模式</h2><p><strong>懒汉主要体现在只有在需要获取实例时，才去创建。判断实例是否为空，为空则创建唯一实例。用时间来换取空间。</strong><br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">private class Singleton&#123;</div><div class="line">    //1.将构造方法私有化，不允许外部直接创建对象</div><div class="line">   <span class="keyword"> private</span> Singleton()&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //2.声明类的实例变量，使用private<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> Singleton instance;</div><div class="line">    </div><div class="line">    //3.提供一个用于获取实例的方法，使用public<span class="keyword"> static</span>修饰</div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance()&#123;</div><div class="line">        if(instance==null)&#123;</div><div class="line">           <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> return </span>instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>饿汉模式的特点是加载类时比较慢，因为需要创建类的实例，但运行时获取对象的速度比较快，是线程安全的。<br>懒汉模式的特点是加载类时比较快，因为不需要在加载时创建类的实例，但运行时获取对象的速度比较慢，是线程不安全的。  </p><h2 id="三、懒汉模式的优化"><a href="#三、懒汉模式的优化" class="headerlink" title="三、懒汉模式的优化"></a>三、懒汉模式的优化</h2><p>懒汉模式是线程不安全的，首先我们想到的是在getInstace()方法上加上synchronized关键字，如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static synchronized Singleton getInstance()&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="attribute">instance</span>==null)&#123;</div><div class="line">           <span class="built_in"> instance </span>= new Singleton();</div><div class="line">        &#125;</div><div class="line">        return<span class="built_in"> instance;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>这样的做法，会让性能下降，原因是每次调用getInstance()，都需要拿到对象上锁，事实上我们只需要在第一次创建对象的时候加锁，之后就不需要了。进行下面的优化，使用双重判断：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static Singleton getInstance()&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="attribute">instance</span>==null)&#123;</div><div class="line">            synchronized(instance)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="attribute">instance</span>==null)&#123;</div><div class="line">               <span class="built_in"> instance </span>= new Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return<span class="built_in"> instance;</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>其实这样问题没有完全解决，instance = new Singleton()，这一句其实包含三个步骤：<br>1.在内存中为实例分配空间<br>2.进行Singleton的初始化动作<br>3.将实例的内存地址赋给instance变量<br>但这三步的顺序是不能保证的，可能在给Singleton分配完空间后就进行了赋值操作，使得没有进行初始化。这时候使用实例时，就会出现问题。  </p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><h4 id="第一种方法："><a href="#第一种方法：" class="headerlink" title="第一种方法："></a>第一种方法：</h4><p>单例模式可以使用内部类来维护它的实现，jvm内部的机制可以保证一个类被加载时候是线程互斥的，当我们第一次调用getInstance方法时，可以保证Instance只被创建一次，并且保证instance初始化完毕，就不用担心上面的问题。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></div><div class="line"></div><div class="line">    <span class="comment">//私有构造方法，防止被实例化</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//使用内部类来维护单例</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span>&#123;</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    <span class="comment">//获取实例</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonFactory.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="第二种方法（推荐）"><a href="#第二种方法（推荐）" class="headerlink" title="第二种方法（推荐）"></a>第二种方法（推荐）</h4><p>将instance变量用volatile关键字修饰，这样做的目的是禁止指令重排序，就不会出现Singleton没有被正常初始化的问题。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class Singleton&#123;</div><div class="line"></div><div class="line">    //私有构造方法</div><div class="line">   <span class="keyword"> private</span> Singleton()&#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //volatile修饰instance变量</div><div class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile Singleton<span class="built_in"> instance </span>= null;</div><div class="line">    </div><div class="line">    //获取实例</div><div class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance()&#123;</div><div class="line">        if(instance == null)&#123;</div><div class="line">            synchronized(instance)&#123;</div><div class="line">                if(instance == null)&#123;</div><div class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">       <span class="built_in"> return </span>instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap的四种遍历方式</title>
      <link href="/2017/12/01/HashMap%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/12/01/HashMap%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="一、Map的四种遍历方式"><a href="#一、Map的四种遍历方式" class="headerlink" title="一、Map的四种遍历方式"></a>一、Map的四种遍历方式</h1><h2 id="1、foreach-map-entrySet"><a href="#1、foreach-map-entrySet" class="headerlink" title="1、foreach map.entrySet()"></a>1、foreach map.entrySet()</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;();</div><div class="line"><span class="built_in">for</span>(Entry&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; entry : <span class="built_in">map</span>.entrySet())&#123;</div><div class="line">    entry.<span class="built_in">getKey</span>();</div><div class="line">    entry.getValue();</div><div class="line">    </div><div class="line">    <span class="comment">//在遍历过程中删除元素，会抛出异常java.util.ConcurrentModificationException</span></div><div class="line">    <span class="comment">//entry.remove(entry.getKey());</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2、调用map-entrySet-的集合迭代器"><a href="#2、调用map-entrySet-的集合迭代器" class="headerlink" title="2、调用map.entrySet()的集合迭代器"></a>2、调用map.entrySet()的集合迭代器</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Iterator&lt;Map.Entry&lt;String,String&gt;&gt; </span><span class="keyword">it </span>= <span class="meta">map</span>.entrySet().<span class="keyword">iterator();</span></div><div class="line"><span class="symbol">while</span>(<span class="keyword">it.hasNext())&#123;</span></div><div class="line">    <span class="meta">Map</span>.Entry&lt;<span class="keyword">String,String&gt; </span><span class="meta">entry</span> = <span class="keyword">it.next();</span></div><div class="line">    <span class="meta">entry</span>.getKey()<span class="comment">;</span></div><div class="line">    <span class="meta">entry</span>.getValue()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3、foreach-map-keySet"><a href="#3、foreach-map-keySet" class="headerlink" title="3、foreach map.keySet()"></a>3、foreach map.keySet()</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">key</span> : <span class="built_in">map</span>.keySet())&#123;</div><div class="line">    <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="built_in">key</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4、foreach-map-entrySet-，用临时变量保存map-entrySet"><a href="#4、foreach-map-entrySet-，用临时变量保存map-entrySet" class="headerlink" title="4、foreach map.entrySet()，用临时变量保存map.entrySet()"></a>4、foreach map.entrySet()，用临时变量保存map.entrySet()</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Set</span>&lt;<span class="meta">Entry</span>&lt;<span class="keyword">String,String&gt;&gt; </span>entrySet = <span class="meta">map</span>.entrySet()<span class="comment">;</span></div><div class="line"><span class="symbol">for</span>(<span class="meta">Entry</span>&lt;<span class="keyword">String,String&gt; </span><span class="meta">entry</span> : entrySet())&#123;</div><div class="line">    <span class="meta">entry</span>.getKey()<span class="comment">;</span></div><div class="line">    <span class="meta">entry</span>.getValue()<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="二、结论"><a href="#二、结论" class="headerlink" title="二、结论"></a>二、结论</h1><p>1、在foreach map.entrySet()这种遍历方法的遍历过程中，不能删除元素，由于在遍历HashMap中删除了当前元素，下一个待访问的元素的指针也丢失了，所以会抛出java.util.ConcurrentModificationException。<br>2、如果需要在遍历过程中进行删除元素，可以使用调用map.entrySet()的集合迭代器来进行遍历。<br>3、如果只需要遍历key而不需要value的话，可以使用foreach map.keySet()的方式进行遍历。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java三大特性之多态性</title>
      <link href="/2017/12/01/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E6%80%81/"/>
      <url>/2017/12/01/Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<h1 id="一、多态的定义"><a href="#一、多态的定义" class="headerlink" title="一、多态的定义"></a>一、多态的定义</h1><p>&nbsp;&nbsp;多态就是指：程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法到底是哪个类中实现的方法，必须由程序运行期间才能决定。这样，不需要修改源程序，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序选择多个运行状态，这就是多态性。  </p><h1 id="二、多态的实现条件"><a href="#二、多态的实现条件" class="headerlink" title="二、多态的实现条件"></a>二、多态的实现条件</h1><p>Java实现多态有三个必要条件：<strong>继承、重写、向上转型</strong>。<br>继承：在多台中必须存在有继承关系的子类和父类。<br>重写：子类对父类中的某些方法进行重新定义，在调用这些方法时就会调用子类的方法。<br>向上转型：在多态中需要把父类型的引用变量指向子类对象。<br>&nbsp;&nbsp;多态的实现机制遵循一个原则：当父类对象的引用变量指向子类对象时，子类对象的类型决定了调用的是谁的方法，但是这个被调用的方法必须是在父类中定义过的，也就是说被子类覆盖的方法。  </p><h1 id="三、经典实例"><a href="#三、经典实例" class="headerlink" title="三、经典实例"></a>三、经典实例</h1><p>&nbsp;&nbsp;<strong>原则：当父类对象的引用变量指向子类对象时，子类对象的类型决定了调用的是谁的方法，但是这个被调用的方法必须是在父类中定义过的，也就是说被子类覆盖的方法。如果不符合前面的条件，它仍然需要根据继承链中方法调用的优先级来确认方法，优先级为：</strong><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这类this指的是引用变量的类型</span></div><div class="line"><span class="keyword">this</span>.show(o)---&gt;<span class="keyword">super</span>.show(o)---&gt;<span class="keyword">this</span>.show((<span class="keyword">super</span>)o)---&gt;<span class="keyword">super</span>.show((<span class="keyword">super</span>)o)</div></pre></td></tr></table></figure></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    public <span class="type">String</span> show(<span class="type">D</span> obj) &#123;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"A and D"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public <span class="type">String</span> show(<span class="type">A</span> obj) &#123;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"A and A"</span>);</div><div class="line">    &#125; </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</div><div class="line">    public <span class="type">String</span> show(<span class="type">B</span> obj)&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"B and B"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public <span class="type">String</span> show(<span class="type">A</span> obj)&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"B and A"</span>);</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    public static void main(<span class="type">String</span>[] args) &#123;</div><div class="line">        <span class="type">A</span> a1 = <span class="keyword">new</span> <span class="type">A</span>();</div><div class="line">        <span class="type">A</span> a2 = <span class="keyword">new</span> <span class="type">B</span>();</div><div class="line">        <span class="type">B</span> b = <span class="keyword">new</span> <span class="type">B</span>();</div><div class="line">        <span class="type">C</span> c = <span class="keyword">new</span> <span class="type">C</span>();</div><div class="line">        <span class="type">D</span> d = <span class="keyword">new</span> <span class="type">D</span>();</div><div class="line">        </div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"1--"</span> + a1.show(b));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"2--"</span> + a1.show(c));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"3--"</span> + a1.show(d));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"4--"</span> + a2.show(b));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"5--"</span> + a2.show(c));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"6--"</span> + a2.show(d));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"7--"</span> + b.show(b));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"8--"</span> + b.show(c));</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"9--"</span> + b.show(d));      </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//运行结果</span></div><div class="line"><span class="number">1</span>--<span class="type">A</span> and <span class="type">A</span></div><div class="line"><span class="number">2</span>--<span class="type">A</span> and <span class="type">A</span></div><div class="line"><span class="number">3</span>--<span class="type">A</span> and <span class="type">D</span></div><div class="line"><span class="number">4</span>--<span class="type">B</span> and <span class="type">A</span></div><div class="line"><span class="number">5</span>--<span class="type">B</span> and <span class="type">A</span></div><div class="line"><span class="number">6</span>--<span class="type">A</span> and <span class="type">D</span></div><div class="line"><span class="number">7</span>--<span class="type">B</span> and <span class="type">B</span></div><div class="line"><span class="number">8</span>--<span class="type">B</span> and <span class="type">B</span></div><div class="line"><span class="number">9</span>--<span class="type">A</span> and <span class="type">D</span></div></pre></td></tr></table></figure><p>&nbsp;&nbsp;比如分析4，a2.show(b)，按照上面原则的意思，是由B来决定调用谁的方法，所有a2.show(b)应该要调用B中的show(B obj)，产生的结果应该是“B and B”，但是这样是错误的，因为我们忽略了后面那句话：被调用的方法必须要在父类中定义过的，不符合要求，不能直接这么做！所以仍然要按照继承链的调用方法的优先级来确认。由于this(A)没有父类，跳到第三级this((super)o)，找到了A中的show(A obj)方法，同时由于B重写了该方法，所以最终会调用B类中的show(A obj)方法，最后输出“B and A”。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO多路复用select、poll、epoll的区别与使用</title>
      <link href="/2017/10/27/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/10/27/Linux%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="I-O复用简述"><a href="#I-O复用简述" class="headerlink" title="I/O复用简述"></a>I/O复用简述</h2><p>&emsp;I/O多路复用技术是为了解决进程或线程阻塞到某个I/O系统调用而出现的技术，使进程不阻塞于某个特定的I/O系统调用。<br>&emsp;select()、poll()、epoll()都是I/O多路复用的机制。<strong>I/O多路复用通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</strong> select()、poll()、epoll()本质上都是同步IO，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说，读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  </p><h2 id="一、select-的使用"><a href="#一、select-的使用" class="headerlink" title="一、select()的使用"></a>一、select()的使用</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int <span class="keyword">select</span>(<span class="built_in">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *<span class="keyword">timeout</span>);</div><div class="line">nfds:要监视的文件描述符的范围，一般取描述符数的最大值+1</div><div class="line">readfds：监视的可读描述符集合，只要有文件描述符即将进行读操作，这个文件描述符就存储到这。</div><div class="line">writefds：监视的可写描述符集合。</div><div class="line">exceptfds：监视的错误异常描述符集合。</div></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>&emsp;监视并等待多个文件描述符的属性变化（可读、可写或错误异常）。select()函数监视的文件描述符分为三类，分别是readfds，writefds，exceptfds。调用select()函数会阻塞，直到有描述符就绪（有数据可读、可写或者有错误异常，或者超时），函数才会返回。当select()函数返回后，可以通过遍历fdset来找到就绪的描述符。</p><h3 id="select-的优缺点"><a href="#select-的优缺点" class="headerlink" title="select()的优缺点"></a>select()的优缺点</h3><p><strong>优点：</strong> 几乎在所有平台是都支持，具有良好的跨平台支持。<br><strong>缺点：</strong><br>1、每次调用select()，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；同时每次调用select()，都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。<br>2、单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。  </p><h2 id="二、poll-的使用"><a href="#二、poll-的使用" class="headerlink" title="二、poll()的使用"></a>二、poll()的使用</h2><p>select()和poll()系统调用的本质一样，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll()没有最大文件描述符数量的限制（但数量过大后性能也会下降）。poll()和select()同样存在一个缺点是，包含大量文件描述符的集合被整体复制于用户态和内核态之间，而不论这些文件描述符是否就绪，随文件描述符数量的增加而线性增大。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span></div></pre></td></tr></table></figure></p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>&emsp;监视并等待多个文件描述符的属性变化。<br>&emsp;poll()的实现和select()非常相似，只是描述fd集合的方式不同，poll()使用pollfd结构而不是select()的fd_set结构，还有就是poll()没有最大文件描述符数量的限制，其他的都差不多。  </p><h2 id="三、epoll-的使用"><a href="#三、epoll-的使用" class="headerlink" title="三、epoll()的使用"></a>三、epoll()的使用</h2><p>epoll()是select()和poll()的增强版本。但epoll更加灵活，没有描述符限制。epoll()使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。<br>epoll操作过程需要三个接口：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span>(<span class="params"><span class="keyword">int</span> size</span>)</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span>(<span class="params"><span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *<span class="keyword">event</span></span>)</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span>(<span class="params"><span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout</span>)</span>;</div></pre></td></tr></table></figure></p><h3 id="1、int-epoll-create-int-size"><a href="#1、int-epoll-create-int-size" class="headerlink" title="1、int epoll_create(int size)"></a>1、int epoll_create(int size)</h3><p><strong>功能：</strong> 该函数生成一个epoll专用的文件描述符（创建一个epoll的句柄）。在创建好epoll句柄后，它就是会占用一个fd值，在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。  </p><h3 id="2、int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#2、int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="2、int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)"></a>2、int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</h3><p><strong>功能：</strong> epoll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，epoll需要先注册要监听的事件类型。  </p><h3 id="3、int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#3、int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="3、int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)"></a>3、int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</h3><p><strong>功能：</strong> 等待事件的发生，收集在epoll监控的事件中已经发送的事件，类似于select()调用。  </p><p>&emsp;epoll对文件描述符的操作有两种模式：LT模式和ET模式。LT模式是默认模式，区别如下：<br><strong>LT模式：</strong> 当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br><strong>ET模式：</strong> 当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。<br>ET模式很大程度上减少了epoll事件被重复触发的次数，因此效率比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。  </p><p>&emsp;在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll()事件通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。  </p><h3 id="epoll-的优点"><a href="#epoll-的优点" class="headerlink" title="epoll()的优点"></a>epoll()的优点</h3><p>1、监视的描述符数量不受限制，它所支持的fd上限是最大可以打开文件的数目，一般远大于2048。1GB内存机器上大约是10万左右。<br>2、I/O效率不会随着监视fd的数量的增长而下降。select,poll需要不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll也需要调用epoll_wait()不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是epoll在设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait()中睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节约了大量的CPU时间。<br>3、select,poll每次调用都要把fd集合从用户态复制到内核态，而epoll只要拷贝一次，这节省了很大的开销。  </p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux的五种I/O模型</title>
      <link href="/2017/10/27/Linux%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/10/27/Linux%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="linux的五种I-O模型："><a href="#linux的五种I-O模型：" class="headerlink" title="linux的五种I/O模型："></a>linux的五种I/O模型：</h2><p>1、阻塞I/O<br>2、非阻塞I/O<br>3、I/O复用<br>4、信号驱动I/O<br>5、异步I/O<br>前面四种都是同步I/O，只有最后一种是异步I/O。  </p><h3 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h3><p><strong>进程会一直阻塞，直到数据拷贝完成。</strong> 应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好，一直等待… 数据准备好了，从内核空间拷贝到用户空间，IO函数返回成功提示。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E9%98%BB%E5%A1%9EIO.png" alt="image">  </p><h3 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h3><p>通过进程反复调用IO函数（多次系统调用，并马上返回），在数据拷贝的过程中，进程是阻塞的。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E9%9D%9E%E9%98%BB%E5%A1%9Eio.jpg" alt="image">  </p><h3 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h3><p>主要是select和epoll，对一个IO端口，两次调用，两次返回。能实现同时对多个IO端口进行监听。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/io%E5%A4%8D%E7%94%A8.jpg" alt="image">  </p><h3 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h3><p>也是两次调用，两次返回。首先允许套接口进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8io.jpg" alt="image">  </p><h3 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h3><p><strong>数据拷贝的时候进程无需阻塞</strong>。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BC%82%E6%AD%A5io.jpg" alt="image">  </p><h2 id="五种I-O模型的比较"><a href="#五种I-O模型的比较" class="headerlink" title="五种I/O模型的比较"></a>五种I/O模型的比较</h2><p><img src="http://osrmzp0jr.bkt.clouddn.com/io%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83.jpg" alt="image">  </p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AVL树的Java实现</title>
      <link href="/2017/10/23/AVL%E6%A0%91%E7%9A%84java%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/10/23/AVL%E6%A0%91%E7%9A%84java%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>AVL树，也叫二叉平衡树，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。  </p><h1 id="AVL树的Java实现"><a href="#AVL树的Java实现" class="headerlink" title="AVL树的Java实现"></a>AVL树的Java实现</h1><h2 id="1、节点"><a href="#1、节点" class="headerlink" title="1、节点"></a>1、节点</h2><h3 id="1-1节点定义"><a href="#1-1节点定义" class="headerlink" title="1.1节点定义"></a>1.1节点定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AVLTree&lt;T</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;T&gt;&gt;</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="type">AVLTreeNode</span>&lt;<span class="type">T</span> <span class="keyword">extends</span> <span class="type">Comparable</span>&lt;<span class="type">T</span>&gt;&gt;&#123;</div><div class="line">        <span class="type">T</span> key;                 <span class="comment">//键值</span></div><div class="line">        int height;            <span class="comment">//高度</span></div><div class="line">        <span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; left;   <span class="comment">//左孩子</span></div><div class="line">        <span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; right;  <span class="comment">//右孩子</span></div><div class="line">        </div><div class="line">        public <span class="type">AVLTreeNode</span>(<span class="type">T</span> key, <span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; left, <span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; right)&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.left = left;</div><div class="line">            <span class="keyword">this</span>.right = right;</div><div class="line">            <span class="keyword">this</span>.height = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2树的高度"><a href="#1-2树的高度" class="headerlink" title="1.2树的高度"></a>1.2树的高度</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取树的高度</span></div><div class="line"><span class="keyword">private</span> <span class="built_in">int</span> <span class="built_in">height</span>(AVLTreeNode&lt;T&gt; tree)&#123;</div><div class="line">    <span class="keyword">if</span>(tree != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> tree.<span class="built_in">height</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">height</span>()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(mRoot);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3比较大小"><a href="#1-3比较大小" class="headerlink" title="1.3比较大小"></a>1.3比较大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">比较两个值的大小</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> a&gt;b ? a: b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h2><p>如果在AVL树中进行插入或删除节点后，可能导致AVL树失去平衡。这种失去平衡可以概括为4种姿势：LL（左左），LR（左右），RR（右右），RL（右左）。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E6%97%8B%E8%BD%AC1.jpg" alt="image">  </p><h3 id="2-1-LL的旋转"><a href="#2-1-LL的旋转" class="headerlink" title="2.1 LL的旋转"></a>2.1 LL的旋转</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/LL.jpg" alt="image">  </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//LL：左左对应的情况</div><div class="line">//返回值：旋转后的根节点</div><div class="line">private AVLTreeNode&lt;T&gt; leftLeftRotation(AVLTreeNode&lt;T&gt; <span class="built_in">k2</span>)&#123;</div><div class="line">    AVLTreeNode&lt;T&gt; <span class="built_in">k1</span><span class="comment">;</span></div><div class="line">    <span class="built_in">k1</span> = <span class="built_in">k2</span>.left<span class="comment">;</span></div><div class="line">    <span class="built_in">k2</span>.left = <span class="built_in">k1</span>.right<span class="comment">;</span></div><div class="line">    <span class="built_in">k1</span>.right = <span class="built_in">k2</span><span class="comment">;</span></div><div class="line">    </div><div class="line">    <span class="built_in">k2</span>.height = max(height(<span class="built_in">k2</span>.left),height(<span class="built_in">k2</span>.right)) + <span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="built_in">k1</span>.height = max(height(<span class="built_in">k1</span>.left),<span class="built_in">k2</span>.height) + <span class="number">1</span><span class="comment">;</span></div><div class="line">    </div><div class="line">    return <span class="built_in">k1</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-2-RR的旋转"><a href="#2-2-RR的旋转" class="headerlink" title="2.2 RR的旋转"></a>2.2 RR的旋转</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/RR.jpg" alt="image">  </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//RR：右右对应的情况</div><div class="line">//返回值：旋转后的根节点</div><div class="line">private AVLTreeNode&lt;T&gt; rightRightRotation(AVLTreeNode&lt;T&gt; <span class="built_in">k1</span>)&#123;</div><div class="line">    AVLTreeNode&lt;T&gt; <span class="built_in">k2</span><span class="comment">;</span></div><div class="line">    <span class="built_in">k2</span> = <span class="built_in">k1</span>.right<span class="comment">;</span></div><div class="line">    <span class="built_in">k1</span>.right = <span class="built_in">k2</span>.left<span class="comment">;</span></div><div class="line">    <span class="built_in">k2</span>.left = <span class="built_in">k1</span><span class="comment">;</span></div><div class="line">    </div><div class="line">    <span class="built_in">k1</span>.height = max(height(<span class="built_in">k1</span>.left),height(<span class="built_in">k1</span>.right)) + <span class="number">1</span><span class="comment">;</span></div><div class="line">    <span class="built_in">k2</span>.height = max(height(<span class="built_in">k2</span>.left),<span class="built_in">k1</span>.height) + <span class="number">1</span><span class="comment">;</span></div><div class="line">    </div><div class="line">    return <span class="built_in">k2</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-3-LR的旋转"><a href="#2-3-LR的旋转" class="headerlink" title="2.3 LR的旋转"></a>2.3 LR的旋转</h3><p>LR失去平衡的情况，需要经过两次旋转才能让AVL树恢复平衡。<br><img src="http://osrmzp0jr.bkt.clouddn.com/LR.jpg" alt="image">  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LR：左右对应的情况</span></div><div class="line"><span class="comment">//返回值：旋转后的根节点</span></div><div class="line"><span class="keyword">private</span> <span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; leftRightRotation(<span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; k3)&#123;</div><div class="line">    k3.<span class="keyword">left</span> = rightRightRotation(k3.<span class="keyword">left</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> leftLeftRotation(k3);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-4-RL的旋转"><a href="#2-4-RL的旋转" class="headerlink" title="2.4 RL的旋转"></a>2.4 RL的旋转</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/RL.jpg" alt="image">  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RL：右左对应的情况</span></div><div class="line"><span class="comment">//返回值：旋转后的根节点</span></div><div class="line"><span class="keyword">private</span> <span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; rightLeftRotation(<span class="type">AVLTreeNode</span>&lt;<span class="type">T</span>&gt; k1)&#123;</div><div class="line">    k1.<span class="keyword">right</span> = leftLeftRotation(k1.<span class="keyword">right</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> rightRightRotation(k1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3、插入"><a href="#3、插入" class="headerlink" title="3、插入"></a>3、插入</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将结点插入到AVL树中，并返回根节点</span></div><div class="line"><span class="keyword">private</span> AVLTreeNode&lt;T&gt; insert(AVLTreeNode&lt;T&gt; tree, T <span class="built_in">key</span>)&#123;<span class="comment">//tree为根节点，key为待插入的值</span></div><div class="line">    <span class="keyword">if</span>(tree == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//新建节点</span></div><div class="line">        tree = <span class="keyword">new</span> AVLTreeNode&lt;T&gt;(<span class="built_in">key</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span>(tree==<span class="keyword">null</span>)&#123;</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"创建节点失败！"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">int</span> cmp = <span class="built_in">key</span>.compareTo(tree.<span class="built_in">key</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//将key插入到Tree的左子树</span></div><div class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</div><div class="line">            tree.left = insert(tree.left, <span class="built_in">key</span>);</div><div class="line">            <span class="comment">//插入节点后，若AVL树失去平衡，做相应的调节</span></div><div class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>(tree.left) - <span class="built_in">height</span>(tree.right) == <span class="number">2</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="built_in">key</span>.compareTo(tree.left.<span class="built_in">key</span>) &lt; <span class="number">0</span>)</div><div class="line">                    tree = leftLeftRotation(tree);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    tree = leftRightRotation(tree);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将key插入到Tree的右子树</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</div><div class="line">            tree.right = insert(tree.right, <span class="built_in">key</span>);</div><div class="line">            <span class="comment">//插入节点后，若AVL树失去平衡，做相应的调节</span></div><div class="line">            <span class="keyword">if</span>(<span class="built_in">height</span>(tree.right) - <span class="built_in">height</span>(tree.left== <span class="number">2</span>)&#123;</div><div class="line">                <span class="keyword">if</span>(<span class="built_in">key</span>.compareTo(tree.left.<span class="built_in">key</span>) &gt; <span class="number">0</span>)</div><div class="line">                    tree = rightRightRotation(tree);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    tree = rightLeftRotation(tree);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"添加节点失败！"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    tree.<span class="built_in">height</span> = <span class="built_in">max</span>(<span class="built_in">height</span>(tree.left), <span class="built_in">height</span>(tree.right)) + <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> tree;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4、删除"><a href="#4、删除" class="headerlink" title="4、删除"></a>4、删除</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">private AVLTreeNode&lt;T&gt; remove(AVLTreeNode&lt;T&gt; <span class="keyword">tree</span>, AVLTreeNode&lt;T&gt; z) &#123;<span class="comment">//tree为根节点，z为待删除节点</span></div><div class="line">    <span class="comment">// 根为空 或者 没有要删除的节点，直接返回null。</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">tree</span>==null || z==null)</div><div class="line">        return null;</div><div class="line"></div><div class="line">    int cmp = z.key.compareTo(<span class="keyword">tree</span>.key);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;        <span class="comment">// 待删除的节点在"tree的左子树"中</span></div><div class="line">        <span class="keyword">tree</span>.left = remove(<span class="keyword">tree</span>.left, z);</div><div class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></div><div class="line">        <span class="keyword">if</span> (height(<span class="keyword">tree</span>.right) - height(<span class="keyword">tree</span>.left) == <span class="number">2</span>) &#123;</div><div class="line">            AVLTreeNode&lt;T&gt; r =  <span class="keyword">tree</span>.right;</div><div class="line">            <span class="keyword">if</span> (height(r.left) &gt; height(r.right))</div><div class="line">                <span class="keyword">tree</span> = rightLeftRotation(<span class="keyword">tree</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">tree</span> = rightRightRotation(<span class="keyword">tree</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;    <span class="comment">// 待删除的节点在"tree的右子树"中</span></div><div class="line">        <span class="keyword">tree</span>.right = remove(<span class="keyword">tree</span>.right, z);</div><div class="line">        <span class="comment">// 删除节点后，若AVL树失去平衡，则进行相应的调节。</span></div><div class="line">        <span class="keyword">if</span> (height(<span class="keyword">tree</span>.left) - height(<span class="keyword">tree</span>.right) == <span class="number">2</span>) &#123;</div><div class="line">            AVLTreeNode&lt;T&gt; l =  <span class="keyword">tree</span>.left;</div><div class="line">            <span class="keyword">if</span> (height(l.right) &gt; height(l.left))</div><div class="line">                <span class="keyword">tree</span> = leftRightRotation(<span class="keyword">tree</span>);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">tree</span> = leftLeftRotation(<span class="keyword">tree</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// tree是对应要删除的节点。</span></div><div class="line">        <span class="comment">// tree的左右孩子都非空</span></div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">tree</span>.left!=null) &amp;&amp; (<span class="keyword">tree</span>.right!=null)) &#123;</div><div class="line">            <span class="keyword">if</span> (height(<span class="keyword">tree</span>.left) &gt; height(<span class="keyword">tree</span>.right)) &#123;</div><div class="line">                <span class="comment">// 如果tree的左子树比右子树高；</span></div><div class="line">                <span class="comment">// 则(01)找出tree的左子树中的最大节点</span></div><div class="line">                <span class="comment">//   (02)将该最大节点的值赋值给tree。</span></div><div class="line">                <span class="comment">//   (03)删除该最大节点。</span></div><div class="line">                <span class="comment">// 这类似于用"tree的左子树中最大节点"做"tree"的替身；</span></div><div class="line">                <span class="comment">// 采用这种方式的好处是：删除"tree的左子树中最大节点"之后，AVL树仍然是平衡的。</span></div><div class="line">                AVLTreeNode&lt;T&gt; max = maximum(<span class="keyword">tree</span>.left);</div><div class="line">                <span class="keyword">tree</span>.key = max.key;</div><div class="line">                <span class="keyword">tree</span>.left = remove(<span class="keyword">tree</span>.left, max);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1)</span></div><div class="line">                <span class="comment">// 则(01)找出tree的右子树中的最小节点</span></div><div class="line">                <span class="comment">//   (02)将该最小节点的值赋值给tree。</span></div><div class="line">                <span class="comment">//   (03)删除该最小节点。</span></div><div class="line">                <span class="comment">// 这类似于用"tree的右子树中最小节点"做"tree"的替身；</span></div><div class="line">                <span class="comment">// 采用这种方式的好处是：删除"tree的右子树中最小节点"之后，AVL树仍然是平衡的。</span></div><div class="line">                AVLTreeNode&lt;T&gt; min = minimum(<span class="keyword">tree</span>.right);</div><div class="line">                <span class="keyword">tree</span>.key = min.key;</div><div class="line">                <span class="keyword">tree</span>.right = remove(<span class="keyword">tree</span>.right, min);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            AVLTreeNode&lt;T&gt; tmp = <span class="keyword">tree</span>;</div><div class="line">            <span class="keyword">tree</span> = (<span class="keyword">tree</span>.left!=null) ? <span class="keyword">tree</span>.left : <span class="keyword">tree</span>.right;</div><div class="line">            tmp = null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return <span class="keyword">tree</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的BIO、NIO、AIO</title>
      <link href="/2017/10/16/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/"/>
      <url>/2017/10/16/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/</url>
      <content type="html"><![CDATA[<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步关注的是消息通信机制。<br>同步：指在发出一个调用时，在没有得到结果之前，该调用就不返回。一旦返回，说明已经得到返回值了。也就是由调用者主动等待这个调用的结果。<br>异步：指在调用发出之后，这个调用就直接返回了，所以没有返回结果。就是说异步过程调用发出后，调用者不会立刻得到结果，而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。  </p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。<br>阻塞：阻塞调用指的是调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。<br>非阻塞：非阻塞调用指的是不能立刻得到结果之前，该调用不会阻塞当前线程。<br>在处理IO的时候，阻塞和非阻塞都是同步IO。除了特殊的API（AIO），为异步IO。  </p><p>对unix来讲：阻塞式IO，非阻塞式IO，IO复用（select/poll/epoll）都属于同步IO，因为它们在数据由内核空间复制回进程缓冲区时都是阻塞的（不能做其他事），分为两阶段：<br>1、数据准备完成<br>2、数据由内核空间复制回进程缓冲区  </p><h2 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h2><p><strong>同步IO</strong>：当用户发出IO请求操作后，如果数据没有就绪，需要通过用户线程或者内核不断去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程。<br><strong>异步IO</strong>：只有IO请求操作的发出是用户线程来执行的，IO操作的两个阶段都是由内核自动完成，不需要不断去轮询，会发送通知告知用户线程IO操作已经完成。不会对用户线程产生阻塞。  </p><h2 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h2><p>阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息上。  </p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>老张爱喝茶，他要煮开水。<br>出场任务：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>1、老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻<br>2、老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开了没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是买了把会响笛的水壶。水开之后，能发出声音提醒水开了。<br>3、老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大<br>4、老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了<br>&emsp;所谓同步异步，只是针对水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。同步只能让调用者去轮询自己，造成老张效率的低下。<br>&emsp;所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和3中老张是阻塞的，虽然3中响水壶是异步的，但对于立等的老张没有太大的意义。所以一般异步都是配合非阻塞使用的，这样才能发挥异步的效用。  </p><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>可分为同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO。<br><strong>同步阻塞IO</strong>：在这种方式下，用户进程在发起一个IO操作后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户线程才能运行。<br><strong>同步非阻塞IO</strong>：这种方式下，用户进程在发起一个IO操作后可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，就要求用户进程不停的去询问，从而引入不惜要的CPU资源浪费。JAVA中NIO就属于同步非阻塞IO。<br><strong>异步阻塞IO</strong>：这种方式下，应用发起一个IO操作后，不等待内核IO操作的完成，等内核完成IO操作后会通知应用程序。<br><strong>异步非阻塞IO</strong>：这种方式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正完成后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取和写入操作已经由内核完成了。  </p><h2 id="JAVA对BIO、NIO、AIO支持"><a href="#JAVA对BIO、NIO、AIO支持" class="headerlink" title="JAVA对BIO、NIO、AIO支持"></a>JAVA对BIO、NIO、AIO支持</h2><p><strong>BIO</strong>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br><strong>NIO</strong>：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br><strong>AIO</strong>：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。  </p><h2 id="JAVA中BIO、NIO、AIO的适用场景"><a href="#JAVA中BIO、NIO、AIO的适用场景" class="headerlink" title="JAVA中BIO、NIO、AIO的适用场景"></a>JAVA中BIO、NIO、AIO的适用场景</h2><p>BIO：适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，jdk1.4前唯一的选择，但程序直观简单易理解。<br>NIO：适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，编程比较复杂，jdk1.4开始支持。<br>AIO：适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk1.7开始支持。  </p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用排序算法总结</title>
      <link href="/2017/10/13/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2017/10/13/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="各比较排序性能比较"><a href="#各比较排序性能比较" class="headerlink" title="各比较排序性能比较"></a>各比较排序性能比较</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD.jpg" alt="image">  </p><h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>1、比较相邻的元素，如果前一个比后一个大，就把他们两个调换位置。<br>2、对每一对相邻的元素作同样的工作，从开始一对到最后一对，完成后，最后的元素会是最大的数。<br>3、针对所有元素重复上面的步骤，除了最后一个元素。<br>4、对剩下越来越少的元素重复上面的步骤。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="image"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------O(n^<span class="number">2</span>)</div><div class="line">最优时间复杂度---------加了isSorted标记，在第一趟运行时，发现无需进行下一趟比较，可把时间复杂度降为O(n)</div><div class="line">平均时间复杂度---------O(n^<span class="number">2</span>)</div><div class="line">所需辅助空间-----------O(<span class="number">1</span>)</div><div class="line">稳定性-----------------稳定</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++)&#123;<span class="comment">//比较趟数</span></div><div class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-<span class="number">1</span>-i; j++)&#123;<span class="comment">//当前趟需要的比较次数</span></div><div class="line">                <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;<span class="comment">//将最大元素浮到数组最后</span></div><div class="line">                    isSorted = <span class="keyword">false</span>;</div><div class="line">                    swap(arr,j,j+<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(isSorted)&#123;<span class="comment">//当前趟比较完后，发现没有元素需要交换位置，表示数组已有序，不必进行下一趟。</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;<span class="comment">//元素交换位置（通用）</span></div><div class="line">        <span class="keyword">int</span> temp=arr[i];</div><div class="line">        arr[i]=arr[j];</div><div class="line">        arr[j]=temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="2、鸡尾酒排序"><a href="#2、鸡尾酒排序" class="headerlink" title="2、鸡尾酒排序"></a>2、鸡尾酒排序</h3><p>也叫定向冒泡排序，是冒泡排序的一种改进。与冒泡排序不同在于先从低到高将最大元素放到后面然后再从高到底将最小元素放到前面。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F.gif" alt="image"><br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------O(<span class="built_in">n</span>^<span class="number">2</span>)</div><div class="line">最优时间复杂度---------如果数组一开始大部分已经排序过的话，接近O(<span class="built_in">n</span>)</div><div class="line">平均时间复杂度---------O(<span class="built_in">n</span>^<span class="number">2</span>)</div><div class="line">所需辅助空间-----------O(<span class="number">1</span>)</div><div class="line">稳定性-----------------稳定</div><div class="line"></div><div class="line">void CocktailSort(<span class="built_in">int</span>[] A, <span class="built_in">int</span> <span class="built_in">n</span>)&#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>;//初始化边界</div><div class="line">    <span class="built_in">int</span> <span class="built_in">right</span>=<span class="built_in">n</span>-<span class="number">1</span>;</div><div class="line">    while(<span class="built_in">left</span> &lt; <span class="built_in">right</span>)&#123;</div><div class="line">    </div><div class="line">        for(<span class="built_in">int</span> i=<span class="built_in">left</span>; i&lt;<span class="built_in">right</span>; i++)&#123;//从左往右，将最大元素放到数组最后</div><div class="line">            <span class="built_in">if</span>(A[i]&gt;A[i+<span class="number">1</span>])</div><div class="line">                swap(A, i, i+<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">right</span>--;</div><div class="line">        </div><div class="line">        for(<span class="built_in">int</span> i=<span class="built_in">right</span>; i&gt;<span class="built_in">left</span>; i--)&#123;//从右往左，将最小元素放到数组最前</div><div class="line">            <span class="built_in">if</span>(A[i]&lt;A[i-<span class="number">1</span>])</div><div class="line">                swap(A, i ,i-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">left</span>++;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="3、选择排序"><a href="#3、选择排序" class="headerlink" title="3、选择排序"></a>3、选择排序</h3><p>选择排序，第一次遍历找到最小（大）元素，放到序列的起始位置，之后每次遍历继续寻找最小（大）元素，放到已排序序列的后面，直到所有元素都排序完毕。<br>选择排序和冒泡排序的区别：冒泡排序一次交换相邻两个顺序不合法的元素位置，从而将最小（大）元素放到合适的位置；而选择排序没遍历一次都记住当前最小（大）元素的位置，最后仅需一次交换操作就可以放到合适的位置。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="image"><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------O(n^<span class="number">2</span>)</div><div class="line">最优时间复杂度---------O(n^<span class="number">2</span>)</div><div class="line">平均时间复杂度---------O(n^<span class="number">2</span>)</div><div class="line">所需辅助空间-----------O(<span class="number">1</span>)</div><div class="line">稳定性-----------------不稳定</div><div class="line"></div><div class="line"><span class="keyword">void</span> SelectionSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)&#123;</div><div class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;<span class="comment">//i为已排序序列的末尾</span></div><div class="line">        <span class="keyword">int</span> <span class="built_in">min</span>=i;</div><div class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;<span class="comment">//未排序序列</span></div><div class="line">            <span class="built_in">if</span>(A[j]&lt;A[<span class="built_in">min</span>])<span class="comment">//找出未排序序列的最小值</span></div><div class="line">                <span class="built_in">min</span>=j;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">if</span>(<span class="built_in">min</span> != i)&#123;</div><div class="line">            swap(A,<span class="built_in">min</span>,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="4、插入排序"><a href="#4、插入排序" class="headerlink" title="4、插入排序"></a>4、插入排序</h3><p>1、从第一个元素开始，该元素可以认定为已被排序<br>2、取出下一个元素，在已排序的序列中从后向前扫描<br>3、如果扫描到的数比新元素大，则将扫描到的数移到下一位置<br>4、重复步骤3，直到找到扫描的数小于等于新元素，则将新元素插到该元素后面<br>5、重复步骤2~4<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F1.gif" alt="image">  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------输入序列是降序排列，O(n^<span class="number">2</span>)</div><div class="line">最优时间复杂度---------输入序列是升序排列，O(n)</div><div class="line">平均时间复杂度---------O(n^<span class="number">2</span>)</div><div class="line">所需辅助空间-----------O(<span class="number">1</span>)</div><div class="line">稳定性-----------------稳定</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span>(<span class="params"><span class="keyword">int</span>[] A, <span class="keyword">int</span> n</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n ;i++)&#123;<span class="comment">//类似抓扑克牌</span></div><div class="line">        <span class="keyword">int</span> <span class="keyword">get</span> = A[i];<span class="comment">//右手抓到的扑克牌</span></div><div class="line">        <span class="keyword">int</span> j=i<span class="number">-1</span>;<span class="comment">//左手上的牌总是排好序的</span></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">get</span>&lt;A[j] &amp;&amp; j&gt;=<span class="number">0</span>)&#123;<span class="comment">//将抓到的牌和手牌从右向左进行比较，若手牌比抓到的牌大，就将其右移 </span></div><div class="line">            A[j+<span class="number">1</span>]=A[j];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        A[j+<span class="number">1</span>]=<span class="keyword">get</span>;<span class="comment">//若手牌比抓到的牌小，就将抓到的牌插到该手牌右边</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="5、插入排序的改进：二分插入排序"><a href="#5、插入排序的改进：二分插入排序" class="headerlink" title="5、插入排序的改进：二分插入排序"></a>5、插入排序的改进：二分插入排序</h3><p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------输入序列是降序排列，O(nlogn)</div><div class="line">最优时间复杂度---------输入序列是升序排列，O(<span class="built_in">n</span>)</div><div class="line">平均时间复杂度---------O(<span class="built_in">n</span>^<span class="number">2</span>)</div><div class="line">所需辅助空间-----------O(<span class="number">1</span>)</div><div class="line">稳定性-----------------稳定</div><div class="line"></div><div class="line">void InsertionSortDichotomy(<span class="built_in">int</span>[] A,<span class="built_in">int</span> <span class="built_in">n</span>)&#123;</div><div class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">n</span>; i++)&#123;</div><div class="line">        <span class="built_in">int</span> get=A[i];//抓到的牌</div><div class="line">        <span class="built_in">int</span> <span class="built_in">left</span>=<span class="number">0</span>;//<span class="built_in">left</span>,<span class="built_in">right</span>是手牌的边界，手牌是已排序好的</div><div class="line">        <span class="built_in">int</span> <span class="built_in">right</span>=i-<span class="number">1</span>;</div><div class="line">        while(<span class="built_in">left</span>&lt;=<span class="built_in">right</span>)&#123;</div><div class="line">            <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;//二分查找，定位新牌的位置</div><div class="line">            <span class="built_in">if</span>(A[<span class="built_in">mid</span>]&gt;get)</div><div class="line">                <span class="built_in">right</span>=<span class="built_in">mid</span>-<span class="number">1</span>;</div><div class="line">            else</div><div class="line">                <span class="built_in">left</span>=<span class="built_in">mid</span>+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        for(<span class="built_in">int</span> j=i-<span class="number">1</span>; j&gt;=<span class="built_in">left</span>; j--)&#123;//将欲插入新牌位置后边的牌向后移一位</div><div class="line">            A[j+<span class="number">1</span>]=A[j];</div><div class="line">        &#125;</div><div class="line">        A[<span class="built_in">left</span>]=get;//将抓到的牌插入手牌</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="6、插入排序的更高效改进：希尔排序"><a href="#6、插入排序的更高效改进：希尔排序" class="headerlink" title="6、插入排序的更高效改进：希尔排序"></a>6、插入排序的更高效改进：希尔排序</h3><p>又叫递减增量排序，是不稳定的排序算法。<br>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素一次性地朝最终位置前进一大步。然后算法再取越来越小的补偿进行排序，算法的最后一步就是普通的插入排序，但到这一步，需排序的数据几乎是已排好的了（此时插入排序较快）。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" alt="image"><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------O(n^<span class="number">2</span>)</div><div class="line">最优时间复杂度---------O(n^<span class="number">1.3</span>)</div><div class="line">平均时间复杂度---------O(nlogn)~O(n^w)</div><div class="line">所需辅助空间-----------O(<span class="number">1</span>)</div><div class="line">稳定性-----------------不稳定</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span>(<span class="params"><span class="keyword">int</span> A[], <span class="keyword">int</span> n</span>)</span>&#123;</div><div class="line">    <span class="keyword">int</span> h=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(h&lt;=n)&#123;</div><div class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;<span class="comment">//生成初始增量</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</div><div class="line">    <span class="comment">//i和j相距距离为h，j在i左侧，A[j]和A[i]比较大小，大的向后移，之后j=j-h按步长向前退</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;n; i++)&#123;</div><div class="line">            <span class="keyword">int</span> j = i-h;</div><div class="line">            <span class="keyword">int</span> <span class="keyword">get</span> = A[i];</div><div class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; A[j]&gt;<span class="keyword">get</span>)&#123;</div><div class="line">                A[j+h] = A[j];</div><div class="line">                j = j-h;</div><div class="line">            &#125;</div><div class="line">            A[j+h] = <span class="keyword">get</span>;</div><div class="line">        &#125;</div><div class="line">        h=(h<span class="number">-1</span>)/<span class="number">3</span>;<span class="comment">//递减增量</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h3><p>归并操作如下：<br>1、申请空间，使其大小为两个已经排序的序列之和，该序列用来存放合并后的序列<br>2、设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>3、比较两个指针所指向的元素，选择较小的元素放入到合并空间，并移动指针到下一位置<br>4、重复步骤3直到某一指针达到序列末尾<br>5、将另一序列所剩下的所有元素直接复制到合并序列尾部  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" alt="image"><br><figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------O(nlogn)</div><div class="line">最优时间复杂度---------O(nlogn)</div><div class="line">平均时间复杂度---------O(nlogn)</div><div class="line">所需辅助空间-----------O(<span class="built_in">n</span>)</div><div class="line">稳定性-----------------稳定</div><div class="line"></div><div class="line"></div><div class="line">//合并两个已排好序的数组A[left...mid]和A[<span class="built_in">mid</span>+<span class="number">1</span>...<span class="built_in">right</span>]</div><div class="line">void Merge(<span class="built_in">int</span>[] A, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)&#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">len</span> = <span class="built_in">right</span>-<span class="built_in">left</span>+<span class="number">1</span>;</div><div class="line">    <span class="built_in">int</span>[] temp = new <span class="built_in">int</span>[<span class="built_in">len</span>];//辅助空间O(<span class="built_in">n</span>)</div><div class="line">    <span class="built_in">int</span> <span class="built_in">index</span>=<span class="number">0</span>;</div><div class="line">    <span class="built_in">int</span> i=<span class="built_in">left</span>;//i,j为两数组的起始位置</div><div class="line">    <span class="built_in">int</span> j=<span class="built_in">mid</span>+<span class="number">1</span>;</div><div class="line">    while(i&lt;=<span class="built_in">mid</span> &amp;&amp; j&lt;=<span class="built_in">right</span>)&#123;</div><div class="line">        temp[<span class="built_in">index</span>++] = A[i]&lt;=A[j] ? A[i++] <span class="symbol">:</span> A[j++];//选择较小元素放入合并空间，并更新指针</div><div class="line">    &#125;</div><div class="line">    while(i&lt;=<span class="built_in">mid</span>)</div><div class="line">        temp[<span class="built_in">index</span>++]=A[i++];</div><div class="line">    while(j&lt;=<span class="built_in">right</span>)</div><div class="line">        temp[<span class="built_in">index</span>++]=A[j++];</div><div class="line">    for(<span class="built_in">int</span> k=<span class="number">0</span>; k&lt;<span class="built_in">len</span>; k++)//将辅助序列复制回原数组</div><div class="line">        A[<span class="built_in">left</span>++]=temp[k];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//递归实现的归并排序（自顶向下）</div><div class="line">void MergeSortRecursion(<span class="built_in">int</span>[] A,<span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)&#123;</div><div class="line">    <span class="built_in">if</span>(<span class="built_in">left</span>==<span class="built_in">right</span>)//当序列长度为<span class="number">1</span>时，递归开始回溯，进行merge操作</div><div class="line">        return;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">mid</span>=(<span class="built_in">left</span>+<span class="built_in">right</span>)/<span class="number">2</span>;</div><div class="line">    MergeSortRecursion(A,<span class="built_in">left</span>,<span class="built_in">mid</span>);</div><div class="line">    MergeSortRecursion(A,<span class="built_in">mid</span>+<span class="number">1</span>,<span class="built_in">right</span>);</div><div class="line">    Merge(A,<span class="built_in">left</span>,<span class="built_in">mid</span>,<span class="built_in">right</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//非递归（迭代）实现的归并排序（自底向上）</div><div class="line">void MergeSortInteration(<span class="built_in">int</span>[] A, <span class="built_in">int</span> <span class="built_in">len</span>)&#123;</div><div class="line">    <span class="built_in">int</span> <span class="built_in">left</span>,<span class="built_in">mid</span>,<span class="built_in">right</span>;//子数组索引，A[left...mid]和A[<span class="built_in">mid</span>+<span class="number">1</span>...<span class="built_in">right</span>]</div><div class="line">    for(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="built_in">len</span>; i*=<span class="number">2</span>)&#123;//子数组大小i初始化为<span class="number">1</span>，每轮翻倍</div><div class="line">        <span class="built_in">left</span>=<span class="number">0</span>;</div><div class="line">        while(<span class="built_in">left</span>+i &lt; <span class="built_in">len</span>)&#123;//后一个数组存在（需要归并）</div><div class="line">            <span class="built_in">mid</span>=<span class="built_in">left</span>+i-<span class="number">1</span>;</div><div class="line">            <span class="built_in">right</span> = <span class="built_in">mid</span>+i&lt;<span class="built_in">len</span> ? <span class="built_in">mid</span>+i <span class="symbol">:</span> <span class="built_in">len</span>-<span class="number">1</span>;//后一个子数组大小可能不够</div><div class="line">            Merge(A,<span class="built_in">left</span>,<span class="built_in">mid</span>,<span class="built_in">right</span>);</div><div class="line">            <span class="built_in">left</span>=<span class="built_in">right</span>+<span class="number">1</span>;//前一个子数组索引向后移动</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="8、堆排序"><a href="#8、堆排序" class="headerlink" title="8、堆排序"></a>8、堆排序</h3><p>堆是一种近乎完全二叉树的结构，最大堆满足父结点的值总是大于它的孩子节点。<br>1、由输入的无序数组构造一个最大堆<br>2、把堆顶元素（最大值）和队尾元素互换<br>3、将堆的尺寸缩小1，从新的堆顶元素开始堆调整<br>4、重复步骤2~3，直到堆的尺寸为1<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------O(nlogn)</div><div class="line">最优时间复杂度---------O(nlogn)</div><div class="line">平均时间复杂度---------O(nlogn)</div><div class="line">所需辅助空间-----------O(<span class="number">1</span>)</div><div class="line">稳定性-----------------不稳定</div><div class="line"></div><div class="line"><span class="keyword">void</span> HeapSort(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);<span class="comment">//建立一个最大堆</span></div><div class="line">    <span class="built_in">while</span>(heap_size&gt;<span class="number">1</span>)&#123;<span class="comment">//堆元素个数大于1，未完成排序</span></div><div class="line">        swap(A,<span class="number">0</span>,--heap_size);<span class="comment">//将堆顶元素和堆的最后一个元素互换，并从堆中去除最后一个元素</span></div><div class="line">        Heapify(A,<span class="number">0</span>,heap_size);<span class="comment">//从新的堆顶元素开始向下进行堆调整</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//建堆</span></div><div class="line"><span class="keyword">int</span> BuildHeap(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)&#123;</div><div class="line">    <span class="keyword">int</span> heap_size=n;</div><div class="line">    <span class="comment">//从每一个非叶子节点开始向下进行堆排序，以每个非叶子节点为根节点都形成最大堆</span></div><div class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i=heap_size/<span class="number">2</span> <span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</div><div class="line">        Heapify(A, i, heap_size);</div><div class="line">    <span class="built_in">return</span> heap_size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//堆调整</span></div><div class="line"><span class="keyword">void</span> Heapify(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> <span class="built_in">size</span>)&#123;<span class="comment">//从A[i]向下进行堆调整</span></div><div class="line">    <span class="keyword">int</span> left_child=i*<span class="number">2</span> + <span class="number">1</span>;<span class="comment">//左孩子索引</span></div><div class="line">    <span class="keyword">int</span> right_child=i*<span class="number">2</span> + <span class="number">2</span>;<span class="comment">//右孩子索引</span></div><div class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=i;<span class="comment">//选出当前节点及左右孩子三者之间中的最大值</span></div><div class="line">    <span class="built_in">if</span>(left_child&lt;<span class="built_in">size</span> &amp;&amp; A[left_child]&gt;A[<span class="built_in">max</span>])</div><div class="line">        <span class="built_in">max</span>=left_child;</div><div class="line">    <span class="built_in">if</span>(right_child&lt;<span class="built_in">size</span> &amp;&amp; A[right_child]&gt;A[<span class="built_in">max</span>])</div><div class="line">        <span class="built_in">max</span>=right_child;</div><div class="line">    <span class="built_in">if</span>(<span class="built_in">max</span> != i)&#123;</div><div class="line">        swap(A, i, <span class="built_in">max</span>);</div><div class="line">        Heapify(A, <span class="built_in">max</span>, <span class="built_in">size</span>);<span class="comment">//递归调用，继续从当前节点向下进行堆调整</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="9、快速排序"><a href="#9、快速排序" class="headerlink" title="9、快速排序"></a>9、快速排序</h3><p>1、从序列中挑出一个元素，作为基准。<br>2、把所有比基准小的元素放在基准前面，所有比基准大的元素放在基准的后面，这个称为分区操作。<br>3.对每个分区递归的调用步骤1~2，递归的结束条件是序列的大小是0或是1，这时整体已经排序好了。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" alt="image"><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">分类-------------------内部比较排序</div><div class="line">数据结构---------------数组</div><div class="line">最差时间复杂度---------<span class="type">O</span>(n^<span class="number">2</span>)</div><div class="line">最优时间复杂度---------<span class="type">O</span>(nlogn)</div><div class="line">平均时间复杂度---------<span class="type">O</span>(nlogn)</div><div class="line">所需辅助空间-----------主要是递归造成的栈空间使用（用来保存<span class="keyword">left</span>和<span class="keyword">right</span>等局部变量），取决于递归树的深度，一般为<span class="type">O</span>(logn)，最差为<span class="type">O</span>(n)</div><div class="line">稳定性-----------------不稳定</div><div class="line"></div><div class="line"></div><div class="line">void <span class="type">QuickSort</span>(int[] <span class="type">A</span>, int <span class="keyword">left</span>, int <span class="keyword">right</span>)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">left</span>&gt;=<span class="keyword">right</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    int pivot_index = <span class="type">Partition</span>(<span class="type">A</span>, <span class="keyword">left</span>, <span class="keyword">right</span>);<span class="comment">//基准的索引</span></div><div class="line">    <span class="type">QuickSort</span>(<span class="type">A</span>, <span class="keyword">left</span>, pivot_index-<span class="number">1</span>);</div><div class="line">    <span class="type">QuickSort</span>(<span class="type">A</span>, pivot_index+<span class="number">1</span>, <span class="keyword">right</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//划分函数</span></div><div class="line">int <span class="type">Partition</span>(int[] <span class="type">A</span>, int <span class="keyword">left</span>, int <span class="keyword">right</span>)&#123;</div><div class="line">    int pivot=<span class="type">A</span>[<span class="keyword">right</span>];<span class="comment">//每次以最后一个元素为基准</span></div><div class="line">    int tail=<span class="keyword">left</span>-<span class="number">1</span>;<span class="comment">//tail为小于基准的子数组的最后一个元素的索引</span></div><div class="line">    <span class="keyword">for</span>(int i=<span class="keyword">left</span>; i&lt;<span class="keyword">right</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="type">A</span>[i]&lt;pivot)<span class="comment">//把小于基准的数字放到前一个子数组的末尾</span></div><div class="line">            <span class="built_in">swap</span>(<span class="type">A</span>, ++tail, i);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">swap</span>(<span class="type">A</span>, tail+<span class="number">1</span>, <span class="keyword">right</span>);<span class="comment">//最后把基准放到前一个子数组的后边，剩下的子数组就是大于基准的子数组</span></div><div class="line">    <span class="keyword">return</span> tail+<span class="number">1</span>;<span class="comment">//返回基准索引</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java实现二叉树的先序、中序、后序遍历</title>
      <link href="/2017/10/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2017/10/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      <content type="html"><![CDATA[<h3 id="先序遍历示意图："><a href="#先序遍历示意图：" class="headerlink" title="先序遍历示意图："></a>先序遍历示意图：</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="image">  </p><h3 id="中序遍历示意图："><a href="#中序遍历示意图：" class="headerlink" title="中序遍历示意图："></a>中序遍历示意图：</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="image">  </p><h3 id="后序遍历示意图："><a href="#后序遍历示意图：" class="headerlink" title="后序遍历示意图："></a>后序遍历示意图：</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.jpg" alt="image">  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class <span class="keyword">Node</span> <span class="title">&#123;  </span></div><div class="line">    private int data;  </div><div class="line">    private <span class="keyword">Node</span> <span class="title">leftNode</span>;  </div><div class="line">    private <span class="keyword">Node</span> <span class="title">rightNode</span>;  </div><div class="line">    public <span class="keyword">Node</span><span class="title">(int</span> data, <span class="keyword">Node</span> <span class="title">leftNode</span>, <span class="keyword">Node</span> <span class="title">rightNode</span>)&#123;  </div><div class="line">        this.data = data;  </div><div class="line">        this.leftNode = leftNode;  </div><div class="line">        this.rightNode = rightNode;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public int getData() &#123;  </div><div class="line">        return data;  </div><div class="line">    &#125;  </div><div class="line">    public void setData(int data) &#123;  </div><div class="line">        this.data = data;  </div><div class="line">    &#125;  </div><div class="line">    public <span class="keyword">Node</span> <span class="title">getLeftNode</span>() &#123;  </div><div class="line">        return leftNode;  </div><div class="line">    &#125;  </div><div class="line">    public void setLeftNode(<span class="keyword">Node</span> <span class="title">leftNode</span>) &#123;  </div><div class="line">        this.leftNode = leftNode;  </div><div class="line">    &#125;  </div><div class="line">    public <span class="keyword">Node</span> <span class="title">getRightNode</span>() &#123;  </div><div class="line">        return rightNode;  </div><div class="line">    &#125;  </div><div class="line">    public void setRightNode(<span class="keyword">Node</span> <span class="title">rightNode</span>) &#123;  </div><div class="line">        this.rightNode = rightNode;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="一、递归遍历"><a href="#一、递归遍历" class="headerlink" title="一、递归遍历"></a>一、递归遍历</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先序遍历</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">theFirstTraversal</span><span class="params">(Node root)</span></span>&#123;</div><div class="line">    printNode(root);</div><div class="line">    <span class="keyword">if</span>(root.getLeftNode() != <span class="keyword">null</span>)&#123;</div><div class="line">        theFirstTraversal(root.getLeftNode());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.getRightNode() != <span class="keyword">null</span>)&#123;</div><div class="line">        theFirstTraversal(root.getRightNode());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">theInOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;    </div><div class="line">    <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </div><div class="line">        theInOrderTraversal(root.getLeftNode());  </div><div class="line">    &#125;  </div><div class="line">    printNode(root);  </div><div class="line">    <span class="keyword">if</span> (root.getRightNode() != <span class="keyword">null</span>) &#123;  </div><div class="line">        theInOrderTraversal(root.getRightNode());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">//后序遍历  </span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">thePostOrderTraversal</span><span class="params">(Node root)</span> </span>&#123;    </div><div class="line">    <span class="keyword">if</span> (root.getLeftNode() != <span class="keyword">null</span>) &#123;  </div><div class="line">        thePostOrderTraversal(root.getLeftNode());  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span>(root.getRightNode() != <span class="keyword">null</span>) &#123;  </div><div class="line">        thePostOrderTraversal(root.getRightNode());  </div><div class="line">    &#125;  </div><div class="line">    printNode(root);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//先序遍历</div><div class="line">public void theFirstTraversal_Stack(<span class="keyword">Node</span> <span class="title">root</span>)&#123;</div><div class="line">    Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;Node&gt;</span>();</div><div class="line">    <span class="keyword">Node</span> <span class="title">node</span> = root;</div><div class="line">    while(<span class="keyword">node</span> <span class="title">!= null</span> || stack.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">        if(<span class="keyword">node</span> <span class="title">!= null</span>)&#123;</div><div class="line">            printNode(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            stack.push(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            node = <span class="keyword">node</span>.<span class="title">getLeftNode</span>();</div><div class="line">        &#125;else&#123;</div><div class="line">            <span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">            <span class="keyword">node</span> <span class="title">= node</span>.getRightNode();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//中序遍历</div><div class="line">public void theInOrderTraversal_Stack(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</div><div class="line">    Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;Node&gt;</span>();</div><div class="line">    <span class="keyword">Node</span> <span class="title">node</span> = root;</div><div class="line">    while(<span class="keyword">node</span> <span class="title">!= null</span> || stack.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">        if(<span class="keyword">node</span> <span class="title">!= null</span>)&#123;</div><div class="line">            stack.push(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            node = <span class="keyword">node</span>.<span class="title">getLeftNode</span>();</div><div class="line">        &#125;else&#123;</div><div class="line">            <span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">            printNode(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            node = <span class="keyword">node</span>.<span class="title">getRightNode</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//后序遍历  </div><div class="line">public void thePostOrderTraversal_Stack(<span class="keyword">Node</span> <span class="title">root</span>) &#123;</div><div class="line">    Stack<span class="tag">&lt;Node&gt;</span> stack = new Stack<span class="tag">&lt;Node&gt;</span>();</div><div class="line">    Stack<span class="tag">&lt;Node&gt;</span> output = new Stack<span class="tag">&lt;Node&gt;</span>();//用于存储逆后序遍历的结果</div><div class="line">    <span class="keyword">Node</span> <span class="title">node</span> = root;</div><div class="line">    while(<span class="keyword">node</span> <span class="title">!= null</span> || stack.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">        if(<span class="keyword">node</span> <span class="title">!= null</span>)&#123;</div><div class="line">            stack.push(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            output.push(<span class="keyword">node</span><span class="title">);</span></div><div class="line">            node = <span class="keyword">node</span>.<span class="title">getRightNode</span>();</div><div class="line">        &#125;else&#123;</div><div class="line">            <span class="keyword">node</span> <span class="title">= stack</span>.pop();</div><div class="line">            <span class="keyword">node</span> <span class="title">= node</span>.getLeftNode();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    while(output.size() &gt; <span class="number">0</span>)&#123;</div><div class="line">        printNode(output.pop());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>29、数组中出现超过一半的数字</title>
      <link href="/2017/10/13/29%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2017/10/13/29%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。  </p><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><p>在遍历数组时，保存两个值：一个是数组中的一个数字，还有一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的相同，则次数加一，不同次数就减一。若次数为0，我们需要保存下一个数字，次数记为1。由于我们要找的数字出现次数比其他所有数字出现的次数之和还多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。  </p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public class <span class="type">Solution</span> &#123;</div><div class="line">    public <span class="built_in">int</span> <span class="type">MoreThanHalfNum_Solution</span>(<span class="built_in">int</span> [] <span class="built_in">array</span>) &#123;</div><div class="line">        <span class="built_in">int</span> <span class="literal">result</span>=<span class="built_in">array</span>[<span class="number">0</span>];</div><div class="line">        <span class="built_in">int</span> count=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">array</span>.length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</div><div class="line">                <span class="literal">result</span>=<span class="built_in">array</span>[i];</div><div class="line">                count=<span class="number">1</span>;</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i]==<span class="literal">result</span>)&#123;</div><div class="line">                count++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                count--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!<span class="type">CheckMoreThanHalf</span>(<span class="built_in">array</span>,<span class="built_in">array</span>.length,<span class="literal">result</span>))</div><div class="line">            <span class="literal">result</span>=<span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</div><div class="line">    &#125;</div><div class="line">    //检验最后一次把次数设为<span class="number">1</span>时对应的数字出现的次数是够满足超过一半的数字。</div><div class="line">    boolean <span class="type">CheckMoreThanHalf</span>(<span class="built_in">int</span>[] <span class="built_in">array</span>,<span class="built_in">int</span> length,<span class="built_in">int</span> <span class="literal">result</span>)&#123;</div><div class="line">        boolean a=<span class="literal">true</span>;</div><div class="line">        <span class="built_in">int</span> times=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i]==<span class="literal">result</span>)</div><div class="line">                times++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(times*<span class="number">2</span>&lt;=length)</div><div class="line">            a=<span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>30、最小的k个数</title>
      <link href="/2017/10/13/30%E3%80%81%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>/2017/10/13/30%E3%80%81%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。  </p><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><p>创建一个大小为k的最大堆，先依次放入k个数，找出k个数中的最大值，然后每次拿待插入的数和最大值比较。如果待插入的数比当前已知的最大值小，就用这个数替换最大值；若比最大值大，就抛弃该数。<br>堆满之后，要做三件事：一是找出最大数；二是可能需要删除最大数；三是可能要插入新数字，我们可以在O(logk)时间内完成这三步操作。对N个数字而言，总时间复杂度为O(nlogk)。  </p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.PriorityQueue;</div><div class="line"><span class="keyword">import</span> java.util.Comparator;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k) &#123;</div><div class="line">        ArrayList&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        <span class="keyword">int</span> length=input.length;</div><div class="line">        <span class="keyword">if</span>(k&gt;length || k&lt;=<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">        </div><div class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k , <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;<span class="comment">//PriorityQueue是基于最小堆的</span></div><div class="line">            @Override</div><div class="line">            <span class="keyword">public</span> <span class="keyword">int</span> compare(Integer o1,Integer o2)&#123;</div><div class="line">                <span class="keyword">return</span> o2.compareTo(o1);<span class="comment">//变为按逆序排的最大堆，原为按自然顺序的最小堆</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(maxHeap.size() != k)&#123;<span class="comment">//先填满大小为k的最大堆</span></div><div class="line">                maxHeap.offer(input[i]);</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxHeap.peek() &gt; input[i])&#123;<span class="comment">//如果比最大堆中最大的数小，则替换之。</span></div><div class="line">                maxHeap.poll();</div><div class="line">                maxHeap.offer(input[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(Integer integer : maxHeap)&#123;</div><div class="line">            <span class="built_in">list</span>.add(integer);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java实现二叉排序树的插入、查找和删除</title>
      <link href="/2017/10/12/Java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A0%E9%99%A4/"/>
      <url>/2017/10/12/Java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E6%9F%A5%E6%89%BE%E5%92%8C%E5%88%A0%E9%99%A4/</url>
      <content type="html"><![CDATA[<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>又叫二叉查找树。<br>1.可以使一颗空树<br>2.若左子树不为空，则左子树上所有节点的值均小于根节点的值<br>3.若右子树不为空，则右子树上所有节点的值均大于根节点的值<br>4.左右子树也分别为二叉排序树  </p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong>查找性能</strong>：含有n个节点的二叉排序树的平均查找长度和树的形态有关。<br>（最坏情况）当先后插入的关键字有序时，构成的二叉排序树蜕变为单枝树，查找性能为O(n)<br>（最好情况）二叉排序的形态和折半查找的判定树相同，平均查找长度和log2(n)成正比  </p><p><strong>插入、删除性能</strong>：插入、删除操作的时间复杂度都是O(logn)级的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//二叉树节点定义</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">value</span>;</div><div class="line">    <span class="keyword">private</span> Node left;</div><div class="line">    <span class="keyword">private</span> Node right;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">Node left, Node right, <span class="keyword">int</span> <span class="keyword">value</span></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.left = left;</div><div class="line">        <span class="keyword">this</span>.right=right;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">set</span>,<span class="keyword">get</span>...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BinarySortTree</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Node root=<span class="literal">null</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//查找二叉排序树中是否有key值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">searchBST</span>(<span class="params"><span class="keyword">int</span> key</span>)</span>&#123;</div><div class="line">        Node current = root;</div><div class="line">        <span class="keyword">while</span>(current != <span class="literal">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(key == current.getValue())</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">else</span>(key &lt; current.getValue())</div><div class="line">                current=current.getLeft();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                current=current.getRight();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//向二叉排序树中插入节点</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertBST</span>(<span class="params"><span class="keyword">int</span> key</span>)</span>&#123;</div><div class="line">        Node p = root;</div><div class="line">        <span class="comment">//记录查找节点的父节点</span></div><div class="line">        Node prev = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//一直查找下去，一直到满足条件的叶子节点</span></div><div class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</div><div class="line">            prev=p;</div><div class="line">            <span class="keyword">if</span>(key &lt; p.getValue())</div><div class="line">                p = p.getLeft();</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; p.getValue())</div><div class="line">                p = p.getRight();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span>;<span class="comment">//找到了相同节点就返回</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//prev为要安放节点的父结点，根据key的大小，判断放入prev的左右节点</span></div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</div><div class="line">            root = <span class="keyword">new</span> Node(key);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; prev.getValue())</div><div class="line">            prev.setLeft(<span class="keyword">new</span> Node(key));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            prev.setRight(<span class="keyword">new</span> Node(key));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//删除二叉排序树中的节点</span></div><div class="line">    分为三种情况：</div><div class="line">    (<span class="number">1</span>)要删除的节点p是叶子节点，删除置空即可</div><div class="line">    (<span class="number">2</span>)p只有左子树或右子树，直接让左子树/右子树代替p</div><div class="line">    (<span class="number">3</span>)p既有左子树又有右子树，用p左子树中最大的那个值（最右端s）代替p，删除s，重接其左子树</div><div class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">delete</span>(<span class="params">Node node</span>)</span>&#123;</div><div class="line">        Node temp = <span class="literal">null</span>;</div><div class="line">        <span class="comment">//右子树为空，重接它的左子树；如果是叶子节点，在这也被置为空</span></div><div class="line">        <span class="keyword">if</span>(node.getRight()==<span class="literal">null</span>)&#123;</div><div class="line">            temp = node;</div><div class="line">            node = node.getLeft();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//左子树为空，重接它的右子树</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node.getLeft()==<span class="literal">null</span>)&#123;</div><div class="line">            temp = node;</div><div class="line">            node = node.getRight();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//左右子树都不为空</span></div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            temp = node;</div><div class="line">            Node s = node;</div><div class="line">            <span class="comment">//转向左子树，然后向右走到尽头</span></div><div class="line">            s=s.getLeft();<span class="comment">//temp是s的父结点</span></div><div class="line">            <span class="keyword">while</span>(s.getRight() != <span class="literal">null</span>)&#123;</div><div class="line">                temp = s;</div><div class="line">                s = s.getRight();</div><div class="line">            &#125;</div><div class="line">            node.setValue(s.getValue());<span class="comment">//将node的值设为左子树最右侧s的值</span></div><div class="line">            <span class="keyword">if</span>(temp != node)&#123;</div><div class="line">                temp.setRight(s.getLeft());<span class="comment">//见书p326</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                temp.setLeft(s.getLeft());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>静态代码块、构造代码块、构造函数及类初始化顺序</title>
      <link href="/2017/10/12/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"/>
      <url>/2017/10/12/%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>静态代码块：用static声明，jvm加载类时执行，仅执行一次。<br>构造代码块：类中直接用{}定义，每一次创建对象时执行。<br>执行顺序优先级：<strong>静态块-&gt;main()-&gt;构造块-&gt;构造函数</strong>。  </p><h2 id="二、详解"><a href="#二、详解" class="headerlink" title="二、详解"></a>二、详解</h2><h3 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;<span class="comment">//构造函数</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>1.对象一建立就会调用与之相应的构造函数，也就是说，不建立对象，构造函数是不会运行的。<br>2.构造函数的作用是用于给对象初始化。<br>3.一个对象建立，构造函数只运行一次。  </p><h3 id="2、构造代码块"><a href="#2、构造代码块" class="headerlink" title="2、构造代码块"></a>2、构造代码块</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="comment">//构造代码块</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>1.构造代码块的作用是给对象进行初始化。<br>2.对象一建立就运行构造代码块了，而且优先于构造函数。有对象建立，才会运行构造代码块，类是不能调用构造代码块的。<br>3.构造代码块和构造函数的区别：<strong>构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。</strong>因为构造函数可以有多个，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。  </p><h3 id="3、静态代码块"><a href="#3、静态代码块" class="headerlink" title="3、静态代码块"></a>3、静态代码块</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span>&#123;<span class="comment">//静态代码块</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>1.<strong>它随着类的加载而执行，只执行一次，并且优先于主函数</strong>。具体说，静态代码块是由类调用的，类调用时，先执行静态代码块，然后再执行主函数。<br>2.静态代码块其实是给类初始化的，而构造代码块是给对象初始化的。<br>3.静态代码块中的变量是局部变量，与普通函数中的局部变量没有区别。<br>4.一个类中可以有多个静态代码块。  </p><h2 id="三、类初始化顺序"><a href="#三、类初始化顺序" class="headerlink" title="三、类初始化顺序"></a>三、类初始化顺序</h2><p>&emsp;其中，<strong>静态变量、静态初始化块，变量、初始化块（构造代码块）的初始化顺序取决于它们在类中出现的先后顺序。</strong><br>首先，访问SubClass.main()，这是一个static方法，于是装载器会寻找已经编译的SubClass.class文件。在装载过程中，如果注意到有基类（extends），会装载基类。不管创不创建基类对象，这个过程都会发生。之后是正常的初始化顺序：  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F.png" alt="image"><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField=<span class="string">"父类--静态变量"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> String p_Field=<span class="string">"父类--变量"</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> i=<span class="number">9</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(p_StaticField);</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"父类--静态初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        System.<span class="keyword">out</span>.println(p_Field);</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"父类--初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"父类--构造器"</span>);</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"i="</span> + i+ <span class="string">",j="</span> + j);</div><div class="line">        j=<span class="number">20</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubClass</span> <span class="title">extends</span> <span class="title">Parent</span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField=<span class="string">"子类--静态变量"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> String s_Field=<span class="string">"子类--变量"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(s_StaticField);</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"子类--静态初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    &#123;</div><div class="line">        System.<span class="keyword">out</span>.println(s_Field);</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"子类--初始化块"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"子类--构造器"</span>);</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"i="</span> + i+ <span class="string">",j="</span> + j);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"子类main方法"</span>);</div><div class="line">        <span class="keyword">new</span> SubClass();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">运行结果：  </div><div class="line">父类--静态变量  </div><div class="line">父类--静态初始化块  </div><div class="line">子类--静态变量  </div><div class="line">子类--静态初始化块  </div><div class="line">子类main方法  </div><div class="line">父类--变量  </div><div class="line">父类--初始化块  </div><div class="line">父类--构造器  </div><div class="line">i=<span class="number">9</span>, j=<span class="number">0</span>  </div><div class="line">子类--变量  </div><div class="line">子类--初始化块  </div><div class="line">子类--构造器  </div><div class="line">i=<span class="number">9</span>,j=<span class="number">20</span></div></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串、基本数据类型等在堆、栈、常量池中的存储</title>
      <link href="/2017/10/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AD%89%E5%9C%A8%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2017/10/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%AD%89%E5%9C%A8%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<h1 id="一、对于字符串"><a href="#一、对于字符串" class="headerlink" title="一、对于字符串"></a>一、对于字符串</h1><p>字符串的对象引用都是存储在栈中的。如果是编译期已经创建好的（直接用双引号定义的），对象存储在常量池中；如果是运行期才能确定的（new出来的），对象存储在堆中。对于equals相等的字符串，常量池中只有一份，堆中可以有多份。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">String</span> s1=<span class="string">"china"</span>;</div><div class="line"><span class="keyword">String</span> s2=<span class="string">"china"</span>;</div><div class="line"><span class="keyword">String</span> ss1=<span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"china"</span>);</div><div class="line"><span class="keyword">String</span> ss2=<span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"china"</span>);</div></pre></td></tr></table></figure></p><p>通过new产生一个字符串“china”时，会先去常量池中查找是否已经有了“china”，如果没有，就在常量池中创建一个此字符串对象，然后在堆中再创建一个常量池中此“china”对象的拷贝对象。  </p><h1 id="二、对于基础类型的变量和常量"><a href="#二、对于基础类型的变量和常量" class="headerlink" title="二、对于基础类型的变量和常量"></a>二、对于基础类型的变量和常量</h1><p>局部变量（包括形式参数）：数据存在于栈内存中，栈内存中的局部变量随着方法的消失而消失。<br>成员变量：存储在堆中的对象里面，由垃圾收集器负责回收。<br>常量、静态变量：存储在方法区中（常量池）。  </p><h1 id="三、Java中的两种数据类型"><a href="#三、Java中的两种数据类型" class="headerlink" title="三、Java中的两种数据类型"></a>三、Java中的两种数据类型</h1><h2 id="1、八种基本类型"><a href="#1、八种基本类型" class="headerlink" title="1、八种基本类型"></a>1、八种基本类型</h2><p>byte,short,int,long,char,double,float,boolean。如函数中的int a=3，a是一个指向3这个字面值的引用。存在于栈中，数据可以共享。同时定义int a=3和int b=3，a和b会同时指向3。<br>字面值的引用和类对象引用不同。两类对象引用同时指向一个对象，若一个对象引用变量修改了这个对象的内部状态，那么对另一个对象引用也即刻反映出变化，但字面值引用不会。  </p><h2 id="2、包装类数据"><a href="#2、包装类数据" class="headerlink" title="2、包装类数据"></a>2、包装类数据</h2><p>Integer,Double等。这些数据全部存在于堆中，Java中用new语句显式的告诉编译器运行时根据需要动态创建，灵活但更占用时间。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args)&#123;</div><div class="line">    int <span class="attribute">a1</span>=1;</div><div class="line">    int <span class="attribute">b1</span>=1;</div><div class="line">    int <span class="attribute">c1</span>=2;</div><div class="line">    int <span class="attribute">d1</span>=a1+b1;</div><div class="line">    </div><div class="line">    Integer <span class="attribute">a</span>=1;</div><div class="line">    Integer <span class="attribute">b</span>=2;</div><div class="line">    Integer <span class="attribute">c</span>=3;</div><div class="line">    Integer <span class="attribute">d</span>=3</div><div class="line">    </div><div class="line">    Integer <span class="attribute">e</span>=321;</div><div class="line">    Integer <span class="attribute">f</span>=321;</div><div class="line">    </div><div class="line">    System.out.println(<span class="attribute">a1</span>==b1);//true</div><div class="line">    System.out.println(<span class="attribute">c1</span>==d1);//true</div><div class="line">    System.out.println(<span class="attribute">c</span>==(a+b));//true</div><div class="line">    System.out.println(<span class="attribute">c</span>==d);//true</div><div class="line">    System.out.println(<span class="attribute">c</span>==d);//false</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在自动装箱时（int-&gt;Integer时），当int值在-128~127时，返回的不是一个新New出来的Integer对象，而是一个已经缓存在堆中的Integer对象；若不在范围，则返回一个新new出来的Integer对象。<br>System.out.println(c1==d1);//true：先创建一个c1的引用，查找有没有字面值为2的地址，没找到，就开辟一个存放2这个字面值的地址，将c1指向2的地址。d1为两个字面值相加也为2，由于在栈中已经有2这个字面量的地址，因此将d1直接指向2的地址，所以c1和d1的指向相同。  </p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java对象的创建过程</title>
      <link href="/2017/10/11/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2017/10/11/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="一、对象的创建"><a href="#一、对象的创建" class="headerlink" title="一、对象的创建"></a>一、对象的创建</h1><h2 id="对象创建有以下几个步骤："><a href="#对象创建有以下几个步骤：" class="headerlink" title="对象创建有以下几个步骤："></a>对象创建有以下几个步骤：</h2><p>1.虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程。<br>2.在类加载检查通过后，接下来虚拟机为新生对象分配内存。<br>3.内存分配后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。<br>4.执行<init>方法，把对象按照程序员的意愿进行初始化。<br>5.将对象在堆上分配的内存地址赋给实例变量。  </init></p><h2 id="初始化顺序："><a href="#初始化顺序：" class="headerlink" title="初始化顺序："></a>初始化顺序：</h2><p>1、先父类，后子类<br>2、先属性，再构造代码块，最后构造函数<br>3、先静态，后非静态<br>4、同一类型，按代码顺序先后执行  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.png" alt="image">  </p><h1 id="二、对象的内存布局"><a href="#二、对象的内存布局" class="headerlink" title="二、对象的内存布局"></a>二、对象的内存布局</h1><p>对象在内存中存储的布局可以分为三块区域：<strong>对象头、实例数据和对齐填充</strong>。  </p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>包括两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。  </p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是子类中定义的，都需要记录下来（包括private的）。  </p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>非必要存在，仅仅起着占位符的作用。  </p><h1 id="三、对象的访问定位"><a href="#三、对象的访问定位" class="headerlink" title="三、对象的访问定位"></a>三、对象的访问定位</h1><p>建立对象是为了使用对象，java程序通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.jpg" alt="image"></p>]]></content>
      
      <categories>
          
          <category> 深入理解Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入java虚拟机之垃圾收集器</title>
      <link href="/2017/10/11/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2017/10/11/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="七种垃圾收集器"><a href="#七种垃圾收集器" class="headerlink" title="七种垃圾收集器"></a>七种垃圾收集器</h3><p>1、Serial（串行GC）-复制<br>2、ParNew（并行GC）-复制<br>3、Parallel Scavenge（并行回收GC）-复制<br>4、Serial Old(MSC)（串行GC）-标记-整理<br>5、CMS（并发GC）-标记-清除<br>6、Parallel Old（并行GC）-标记-整理<br>7、G1（jdk1.7才正式商用）<br>其中，1~3用于年轻代垃圾回收（minor GC），4~6用于老年代垃圾回收（full GC），G1独立完成“分代垃圾回收”。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="image">  </p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p><strong>并行</strong>：多条垃圾回收线程同时操作<br><strong>并发</strong>：垃圾回收线程和用户线程一起操作，但不一定是并行的，可能交替执行。  </p><h3 id="常用的五种组合"><a href="#常用的五种组合" class="headerlink" title="常用的五种组合"></a>常用的五种组合</h3><p>1、Serial/Serial Old<br>2、ParNew/Serial Old，与上面相比，只是比年轻代多了多线程垃圾回收而已<br>3、ParNew/CMS，当下比较高校的组合<br>4、Parallel Scavenge/Parallel Old，自动管理的组合<br>5、G1，最先进的收集器，需要jdk1.7update14以上  </p><h2 id="一、新生代垃圾收集器"><a href="#一、新生代垃圾收集器" class="headerlink" title="一、新生代垃圾收集器"></a>一、新生代垃圾收集器</h2><h3 id="1、Serial收集器"><a href="#1、Serial收集器" class="headerlink" title="1、Serial收集器"></a>1、Serial收集器</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="image">  </p><p>是最基础、最古老的收集器，是一个单线程的收集器，是Client模式下的默认收集器。<br><strong>优点</strong>：简单高效（与其他收集器的单线程比），对于限定单个CPU的环境下，Serial收集器由于没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率。<br><strong>缺点</strong>：是单线程处理，并且会stop the world，即在它进行垃圾收集时，必须暂停其他所有的工作线程，这对很多应用来说难以接受的。<br><strong>应用</strong>：Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。  </p><h3 id="2、ParNew收集器"><a href="#2、ParNew收集器" class="headerlink" title="2、ParNew收集器"></a>2、ParNew收集器</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/parnew.png" alt="image">  </p><p>其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其他都与Serial完全一样。<br><strong>特点</strong>：<br>1.是并行收集器<br>2.是server模式下的首选收集器<br>3.可以和CMS收集器相配合，但是Parallel Scavenge与CMS是无法配合的<br>4.使用复制算法进行垃圾回收  </p><h3 id="3、Parallel-Scavenge收集器"><a href="#3、Parallel-Scavenge收集器" class="headerlink" title="3、Parallel Scavenge收集器"></a>3、Parallel Scavenge收集器</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/Parallel%20Scavenge.png" alt="image">  </p><p>&emsp;Parallel Scavenge的关注点和其他收集器不同，<strong>CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge的目的是达到一个可控制的吞吐量</strong>。<br>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)<br>&emsp;停顿时间越短就越适合需要与用户交互的程序，良好的响应速度可以提升用户体验；而<strong>高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</strong>  </p><h2 id="二、老年代垃圾收集器"><a href="#二、老年代垃圾收集器" class="headerlink" title="二、老年代垃圾收集器"></a>二、老年代垃圾收集器</h2><h3 id="1、Serial-Old收集器"><a href="#1、Serial-Old收集器" class="headerlink" title="1、Serial Old收集器"></a>1、Serial Old收集器</h3><p>是Serial收集器的老年代版本。<br><strong>特点</strong>：<br>1.是一个单线程收集器<br>2.使用标记-整理算法<br>3.主要在Client模式下使用<br>&emsp;在Server模式下，主要有两个用途：一个是在jdk1.5前与Parallel Scavenge配合使用，还有一个是作为CMS的后备预案，在发生Concurrent Mode Failure时使用。  </p><h3 id="2、Parallel-Old收集器"><a href="#2、Parallel-Old收集器" class="headerlink" title="2、Parallel Old收集器"></a>2、Parallel Old收集器</h3><p>是Parallel Scavenge老年代版本。<br><strong>特点</strong>：<br>1.多线程<br>2.标记-整理算法<br>3.jdk1.6之后提供<br><strong>作用</strong>：在Parallel Old之前，如果新生代选择了Parallel Scavenge，那么老年代只能选择Serial Old，由于Serial Old的拖累，使用整体性能不一定比ParNew/CMS高。直到有了Parallel Old，“吞吐量优先”菜真正有了名副其实的组合。  </p><h3 id="3、CMS（Concurrent-Mark-Sweep）收集器"><a href="#3、CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="3、CMS（Concurrent Mark Sweep）收集器"></a>3、CMS（Concurrent Mark Sweep）收集器</h3><p><img src="http://osrmzp0jr.bkt.clouddn.com/CMS.png" alt="image">  </p><p><strong>是一种追求回收停顿时间最短的收集器。</strong>  是基于“标记-清除”算法实现的。<br><strong>分为四个步骤</strong>：<br><strong>1.初始标记</strong>：仅仅是标记一下GC Roots能直接关联到的对象，速度很快<br><strong>2.并发标记</strong>：进行GC Roots的追踪过程<br><strong>3.重新标记</strong>：为了修正并发标记期间由于用户程序继续运作而导致标记产生变动的那一部分对象的标示记录<br><strong>4.标记清除</strong><br>&emsp;其中，初始标记和重新标记仍然需要“Stop the world”，但是由于整个过程中最耗时的并发标记和并发清除过程是可以与用户线程一起工作的，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。<br><strong>优点</strong>：并发收集，低停顿<br><strong>缺点</strong>：<br>1.对cpu资源非常敏感<br>2.无法处理浮动垃圾，当CMS运行期间预留的内存无法满足程序需要，会出现“Concurrent Mode Failure”<br>3.标记-清除算法，会产生大量的空间碎片<br>&emsp;默认条件下，当老年代使用68%即触发GC，1.6中已提高为92%。  </p><h2 id="三、通用收集器G1（Garbage-First）"><a href="#三、通用收集器G1（Garbage-First）" class="headerlink" title="三、通用收集器G1（Garbage-First）"></a>三、通用收集器G1（Garbage-First）</h2><p><img src="http://osrmzp0jr.bkt.clouddn.com/G1.png" alt="image">  </p><p>1.7u14后正式提供商用G1，以前都是测试用的。G1是一款面向服务端应用的垃圾收集器。<br><strong>特点</strong>：<br>1.并行与并发<br>2.分代收集<br>3.空间整合：基于“标记-整理”，不会产生内存空间碎片<br>4.可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<br>&emsp;G1将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但是他们并不是物理隔离的了，他们都是一部分Region（不需要连续）的集合。G1跟踪各个Region里面垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，这也就是Garbage-First的由来。<br><strong>难题</strong>：对象可能在不同的Region中引用。<br><strong>解决方法</strong>：G1通过Remember Set来避免进行全堆扫描。G1中每个Region都有一个对应的Remember Set，一旦发现一个对象引用了另一个Region的对象，就通过CardTable把相关引用信息记录到被引用对象所属的Region的Remember Set中。当进行GC时，在GC根节点的枚举范围中加入Remember Set，就可以保证不对全堆扫描也不会有遗漏。<br><strong>主要有以下几个步骤</strong>：<br><strong>1.初始标记</strong>：标记一下GC Roots能直接关联到的对象，并修改TAMS的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象<br><strong>2.并发标记</strong>：从GC Roots进行可达性分析，找出存活对象<br><strong>3.最终标记</strong>：为了修正并发标记期间由于用户程序继续运作而导致标记产生变动的那一部分对象的标示记录<br><strong>4.筛选回收</strong>  </p>]]></content>
      
      <categories>
          
          <category> 深入理解Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入java虚拟机之垃圾回收算法</title>
      <link href="/2017/10/10/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2017/10/10/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="一、判断对象是否已死"><a href="#一、判断对象是否已死" class="headerlink" title="一、判断对象是否已死"></a>一、判断对象是否已死</h1><h2 id="1、引用计数算法"><a href="#1、引用计数算法" class="headerlink" title="1、引用计数算法"></a>1、引用计数算法</h2><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>缺点：难以解决循环引用的问题。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ReferenceCountingGC objA = new ReferenceCountingGC();</div><div class="line">ReferenceCountingGC objB = new ReferenceCountingGC();</div><div class="line">objA.<span class="attribute">instance</span>=objB;</div><div class="line">objB.<span class="attribute">instance</span>=objA;</div><div class="line"></div><div class="line"><span class="attribute">objA</span>=<span class="literal">null</span>;</div><div class="line"><span class="attribute">objB</span>=<span class="literal">null</span>;</div></pre></td></tr></table></figure></p><h2 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h2><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，说明该对象是不可用的。<br><strong>可作为GC Roots的对象为：</strong><br>①虚拟机栈中引用的对象<br>②方法区中类静态属性引用的对象<br>③方法区中常量引用的对象<br>④本地方法栈中Native方法引用的对象  </p><h2 id="3、引用"><a href="#3、引用" class="headerlink" title="3、引用"></a>3、引用</h2><p><strong>强引用（Strong Reference）</strong>：指在程序代码中普遍存在的，类似A a = new A()这样的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。<br><strong>软引用（Soft Reference）</strong>：用来描述一些还有用但并非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。<br><strong>弱引用（Weak Reference）</strong>：用来描述非必需对象的，但是它的强度比软引用更弱一些，被软引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被软引用关联的对象。<br><strong>虚引用（Phantom Reference）</strong>：称为幽灵引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。对一个对象设置虚引用关联的唯一目的是用来跟踪对象被垃圾回收的状态。  </p><h2 id="4、finalize自救"><a href="#4、finalize自救" class="headerlink" title="4、finalize自救"></a>4、finalize自救</h2><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象死亡，需要经历两次标记过程：<br>1、如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize方法。当对象没有覆盖finalize方法，或者finalize方法已经被虚拟机调用过，虚拟机将这两种情况视为“没有必要执行”，这时对象宣告死亡。<br>2、如果对象被判定有必要执行finalize，那么该对象会放置在一个F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC会对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize()中成功拯救自己——只要重新与引用链的任何一个对象建立连接即可，譬如把自己（this）赋值给某个类变量或者对象的成员变量，那么第二次标记时它将被移除“即将回收”的集合；否则，它就会被真的回收了。<br>注意：任何一个对象的finalize方法都只会被系统自动调用一次。  </p><h1 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h1><h2 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h2><p>分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br>有两点不足之处：<br>①一个是效率问题，标记和清除两个过程的效率都不高；<br>②另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  </p><h2 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h2><h3 id="①普通的复制算法"><a href="#①普通的复制算法" class="headerlink" title="①普通的复制算法"></a>①普通的复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存一次清理掉。<br>这样每次都是对整个半区进行内存回收，不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br>代价：内存使用率只有原来的一半。  </p><h3 id="②改进的复制算法"><a href="#②改进的复制算法" class="headerlink" title="②改进的复制算法"></a>②改进的复制算法</h3><p>不是按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间。在回收时，会把Eden和其中一个Survivor中还存活的对象一次性放到另一个空的Survivor中，然后清除之前的Eden和第一个Survivor。为了区分，一般称第一个为From Survivor，第二个为To Survivor。他们的比例为8:1:1，只会浪费10%的空间。<br>内存担保：有可能存活的对象大于10%，一个Survivor放不下，这时需要有其他内存来作担保，这里会以老年代作为担保。如果放不下，那么通过分配担保机制直接进入老年代。  </p><h2 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h2><p>老年代没有其他内存给它做担保，所以不能使用复制算法。先标记需要回收的对象，然后把活着的对象向一端进行移动，使他们在物理上连续，然后把边界右侧的内存直接清理掉。<br>没有内存碎片，但是效率会稍微低一点，因为要移动对象。  </p><h2 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h2><p>根据对象存活周期的不同将内存划分为几块，一般把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，根据年代的特点采用最适当的收集算法。<br>在<strong>新生代</strong>中，每次垃圾收集时都有大批对象死去，只有少量存活，选用“复制算法”，只需要付出少量存活对象的复制成本就可以完成收集。<br>而在<strong>老年代</strong>中，对象存活率高、没有额外空间对它进行分配担保，就使用“标记-清除”或者“标记-整理”算法来进行回收。  </p><h1 id="三、新生代、老年代和永久代"><a href="#三、新生代、老年代和永久代" class="headerlink" title="三、新生代、老年代和永久代"></a>三、新生代、老年代和永久代</h1><p>java虚拟机垃圾收集器关注的内存结构如下：<br><img src="http://osrmzp0jr.bkt.clouddn.com/20141107224401036.png" alt="image"><br>堆大小=新生代+老年代，新生代与老年代的比例为1：2，新生代细分为一块较大的Eden空间和两块较小的Survivor空间，分别被命名为from和to。  </p><h2 id="1、新生代"><a href="#1、新生代" class="headerlink" title="1、新生代"></a>1、新生代</h2><p>新创建的对象一般都在新生代中分配内存空间，新生代采用“复制算法”进行垃圾回收，可见上面改进的复制算法。<br>java虚拟机对新生代的垃圾回收称为<strong>Minor GC</strong>，次数比较频繁，每次的回收时间较短。使用虚拟机的-Xmn参数可以指定新生代内存大小。  </p><h2 id="2、老年代"><a href="#2、老年代" class="headerlink" title="2、老年代"></a>2、老年代</h2><p>老年代中的对象一般都是长生命周期对象，对象的存活率比较高。当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到老年代内存中（默认是15岁），当大对象无法在新生代找到足够的连续内存时也会直接在老年代中创建。<br>老年代中使用“标记-清除”或者“标记-整理”算法进行垃圾回收。java虚拟机对老年代的回收称为<strong>MajorGC/Full GC</strong>，次数相对比较少，每次回收的时间也比较长。<br>在新生代中没有足够空间为对象创建分配内存，老年代中内存回收也无法回收到足够的内存空间，并且新生代和老年代都无法扩展时，堆就会产生OutOfMemoryError异常。虚拟机-Xms参数指定最小内存大小，-Xmx参数指定最大内存大小，与新生代大小参数-Xmn之差可计算出老年代最小和最大容量。  </p><h2 id="3、永久代"><a href="#3、永久代" class="headerlink" title="3、永久代"></a>3、永久代</h2><p>永久代指的是虚拟机内存中的方法区，被各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。永久代垃圾回收比较少，效率也比较低，但也必须进行垃圾回收，否则永久代内存不够用时仍然会抛出OutOfMemoryError异常。永久代也使用“标记-清除”或者“标记-整理”算法进行垃圾回收。虚拟机参数-XX：PermSize和-XX：MaxPermSize可以设置永久代的初始大小和最大容量。  </p>]]></content>
      
      <categories>
          
          <category> 深入理解Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的异常和处理</title>
      <link href="/2017/10/09/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86/"/>
      <url>/2017/10/09/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>程序运行时，发生超出预期的事件，阻止了程序按照程序员的预期正常执行，这就是异常。Java中的解决方法为<strong>异常处理机制</strong>。<br>异常处理机制能让程序在异常发生时，按照代码预先设定的异常处理逻辑，针对性的处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。<br>java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw关键字手动抛出的，只要程序中产生了异常，就会用一个对应类型的异常对象来封装异常，jre就会试图寻找异常处理程序来处理异常。<br>Throwable类是Java异常类型的顶层父类，一个对象只有是Throwable类的实例，他才是一个异常对象，才能被异常处理机制识别。jdk中内置了一些常用的异常类，同时程序员自己也可以自定义异常。  </p><h1 id="java异常的分类和类结构图"><a href="#java异常的分类和类结构图" class="headerlink" title="java异常的分类和类结构图"></a>java异常的分类和类结构图</h1><p>Throwable类是顶层父类，Throwable类派生出Error类和Exception类。<br><strong>错误</strong>：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。<br><strong>异常</strong>：Exception以及它的子类，代表程序运行时发送的各种不期望发生的事件。<strong>可以被java异常处理机制使用，是异常处理的核心</strong>。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.jpg" alt="image"><br>根据javac对异常的处理要求，将异常类分为2类：<br><strong>非检查异常（unchecked exception）</strong>：Error和RuntimeException以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序中处理这些异常。对于这样的异常，我们可以编写代码处理（try…catch…finally），也可以不处理。对于这些异常，我们要做的应该是修正代码，而不是去通过异常处理器处理。这样的异常多半是代码编写的问题。如除0错误ArithmeticException，错误的类型强转错误ClassCastException，数组越界错误ArrayIndexOutOfBoundsException，空指针错误NullPointerException等等。<br><strong>检查异常（checked exception）</strong>：除了Error和RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（try…catch…finally）。在方法中，<strong>要么通过try-catch语句捕获异常并处理，要么用throws子句声明交给函数调用者去解决</strong>，否则编译不会通过。这种异常一般由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，但是程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着，如SQLException，IOException，ClassNotFoundException，FileNotFoundException等等。<br>这里的检查与非检查是针对javac而言的。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>（转）Java中锁概念总结</title>
      <link href="/2017/09/30/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E4%B8%AD%E9%94%81%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
      <url>/2017/09/30/%EF%BC%88%E8%BD%AC%EF%BC%89Java%E4%B8%AD%E9%94%81%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://www.jianshu.com/p/4a8415140406" target="_blank" rel="external">http://www.jianshu.com/p/4a8415140406</a></p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p><strong>公平锁</strong>：多个线程申请获取同一个锁，按照线程的申请顺序，排队获取锁。公平锁的好处是等待的线程不会被饿死，相应的缺陷就是整体吞吐量很低、效率很低。使用new ReentrantLock(true)可以构造一个公平锁。<br><strong>非公平锁</strong>：多个线程申请获取同一个锁，获取锁的顺序不按照申请顺序，抢占式的获取。非公平锁的好处是整体效率很高，但是可能会使有些线程一致在等待，造成饿死。使用Synchronized、new ReentrantLock()和new ReentrantLock(false)可以构建一个非公平锁。  </p><h2 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h2><p><strong>共享锁</strong>：简单的理解就是锁可以被多个线程持有。在实际使用过程中，线程A获取到了共享资源D的共享锁，其它线程只能获取D的共享锁，不能获取独占锁。<br><strong>独占锁</strong>：一次只能有一个线程获得锁，即只能被一个线程持有。在实际使用过程中，线程A获取到了共享资源D的独占锁，其它线程不能获取D的任何类型锁。  </p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong>读写锁</strong>一次只有一个线程（writer线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader线程）。Java中的读写锁通过ReentrantReadWriteLock实现。ReentrantReadWriteLock.ReadLock是读锁，它是共享锁。ReentrantReadWriteLock.WriteLock是写锁，它是独占锁。  </p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p><strong>互斥锁</strong>即一次只能有一个线程持有的锁。ReentrantLock和synchronized都是互斥锁。  </p><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p><strong>悲观锁</strong>认为对同一数据的并发操作一定会出现冲突问题，所以，在对数据操作之前一定要加锁。Java编码中悲观锁的实现有很多种，for update就是一种。<br><strong>乐观锁</strong>认为对同一数据的并发操作不会出现冲突问题，数据操作不加锁，会在操作提交时检查数据的完整性。Java中常用的乐观锁方式有版本号、时间戳。  </p><h2 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h2><p><strong>偏向锁</strong>：对于一段同步代码来说，锁偏向于第一次获取它的线程，如果继续执行的过程中，锁没有被其它线程持有，则持有偏向锁的线程将不需要同步，自动获取锁。<br><strong>轻量级锁</strong>：当偏向锁被另一个线程持有的时候，偏向锁升级为轻量级锁，其它线程通过自旋转的方式尝试获取锁。<br><strong>重量级锁</strong>：当轻量级锁被另一个线程持有的时候，轻量级锁升级为重量级锁。  </p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>Java线程在得不到锁时不会立即阻塞，而是执行一个循环，不断的去尝试获取锁，这种技术就是<strong>自旋锁</strong>。它可以减少在获取锁的过程中，因为线程上下文的切换而导致的额外消耗。  </p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p><strong>可重入锁</strong>，也称为递归锁，即线程在获取到某方法的锁之后，如果在该方法内部调用其它方法，这个方法也需要获取锁，那么进入这个方法将自动获取锁，它可以在一定程度上避免死锁。  </p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java多线程之锁优化策略</title>
      <link href="/2017/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/"/>
      <url>/2017/09/30/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h1 id="一、编码过程中可采取的锁优化的思路："><a href="#一、编码过程中可采取的锁优化的思路：" class="headerlink" title="一、编码过程中可采取的锁优化的思路："></a>一、编码过程中可采取的锁优化的思路：</h1><h2 id="1、减少锁持有时间"><a href="#1、减少锁持有时间" class="headerlink" title="1、减少锁持有时间"></a>1、减少锁持有时间</h2><p>如：对一个方法加锁，不如对方法中需要同步的几行代码加锁。  </p><h2 id="2、减小锁粒度"><a href="#2、减小锁粒度" class="headerlink" title="2、减小锁粒度"></a>2、减小锁粒度</h2><p>如：jdk1.6中，  ConcurrentHashMap中采取对segement加锁而不是整个map加锁，提高并发性。类似数据库中的行锁对表锁的优势。  </p><h2 id="3、锁分离"><a href="#3、锁分离" class="headerlink" title="3、锁分离"></a>3、锁分离</h2><p>根据同步操作的性质，把锁划分为读锁和写锁，读锁之间不互斥，提高了并发性。  </p><h2 id="4、锁粗化"><a href="#4、锁粗化" class="headerlink" title="4、锁粗化"></a>4、锁粗化</h2><p>在一个间隔性需要执行同步语句的线程中，如果在不连续的同步块间频繁加锁解锁是很耗性能的，因此把加锁范围扩大，把这些不连续的同步语句进行一次性加锁解锁。虽然线程持有锁的时间增加了，但是总体还是优化了的。  </p><h2 id="5、锁消除"><a href="#5、锁消除" class="headerlink" title="5、锁消除"></a>5、锁消除</h2><p>锁消除是编译器做的事：根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸当前线程（即不会影响线程外的数据），那么可以认为这段代码是线程安全的，不需要加锁。  </p><h1 id="二、Java虚拟机中采用的锁优化策略："><a href="#二、Java虚拟机中采用的锁优化策略：" class="headerlink" title="二、Java虚拟机中采用的锁优化策略："></a>二、Java虚拟机中采用的锁优化策略：</h1><p>主要包括偏向锁、轻量级锁和自旋锁。其中，<a href="http://xiaonanbobo.com/2017/08/13/synchronized的实现原理及锁的升级/" target="_blank" rel="external">偏向锁、轻量级锁及重量锁及其膨胀过程在之前博客中有了详细描述，</a>在这篇文章，我主要介绍下自旋锁。  </p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>如果当线程申请锁时，发现锁被占用，就让当前线程执行忙循环（自旋），观察持有锁的线程是否会很快释放锁。如果自旋后还没获得锁，才进入同步阻塞状态。  </p><h3 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h3><p>自旋的线程的自旋时间为在同一个锁上，上一次线程自旋并获得锁的耗时。如果对于这个锁，自旋很少成功，就不自旋了，避免浪费CPU资源。 </p><p>&emsp;<strong>为了尽量避免使用重量级锁，JVM首先会尝试轻量级锁，轻量级锁尝试使用CAS操作来获取锁，如果轻量级锁获取失败，说明存在竞争，但是可能很快就能获得锁，就会尝试自旋锁，将线程做几个空循环，每一次循环都不断尝试获得锁。如果自旋锁也失败，那么只能升级为重量级锁。</strong></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>26、复杂链表的复制</title>
      <link href="/2017/09/29/26%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/09/29/26%E3%80%81%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>&emsp;输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head  </p><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><p>1、复制链表<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170929192000.jpg" alt="image"><br>2、复制random<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170929192011.jpg" alt="image"><br>3、拆分链表<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170929192006.jpg" alt="image">  </p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">public class RandomListNode &#123;</div><div class="line">    int label;</div><div class="line">    RandomListNode next = null;</div><div class="line">    RandomListNode random = null;</div><div class="line"></div><div class="line">    RandomListNode(int label) &#123;</div><div class="line">        this.label = label;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</div><div class="line">    <span class="keyword">public</span> RandomListNode Clone(RandomListNode pHead)</div><div class="line">    &#123;</div><div class="line">        RandomListNode pCur=pHead;</div><div class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//第一步，复制链表  A-&gt;B-&gt;C变为A-&gt;A'-&gt;B-&gt;B'-&gt;C-&gt;C'</span></div><div class="line">        <span class="keyword">while</span>(pCur!=<span class="keyword">null</span>)&#123;</div><div class="line">            RandomListNode node=<span class="keyword">new</span> RandomListNode(pCur.label);</div><div class="line">            node.<span class="keyword">next</span>=pCur.<span class="keyword">next</span>;</div><div class="line">            pCur.<span class="keyword">next</span>=node;</div><div class="line">            pCur=node.<span class="keyword">next</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//第二步，复制random</span></div><div class="line">        pCur=pHead;</div><div class="line">        <span class="keyword">while</span>(pCur!=<span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(pCur.random!=<span class="keyword">null</span>)</div><div class="line">                pCur.<span class="keyword">next</span>.random=pCur.random.<span class="keyword">next</span>;</div><div class="line">            pCur=pCur.<span class="keyword">next</span>.<span class="keyword">next</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//第三步，拆分链表</span></div><div class="line">        pCur=pHead;</div><div class="line">        RandomListNode cur=pHead.<span class="keyword">next</span>;</div><div class="line">        RandomListNode pNode=cur;</div><div class="line">        <span class="keyword">while</span>(pCur!=<span class="keyword">null</span>)&#123;</div><div class="line">            pCur.<span class="keyword">next</span>=pCur.<span class="keyword">next</span>.<span class="keyword">next</span>;</div><div class="line">            <span class="keyword">if</span>(cur.<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</div><div class="line">                cur.<span class="keyword">next</span>=cur.<span class="keyword">next</span>.<span class="keyword">next</span>;</div><div class="line">            &#125;</div><div class="line">            pCur=pCur.<span class="keyword">next</span>;</div><div class="line">            cur=cur.<span class="keyword">next</span>;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">return</span> pNode;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>27、二叉搜索树转双向链表</title>
      <link href="/2017/09/29/27%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2017/09/29/27%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>&emsp;输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。  </p><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><p>&emsp;用中序遍历来遍历树中每一个结点，因为中序遍历的特点是按照从小到大的顺序遍历二叉树每个节点。当遍历到根节点10时，它的左子树已经转换成一个排序的链表，并且处在链表最后一个节点的是当前值的最大节点8。我们把值为8的节点和根节点链接起来，此时最后一个节点变为根节点10。接着去遍历转换右子树，并把根节点和右子树中最小的节点连接起来。</p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20170929165150.jpg" alt="image">  </p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TreeNode &#123;</div><div class="line">    <span class="built_in">int</span> val = <span class="number">0</span>;</div><div class="line">    TreeNode <span class="built_in">left</span> = <span class="literal">null</span>;</div><div class="line">    TreeNode <span class="built_in">right</span> = <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> TreeNode(<span class="built_in">int</span> val) &#123;</div><div class="line">        this.val = val;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution &#123;</div><div class="line">    TreeNode leftHead=<span class="literal">null</span>;</div><div class="line">    TreeNode rightHead=<span class="literal">null</span>;</div><div class="line">    <span class="keyword">public</span> TreeNode Convert(TreeNode pRootOfTree) &#123;</div><div class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="literal">null</span>)</div><div class="line">            return <span class="literal">null</span>;</div><div class="line">        Convert(pRootOfTree.<span class="built_in">left</span>);</div><div class="line">        <span class="keyword">if</span>(leftHead==<span class="literal">null</span>)&#123;</div><div class="line">            leftHead=rightHead=pRootOfTree;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            rightHead.<span class="built_in">right</span>=pRootOfTree;</div><div class="line">            pRootOfTree.<span class="built_in">left</span>=rightHead;</div><div class="line">            rightHead=pRootOfTree;</div><div class="line">        &#125;</div><div class="line">        Convert(pRootOfTree.<span class="built_in">right</span>);</div><div class="line">        return leftHead;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>28、字符串的排列</title>
      <link href="/2017/09/29/28%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
      <url>/2017/09/29/28%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
      <content type="html"><![CDATA[<p>&emsp;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。  </p><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><p>1、将第一个字符与后面每个字符交换<br>2、固定第一个字符<br>3、将固定后，后面字符的第一位字符分别与后面每个字符交换<br>以此类推。。。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%9B%9E%E6%BA%AF.png" alt="image">  </p><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">public <span class="keyword">class</span> Solution &#123;</div><div class="line">    public ArrayList&lt;String&gt; Permutation(String str) &#123;</div><div class="line">       ArrayList <span class="keyword">list</span> =new ArrayList();</div><div class="line">        <span class="keyword">if</span>(str!=null &amp;&amp; str.<span class="built_in">length</span>()&gt;0)&#123;</div><div class="line">            PermutationHelper(str.toCharArray(),0,<span class="keyword">list</span>);</div><div class="line">            Collections.<span class="keyword">sort</span>(<span class="keyword">list</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">list</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void PermutationHelper(<span class="keyword">char</span>[] <span class="keyword">cs</span>,int i,ArrayList <span class="keyword">list</span>)&#123;</div><div class="line">        <span class="comment">//结束条件，排到最后一位元素</span></div><div class="line">        <span class="keyword">if</span>(i==<span class="keyword">cs</span>.length-1)&#123;</div><div class="line">            String val=String.valueOf(<span class="keyword">cs</span>);</div><div class="line">            <span class="keyword">if</span>(!<span class="keyword">list</span>.contains(val))</div><div class="line">            <span class="keyword">list</span>.add(val);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">for</span>(int j=i;j&lt;<span class="keyword">cs</span>.length;j++)&#123;</div><div class="line">                swap(<span class="keyword">cs</span>,i,j);<span class="comment">//将第一个字符与后面每个字符交换</span></div><div class="line">                PermutationHelper(<span class="keyword">cs</span>,i+1,<span class="keyword">list</span>);<span class="comment">//将第一位字符固定</span></div><div class="line">                swap(<span class="keyword">cs</span>,i,j);<span class="comment">//第一个字符固定后，之后第一个字符与后面每个字符交换，直至固定后的第一个字符就是最后一个字符</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//两元素的交换</span></div><div class="line">    void swap(<span class="keyword">char</span>[] <span class="keyword">cs</span>,int i,int j)&#123;</div><div class="line">        <span class="keyword">char</span> temp=<span class="keyword">cs</span>[i];</div><div class="line">        <span class="keyword">cs</span>[i]=<span class="keyword">cs</span>[j];</div><div class="line">        <span class="keyword">cs</span>[j]=temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入java虚拟机之类加载机制</title>
      <link href="/2017/08/31/%E6%B7%B1%E5%85%A5java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/08/31/%E6%B7%B1%E5%85%A5java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载。其中类加载的过程包括了<strong>加载、验证、准备、解析和初始化</strong>五个阶段。加载、验证、准备、初始化这四个阶段发生的顺序是确定的，但解析阶段不一定，在某些情况下，解析阶段在初始化之后进行，这时为了支持Java的动态绑定。这几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常会互相交叉的进行，通常在一个阶段的执行过程中调用或激活另一个阶段。  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD1.png" alt="image">  </p><h2 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h2><p><strong>绑定是指把一个方法的调用与方法所在的类关联起来</strong>，分来静态绑定和动态绑定。<br>1、静态绑定<br>即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。对java来说，可以理解为程序编译期的绑定。<strong>Java方法中只有final、static、private和构造方法是前期绑定的。</strong><br>2、动态绑定<br>即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定，在java中，几乎所有的方法都是后期绑定的。  </p><h2 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h2><p>加载是类加载过程的第一个阶段，在这个阶段，虚拟机完成以下3件事情：<br>1、通过一个类的全限定名来获取定义此类的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中各种数据的访问入口。<br>在加载阶段，可控性强，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。  </p><h2 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h2><p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。大致分为四个阶段的验证：<br><strong>1、文件格式的验证</strong>：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过这个阶段的验证后，字节流才会进入内存的方法区进行存储，后面三个验证都是基于方法区的存储结构进行的。<br><strong>2、元数据验证</strong>：对类中的各数据类型进行语法校验，保证不存在不符合Java语言规范的元数据信息。<br><strong>3、字节码验证</strong>：主要目的是通过数据流和控制流分析，对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。<br><strong>4、符号引用验证</strong>：发生在虚拟机将符号引用转化为直接引用的时候（解析阶段发生该转化），主要是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。  </p><h2 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h2><p>准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。<br>注意几点：<br>1、仅包括类变量（static修饰），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配到Java堆中。<br>2、这里设置的初始值通常是数据类型默认的零值（如0、0L、null、false等），而不是在java代码中被显式地赋予的值。<br>3、如果变量同时被final和static修饰（常量），类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。  </p><h2 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h2><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。  </p><h3 id="符号引用和直接引用"><a href="#符号引用和直接引用" class="headerlink" title="符号引用和直接引用"></a>符号引用和直接引用</h3><p><strong>符号引用</strong>：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符合引用和虚拟机的内存布局无关，引用的目标并不一定已经加载到内存中。<br><strong>直接引用</strong>：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机的内存布局相关。<br>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。</p><h2 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h2><p>初始化阶段是类加载过程的最后一步，到这个阶段，才真正去执行类中定义的java代码。在准备阶段，类变量（static变量）已经被赋过一次系统要求的初始化值，而在初始化阶段，回去初始化类变量在java代码中定义的值以及其他资源。初始化阶段可理解为执行类构造器&lt;clinit&gt;()方法的过程。  </p><h3 id="lt-clinit-gt-方法的执行规则："><a href="#lt-clinit-gt-方法的执行规则：" class="headerlink" title="&lt;clinit&gt;()方法的执行规则："></a>&lt;clinit&gt;()方法的执行规则：</h3><p><strong>1、&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。</strong><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        i = <span class="number">0</span>;                 <span class="comment">//给变量赋值可以正常编译通过</span></div><div class="line">        System.<span class="keyword">out</span>.println(i); <span class="comment">//编译器会提示“非法向前引用”，不可访问定义在静态语句块之后的变量       </span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>2、&lt;clinit&gt;()方法和类的构造函数（实例构造器&lt;init&gt;()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在虚拟机中第一个被执行的&lt;clinit&gt;()方法的类肯定是Object。<br>3、由于父类的&lt;clinit&gt;()方法会先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。<br>4、&lt;clinit&gt;()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么这个类可以不用生成&lt;clinit&gt;()方法。<br>5、接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，接口和类一样都会生成&lt;clinit&gt;()方法。但接口和类不同的是，执行接口的&lt;clinit&gt;()方法不需要执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量使用时，父接口才会初始化。<br>6、虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中能被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动现场执行&lt;clinit&gt;()方法完毕。</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</div><div class="line">    sttatic&#123;</div><div class="line">        A = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    System.out.println(Sub.B);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&emsp;&emsp;首先在准备阶段为类变量分配内存并设置类变量的初始值，此时A、B的值被赋为默认值0，之后在初始化阶段调用&lt;clinit&gt;()方法给他们赋予程序中指定的值。当我们调用Sub.B时会触发Sub的&lt;clinit&gt;()方法，根据规则2，在此之前，要先执行完其父类Parent的&lt;clinit&gt;()方法；又根据规则1，在执行&lt;clinit&gt;()方法时，需要按static语句或static变量赋值操作在代码中出现的顺序来执行相关的static语句，因此当触发执行Parent的&lt;clinit&gt;()方法时，会先将A赋值为1，再执行static语句块中语句，将A赋值为2；之后执行Sub的&lt;clinit&gt;()方法，这样会将B的赋值为2。  </p><h1 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h1><p>类加载器用于实现类的加载动作。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。也就是说，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。即使两个类来源于同一个Class文件，只要加载她们的类加载器i不同，那这两个类肯定是不同的。  </p><h2 id="1、类加载器的分类"><a href="#1、类加载器的分类" class="headerlink" title="1、类加载器的分类"></a>1、类加载器的分类</h2><p>1、<strong>启动类加载器</strong>：负责加载存放在JDK\jre\lib下（JDK代表jdk安装目录），或是被-Xbootclasspath参数指定的路径中的，并且被虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。<br>2、<strong>扩展类加载器</strong>：负责加载JDK\jre\lib\ext目录下的或是被java.ext.dirs系统变量指定的路径中的所有类库。开发者可以直接使用扩展类加载器。<br>3、<strong>应用程序类加载器</strong>：负责加载用户类路径（ClassPath）上指定的类库。开发者可直接使用这个加载器，<strong>应用程序类加载器也是程序中默认的类加载器</strong>。<br>如果有必要，还可以加入自定义的类加载器。  </p><h2 id="2、双亲委派模型"><a href="#2、双亲委派模型" class="headerlink" title="2、双亲委派模型"></a>2、双亲委派模型</h2><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD2.png" alt="image"><br>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，它们之间的父子关系不是通过继承而来的，而是使用组合关系来复用父加载器中的代码。  </p><h3 id="①双亲委派模型的工作流程"><a href="#①双亲委派模型的工作流程" class="headerlink" title="①双亲委派模型的工作流程"></a>①双亲委派模型的工作流程</h3><p>&emsp;&emsp;<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是这样，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</strong>  </p><h3 id="②双亲委派模型的好处"><a href="#②双亲委派模型的好处" class="headerlink" title="②双亲委派模型的好处"></a>②双亲委派模型的好处</h3><p>&emsp;&emsp;<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</strong> 例如，java.lang.Object类，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各个类加载器环境中都是同一个类。如果没有双亲委派模型，由各个类加载器自行去加载的话，若用户自己编写了一个java.lang.Object类，那系统中将会出现多个不同的Object类，那么Java类型体系中最基本的行为也无法保证。  </p>]]></content>
      
      <categories>
          
          <category> 深入理解Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中的线程池</title>
      <link href="/2017/08/30/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2017/08/30/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h1 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h1><p><strong>1、降低资源消耗</strong><br>通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br><strong>2、提高响应速度</strong><br>当任务到达时，任务可以不需要等到线程创建就能立即执行。<br><strong>3、提高线程的可管理性</strong><br>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。  </p><h1 id="一、线程池的实现原理"><a href="#一、线程池的实现原理" class="headerlink" title="一、线程池的实现原理"></a>一、线程池的实现原理</h1><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%89%AF%E6%9C%AC1.jpg" alt="image"><br><strong>ThreadPoolExecutor执行execute()方法步骤：</strong><br>1、如果当前运行的线程少于corePoolSize，那么创建新的线程来执行任务<br>2、如果运行的线程等于或者多于corePoolSize，那么将任务加入BlockingQueue<br>3、如果BlockingQueue中任务已满，并且当前运行的线程数少于maximumPoolSize，那么创建新的线程来处理任务<br>4、如果当前运行的线程数多于maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectdExecution()方法（饱和策略）<br><img src="http://osrmzp0jr.bkt.clouddn.com/1_%E5%89%AF%E6%9C%AC.jpg" alt="image"><br><strong>线程池中的线程执行任务分两种情况：</strong><br>1、在execute()方法中创建一个线程时，会让这个线程执行当前任务<br>2、这个线程执行完图中1的任务后，会反复从BlockingQueue中获取任务来执行  </p><h1 id="二、线程池的使用"><a href="#二、线程池的使用" class="headerlink" title="二、线程池的使用"></a>二、线程池的使用</h1><h2 id="1、线程池的创建"><a href="#1、线程池的创建" class="headerlink" title="1、线程池的创建"></a>1、线程池的创建</h2><p>new ThreadPoolExecutor(corePoolSize, runnableTaskQueue, maximumPoolSize, handler, keepAliveTime);<br><strong>①corePoolSize（线程池的核心线程数）</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建新线程，等到需要执行的任务数大于线程池的核心线程数时就不再创建。具体可以参考上图<br><strong>②runnableTaskQueue（任务队列）</strong>：用于保存等待执行的任务的阻塞队列。有以下几个阻塞队列：<br>&emsp;1、ArrayBlockingQueue：是一个基于数组结构的<strong>有界阻塞队列</strong>，按先进先出原则对元素进行排序。<br>&emsp;2、LinkedBlockingQueue：一个基于链表结构的<strong>无界阻塞队列</strong>，吞吐量高于有界队列，newFixedThreadPool采用这个队列。<br>&emsp;3、SynchronousQueue：不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，newCachedThreadPool使用这个队列。<br>&emsp;4、PriporityBlockingQueue：一个具有优先级的<strong>无界阻塞队列</strong>。<br><strong>③maximumPoolSize（线程池最大数量）</strong>：线程池允许创建线程的最大数量。如果队列满了，且创建的线程数小于最大线程数，那么线程池会创建新的线程执行任务。<br><strong>④handler（饱和策略）</strong>：当队列和线程池都满了，说明线程池处于饱和状态，采取饱和策略处理提交的任务。有四种策略：<br>&emsp;1、AbortPolicy：终止策略，直接抛出异常（默认采用）<br>&emsp;2、CallerRunsPolicy：调用者运行策略，将某些任务回退给调用者，来降低新任务的流量<br>&emsp;3、DiscardOldestPolicy：抛弃策略，丢弃队列里最近的一个任务，并执行当前任务<br>&emsp;4、DiscardPolicy：抛弃最旧的策略，不处理，丢弃掉<br><strong>⑤keepAliveTime（线程活动保持的时间）</strong>：线程池的工作线程空闲后，保持存活的时间。  </p><h2 id="2、线程池的关闭"><a href="#2、线程池的关闭" class="headerlink" title="2、线程池的关闭"></a>2、线程池的关闭</h2><p>可以通过shutdown或者shutdownNow方法来关闭线程池。原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程。但也存在一些区别：<br>shutdownNow：首先将线程池的状态设置为STOP，然后尝试<strong>停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表</strong>。<br>shutdown：将线程池的状态设置为SHUTDOWN状态，然后<strong>中断所有没有正在执行任务的线程</strong>。  </p><h2 id="3、合理配置线程池"><a href="#3、合理配置线程池" class="headerlink" title="3、合理配置线程池"></a>3、合理配置线程池</h2><p>从下面几个角度分析：<br>1、任务的性质：CPU密集型任务、IO密集型任务和混合型任务。<br>2、任务的优先级：高、中、低<br>3、任务的执行时间：长、中、短<br>4、任务的依赖性：是否依赖其他系统资源，比如数据库连接<br>如果<strong>任务是CPU密集型的，应配置尽可能少的线程</strong>，如等于可用的处理器核数，这样就可以充分利用处理器，让它以最大火力不停进行计算。创建更多的线程反而是不利的，因为多个线程频繁进行上下文切换对性能消耗太大。<br>如果<strong>任务是IO密集型的，应尽可能配置多的线程</strong>，如处理器核数的几倍。因为在执行IO操作时，线程将被阻塞，此时处理器可以立即进行上下文切换以便其他线程开始任务。如果线程数不够，那么有待执行的任务也无法调度处理了。<br>可以使用公式计算出程序所需线程数：<strong>线程数=CPU可用核心数/(1-阻塞系数)</strong>，其中阻塞系数在0到1范围内。CPU密集型的阻塞系数为0，IO密集型的阻塞系数接近1。  </p><h1 id="三、线程池的本质"><a href="#三、线程池的本质" class="headerlink" title="三、线程池的本质"></a>三、线程池的本质</h1><p><strong>线程池的本质是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行，典型的生产者-消费者模型。</strong></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cglib动态代理</title>
      <link href="/2017/08/25/cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2017/08/25/cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="一、cglib实现动态代理步骤"><a href="#一、cglib实现动态代理步骤" class="headerlink" title="一、cglib实现动态代理步骤"></a>一、cglib实现动态代理步骤</h1><p>使用cglib实现动态代理，并不要求委托类必须实现接口，底层使用asm字节码生成框架生成代理类的字节码。  </p><h2 id="1、定义业务逻辑"><a href="#1、定义业务逻辑" class="headerlink" title="1、定义业务逻辑"></a>1、定义业务逻辑</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span>&#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</div><div class="line">        System.ou.println(<span class="string">"This is add service"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2、实现MethodInterceptor接口，定义方法的拦截器"><a href="#2、实现MethodInterceptor接口，定义方法的拦截器" class="headerlink" title="2、实现MethodInterceptor接口，定义方法的拦截器"></a>2、实现MethodInterceptor接口，定义方法的拦截器</h2><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>&#123;</span></div><div class="line">    <span class="keyword">public</span> Object intercept(Object obj, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">arg</span>, <span class="title">MethodProxy</span> <span class="title">proxy</span>)<span class="title">throws</span> <span class="title">Throwable</span>&#123;</span></div><div class="line">        System.ou.println(<span class="string">"Before:"</span> + <span class="function"><span class="keyword">method</span>);</span></div><div class="line">        Object object = proxy.invokeSuper(obj, arg);</div><div class="line">        System.ou.println(<span class="string">"After:"</span> + <span class="function"><span class="keyword">method</span>);</span></div><div class="line">        <span class="keyword">return</span> object;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3、使用Enhancer类生成代理类"><a href="#3、使用Enhancer类生成代理类" class="headerlink" title="3、使用Enhancer类生成代理类"></a>3、使用Enhancer类生成代理类</h2><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">Enhancer</span> enhancer = <span class="function"><span class="keyword">new</span> <span class="title">Enhancer</span>();</span></div><div class="line"><span class="title">enhancer</span>.<span class="title">setSuperClass</span>(<span class="type">UserService</span>.class);</div><div class="line"><span class="title">enhancer</span>.<span class="title">setCallback</span>(new <span class="type">MyMethodInterceptor</span>());</div><div class="line"><span class="title">UserService</span> <span class="title">userService</span> = (<span class="type">UserService</span>)<span class="title">enhancer</span>.<span class="title">create</span>();</div></pre></td></tr></table></figure><h2 id="4、userService-add-的执行结果"><a href="#4、userService-add-的执行结果" class="headerlink" title="4、userService.add()的执行结果"></a>4、userService.add()的执行结果</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Before: <span class="builtin-name">add</span></div><div class="line">This is <span class="builtin-name">add</span><span class="built_in"> service</span></div><div class="line">After: add</div></pre></td></tr></table></figure><h1 id="二、cglib字节码生成"><a href="#二、cglib字节码生成" class="headerlink" title="二、cglib字节码生成"></a>二、cglib字节码生成</h1><p><strong>Enhancer</strong>是cglib字节码增强器，可以方便的对类进行扩展，<strong>内部调用GeneratorStrategy.generate方法生成代理类的字节码</strong><br>内部实现：<br><strong>1、代理类UserService$$EnhancerByCGLIB$$394dddeb继承了委托类UserService，且委托类的final方法不能被代理；<br>2、代理类为每个委托方法都生成两个方法，以add方法为例，一个是重写的add方法，一个是CGLIB$add$0方法，该方法直接调用委托类的add方法；<br>3、当执行代理对象的add方法时，会先判断是否存在实现了MethodInterceptor接口的对象cglib$CALLBACK_0（也就是这里的MyMethodInterceptor），如果存在，那么调用MethodInterceptor对象的intercept方法</strong><br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Object intercept(Object obj, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">arg</span>, <span class="title">MethodProxy</span> <span class="title">proxy</span>)<span class="title">throws</span> <span class="title">Throwable</span>&#123;</span></div><div class="line">    System.ou.println(<span class="string">"Before:"</span> + <span class="function"><span class="keyword">method</span>);</span></div><div class="line">    Object object = proxy.invokeSuper(obj, arg);//最终调用的委托类中的<span class="function"><span class="keyword">method</span>方法</span></div><div class="line">    System.ou.println(<span class="string">"After:"</span> + <span class="function"><span class="keyword">method</span>);</span></div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>参数分别是：①代理对象；②委托类方法；③方法参数；④代理方法的MethodProxy对象<br><strong>4、每个被代理的方法都对应一个MethodProxy对象，methodProxy.invokeSuper最终调用的是委托类的add方法</strong>，实现如下：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public Object invokeSuper(Object obj, Object[] args)throws Throwable&#123;</div><div class="line">    try&#123;</div><div class="line">        init();</div><div class="line">        FastClassInfo fci = fastClassInfo;</div><div class="line">        //fci.f2:代理类对象</div><div class="line">        //fci.i2:方法CGLIB$<span class="keyword">add</span><span class="bash"><span class="variable">$0</span>在对象中的索引位置</span></div><div class="line">        return fci.f2.invoke(fci.i2, obj, args);//调用代理类对象的CGLIB$<span class="keyword">add</span><span class="bash"><span class="variable">$0</span>方法，CGLIB<span class="variable">$add</span><span class="variable">$0</span>方法又直接调用委托类的add方法</span></div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在MethodProxy实现中，通过FastClassInfo维护了委托类和代理类的FastClass：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassInfo</span>&#123;</span></div><div class="line">    FastClass f1;<span class="comment">//指向委托类对象</span></div><div class="line">    FastClass f2;<span class="comment">//指向代理类对象</span></div><div class="line">    <span class="keyword">int</span> i1;<span class="comment">//方法add在对象中的索引位置</span></div><div class="line">    <span class="keyword">int</span> i2;<span class="comment">//方法CGLIB$add$0在对象中的索引位置</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>FastClass提出概念下标index，通过索引来保存方法的引用信息，将原先的反射调用，转化为方法的直接调用，从而实现fast。当调用methodProxy.invokeSuper方法时，实际上是调用代理类的CGLIB$add$0方法，CGLIB$add$0方法又直接调用委托类的add方法，避免了使用反射机制来调用委托类的方法。</strong>  </p><h1 id="三、jdk和cglib动态代理的区别"><a href="#三、jdk和cglib动态代理的区别" class="headerlink" title="三、jdk和cglib动态代理的区别"></a>三、jdk和cglib动态代理的区别</h1><p>1、jdk动态代理生成的代理类和委托类必须实现相同的接口；cglib动态代理则不需要。<br>2、cglib动态代理中，生成的代理类是委托类的子类，且不能处理被final关键字修饰的方法；<br>3、jdk采用反射机制来调用委托类的方法，cglib采用类似索引的方式直接调用委托类的方法。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java，java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK动态代理</title>
      <link href="/2017/08/25/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2017/08/25/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h1><p><img src="http://osrmzp0jr.bkt.clouddn.com/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86.png" alt="image"><br>1、RealSubject是委托类，Proxy是代理类<br>2、Subject是委托类和代理类的接口<br>3、request()是委托类和代理类的共同方法<br>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//委托类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"RealSubject"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//代理类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Subject subject;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.subject = subject;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"start"</span>);<span class="comment">//前置通知</span></div><div class="line">        subject.request();</div><div class="line">        System.out.println(<span class="string">"stop"</span>);<span class="comment">//后置处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        RealSubject subject = <span class="keyword">new</span> RealSubject();</div><div class="line">        Proxy p = <span class="keyword">new</span> Proxy(subject);<span class="comment">//代理类要传入委托类作为参数</span></div><div class="line">        p.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>静态代理</strong>实现中，一个委托类对应一个代理类，<strong>代理类在编译期间就已经确定了</strong>。</p><h1 id="二、动态代理"><a href="#二、动态代理" class="headerlink" title="二、动态代理"></a>二、动态代理</h1><p>动态代理中，必须让代理类和目标类实现相同的接口，客户端通过代理类来调用目标类的方法，<strong>代理类会将所有的方法调用分派到目标对象上反射执行</strong>，在分派的过程中，还可以添加“前置通知”和“后置处理”（如在调用目标方法前校验权限，在调用完目标方法后打印日志等）等功能。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E4%BB%A3%E7%90%86.png" alt="image"><br>相比于静态代理，<strong>动态代理不需要编写各个繁琐的静态代理类</strong>，只需要简单地指定一组接口及目标类对象就可以动态的获得代理对象了。  </p><h2 id="1、定义业务逻辑"><a href="#1、定义业务逻辑" class="headerlink" title="1、定义业务逻辑"></a>1、定义业务逻辑</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Service</span></span>&#123;</div><div class="line">    <span class="comment">//目标方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//委托类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">Service</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"This is add service"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2、利用java-lang-reflect-Proxy类和java-lang-reflect-InvocationHandler接口定义代理类的实现"><a href="#2、利用java-lang-reflect-Proxy类和java-lang-reflect-InvocationHandler接口定义代理类的实现" class="headerlink" title="2、利用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口定义代理类的实现"></a>2、利用java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口定义代理类的实现</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Object <span class="keyword">target</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object <span class="keyword">target</span>)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        System.out.println(<span class="string">"------before--------"</span>);</div><div class="line">        Object result = method.invoke(<span class="keyword">target</span>,args);<span class="comment">//调用target的method方法，参数为args</span></div><div class="line">        System.out.println(<span class="string">"------end--------"</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//生成代理对象</span></div><div class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">        Class&lt;?&gt;[] interfaces = <span class="keyword">target</span>.getClass().getInterfaces();</div><div class="line">        <span class="function"><span class="keyword">return</span> Proxy.<span class="title">newProxyInstance</span><span class="params">(loader, interfaces, <span class="keyword">this</span>)</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3、使用动态代理"><a href="#3、使用动态代理" class="headerlink" title="3、使用动态代理"></a>3、使用动态代理</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ProxyTest&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">       <span class="built_in"> Service service </span>= new UserServiceImpl();</div><div class="line">        MyInvocationHandler handler = new MyInvocationHandler(service);</div><div class="line">       <span class="built_in"> Service </span>serviceProxy = (Service)handler.getProxy();</div><div class="line">        serviceProxy.<span class="builtin-name">add</span>();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">------before--------</div><div class="line">This is <span class="builtin-name">add</span><span class="built_in"> service</span></div><div class="line">------end--------</div></pre></td></tr></table></figure></p><p>代理对象的生成过程由<strong>Proxy类的newProxyInstance方法</strong>实现，分为三个步骤：<br><strong>①ProxyGenerator.generateProxyClass方法负责生成代理类的字节码</strong><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//proxyName：格式如"com.sun.proxy.$Proxy.1"</span></div><div class="line"><span class="comment">//interfaces：代理类需要实现的接口数组</span></div><div class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</div></pre></td></tr></table></figure></p><p><strong>②native方法Proxy.defineClass0负责字节码加载的实现，并返回对应的Class对象</strong><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Class clazz</span> = defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);</div></pre></td></tr></table></figure></p><p><strong>③使用clazz.newInstance反射机制生成代理类对象</strong>  </p><h3 id="内部实现："><a href="#内部实现：" class="headerlink" title="内部实现："></a>内部实现：</h3><p><strong>1、生成的代理类$Proxy1继承自Proxy类，并且实现了Service接口<br>2、执行代理对象的方法serviceProxy.add()，其实就是执行InvocationHandler对象的invoke方法</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m, <span class="keyword">null</span>);<span class="comment">//传入的参数分别是当前代理对象、当前执行的方法和参数</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="InvocationHandler的作用"><a href="#InvocationHandler的作用" class="headerlink" title="InvocationHandler的作用"></a>InvocationHandler的作用</h3><p><strong>在动态代理中，InvocationHandler是核心，每个代理实例都有一个关联的调用处理程序（InvocationHandler）。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的InvocationHandler的invoke()方法。所以对代理方法的调用，内部都是通过InvocationHandler的invoke()实现的，invoke()根据传入的当前代理对象、当前执行的方法和参数来决定调用委托类的哪个方法。</strong></p><h2 id="jdk动态代理的局限性"><a href="#jdk动态代理的局限性" class="headerlink" title="jdk动态代理的局限性"></a>jdk动态代理的局限性</h2><p>通过反射类Proxy和InvocationHandler回调接口实现的jdk动态代理，<strong>要求委托类必须实现一个接口</strong>，但其实并不是每个类都有接口，对于没有实现接口的类，就无法使用这种方式实现动态代理。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java，java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2017/08/24/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/08/24/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="一、反射技术简介及获取Class对象"><a href="#一、反射技术简介及获取Class对象" class="headerlink" title="一、反射技术简介及获取Class对象"></a>一、反射技术简介及获取Class对象</h1><p><strong>反射技术是指动态的获取指定的类，以及动态的调用类中的内容。</strong><br>要想获取字节码文件的成员，就必须先获取到字节码文件对象（Class对象）。<br><strong>Class对象：虚拟机在class文件的加载阶段，把类信息保存在方法区的数据结构中，并在Java堆中生成一个Class对象，作为类信息的入口</strong>。<br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%8F%8D%E5%B0%84.png" alt="image"><br>介绍三种获取字节码文件对象的方式：<br>首先声明一个Person类  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></div><div class="line">    <span class="comment">//字段</span></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    </div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    Person()&#123; ... &#125;</div><div class="line">    Person(String name, <span class="keyword">int</span> age)&#123; ... &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123; ... &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticShow</span><span class="params">()</span></span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="1、通过实例变量的方式"><a href="#1、通过实例变量的方式" class="headerlink" title="1、通过实例变量的方式"></a>1、通过实例变量的方式</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Person person</span> = new Person();</div><div class="line"><span class="attribute">Class clazz</span> = person.getClass();</div></pre></td></tr></table></figure><p>使用Object类中的getClass方法，是通用的，但前提是必须有指定类，并对该类进行对象的创建，才能调用getClass方法。  </p><h2 id="2、通过类名的方式"><a href="#2、通过类名的方式" class="headerlink" title="2、通过类名的方式"></a>2、通过类名的方式</h2><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Class</span> clazz = Person.<span class="keyword">class</span></div></pre></td></tr></table></figure><p>不用new对象，但还是需要使用具体的类。这种方式，只会加载Person类，但不会触发它的类构造器来初始化。    </p><h2 id="3、通过Class类中的forName-String-className-的方式"><a href="#3、通过Class类中的forName-String-className-的方式" class="headerlink" title="3、通过Class类中的forName(String className)的方式"></a>3、通过Class类中的forName(String className)的方式</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">String</span> classNmae = <span class="string">"cn.wunian.domian.Person"</span>;<span class="comment">//要用全限定名</span></div><div class="line">Class clazz = Class.forName(className);</div><div class="line"><span class="comment">//通过newInstance()方法就可以创建字节码文件对象所表示的类的实例</span></div><div class="line">Object obj = clazz.<span class="keyword">new</span><span class="type">Instance</span>();<span class="comment">//创建字节码文件对象所表示的类的一个实例</span></div></pre></td></tr></table></figure><p><strong>这种方式是反射技术所使用的获取字节码文件对象的方式。只需要知道类的名字就可以了，获取对应的字节码文件等由forName方法自动完成。</strong>  </p><p>总结下，主要分为三个步骤：<br><strong>①通过给定的类名称，加载对应的字节码文件，并封装成字节码文件对象Class<br>②通过newInstance创建字节码文件对象所表示的类的实例<br>③调用该类的构造函数来进行初始化</strong>  </p><h1 id="二、反射机制"><a href="#二、反射机制" class="headerlink" title="二、反射机制"></a>二、反射机制</h1><p>反射机制可以在<strong>运行期间获取类的字段、方法、父类和接口</strong>等信息。  </p><h2 id="1、获取构造函数"><a href="#1、获取构造函数" class="headerlink" title="1、获取构造函数"></a>1、获取构造函数</h2><p>通常被反射的类都会提供空参数的构造函数。如果没有对应的构造函数，会报InstantiationException；如果有提供，但访问权限不够，会报IllegalAccessException。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用带参的构造器来初始化对象</span></div><div class="line"><span class="built_in">String</span> className = <span class="string">"cn.wunian.domain.Person"</span>;</div><div class="line">Class clazz = Class.forName(className);</div><div class="line">Constructer constructer = clazz.getConstructer(<span class="built_in">String</span>.calss, <span class="built_in">int</span>.<span class="keyword">class</span>);</div><div class="line"><span class="comment">//通过构造器对象来初始化对象</span></div><div class="line"><span class="built_in">Object</span> obj = constructer.newInstance(<span class="string">"xubo"</span>, <span class="number">24</span>);</div></pre></td></tr></table></figure></p><p>使用此Constructer对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数来初始化该实例。  </p><h2 id="2、获取字段"><a href="#2、获取字段" class="headerlink" title="2、获取字段"></a>2、获取字段</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">String</span> className = <span class="string">"cn.wunian.domain.Person"</span>;</div><div class="line">Class clazz = Class.forName(className);</div><div class="line"><span class="keyword">String</span> fieldName = <span class="string">"age"</span>;</div><div class="line">Object obj = clazz.<span class="keyword">new</span><span class="type">Instance</span>();</div><div class="line"><span class="comment">//获取字段对象</span></div><div class="line">Field field = clazz.getDeclaredField(fieldName);</div><div class="line"><span class="comment">//取消访问检查</span></div><div class="line">field.setAccessible(<span class="literal">true</span>);</div><div class="line"><span class="comment">//设置字段值</span></div><div class="line">field.<span class="keyword">set</span>(obj, <span class="number">30</span>);<span class="comment">//将指定对象变量上此Field对象表示的字段设置为指定的新值</span></div><div class="line"><span class="comment">//返回指定对象上此Field字段的值</span></div><div class="line">System.out.println(field.<span class="keyword">get</span>(obj));</div></pre></td></tr></table></figure><h2 id="3、获取方法"><a href="#3、获取方法" class="headerlink" title="3、获取方法"></a>3、获取方法</h2><p>用到的两个方法：<br>①返回一个Method对象，它反映此Class对象所表示的类或接口指定的名为methodName的公共成员方法<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Class</span>.getMethod(String methodName, <span class="keyword">class</span>&lt;?&gt;.<span class="built_in">..parameterTypes</span>)</div><div class="line">methodName：方法名  </div><div class="line">parameterTypes：参数列表所属的类型</div></pre></td></tr></table></figure></p><p>②对带有指定参数（parameterTypes）的指定对象（obj）调用由此Method对象表示的底层方法（上面的methodName代表的方法）<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Method</span>.<span class="title">invoke</span><span class="params">(Object obj, Object...args)</span></span></div><div class="line"><span class="title">obj</span>：调用底层方法的对象  </div><div class="line"><span class="title">args</span>：用于方法调用的参数</div></pre></td></tr></table></figure></p><h3 id="①获取带有参数的方法"><a href="#①获取带有参数的方法" class="headerlink" title="①获取带有参数的方法"></a>①获取带有参数的方法</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> className = <span class="string">"cn.wunian.domain.Person"</span>;</div><div class="line"><span class="keyword">Class</span> clazz = <span class="keyword">Class</span>.forName(className);</div><div class="line"><span class="built_in">Object</span> obj = clazz.newInstance();</div><div class="line"><span class="built_in">String</span> methodName = <span class="string">"show"</span>;</div><div class="line">Method method = clazz.getMethod(methodName, <span class="built_in">String</span>.<span class="keyword">class</span>, int.<span class="keyword">class</span>);</div><div class="line">method.invoke(obj, <span class="string">"xubo"</span>, <span class="number">24</span>);</div></pre></td></tr></table></figure><h3 id="②获取无参数的方法"><a href="#②获取无参数的方法" class="headerlink" title="②获取无参数的方法"></a>②获取无参数的方法</h3><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String className = <span class="string">"cn.wunian.domain.Person"</span>;</div><div class="line"><span class="class"><span class="keyword">Class</span> <span class="title">clazz</span> = <span class="title">Class</span>.<span class="title">forName</span>(<span class="title">className</span>);</span></div><div class="line">String methodName = <span class="string">"staticShow"</span>;</div><div class="line"><span class="function"><span class="keyword">Method</span> <span class="title">method</span> =</span> clazz.getMethod(methodName, <span class="literal">null</span>);//无参传<span class="literal">null</span></div><div class="line"><span class="function"><span class="keyword">method</span>.<span class="title">invoke</span>(</span><span class="literal">null</span>,<span class="literal">null</span>)//静态方法不需要对象调用，传<span class="literal">null</span></div></pre></td></tr></table></figure><h1 id="三、反射的性能问题"><a href="#三、反射的性能问题" class="headerlink" title="三、反射的性能问题"></a>三、反射的性能问题</h1><p>1、代码的语言访问检查过于复杂，本来这块应该在链接阶段实现的，使用反射时需要在运行时才进行<br>2、运行时进行验证会产生过多的临时对象，影响GC的消耗<br>3、由于缺少上下文，导致不能进行更多的优化<br>现代JVM已经不慢了，能对反射代码进行缓存以及通过方法计数器同样实现JIT优化，所以反射不一定慢，可以大胆使用反射。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2017/08/23/ThreadLocal/"/>
      <url>/2017/08/23/ThreadLocal/</url>
      <content type="html"><![CDATA[<h1 id="一、ThreadLocal简述"><a href="#一、ThreadLocal简述" class="headerlink" title="一、ThreadLocal简述"></a>一、ThreadLocal简述</h1><p><strong>ThreadLocal，又叫线程本地变量，ThreadLocal变量为每个线程都创建了一个副本，每个线程都可以访问自己内部的副本变量，不同线程之间互不干扰。</strong>  </p><h1 id="二、深入解析ThreadLocall类"><a href="#二、深入解析ThreadLocall类" class="headerlink" title="二、深入解析ThreadLocall类"></a>二、深入解析ThreadLocall类</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><strong>从线程Thread的角度来看，每个线程内部都会持有一个对ThreadLocalMap实例的引用threadLocals，而ThreadLocalMap实例相当于线程的局部变量空间。引用threadLocals是用来存储实际的变量副本的，键值（key）是当前的ThreadLocal变量，value为变量副本（即ThreadLocal类型的变量值）。</strong><br><img src="http://osrmzp0jr.bkt.clouddn.com/threadLocal.png" alt="image">  </p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>内部使用table数组来存储Entry，默认的大小为INITIAL_CAPACITY(16)，其中两个参数：<br>1、size：table中元素的数量，其实就是ThreadLocal变量的数量，因为一个ThreadLocal变量对应table数组中的一个Entry。<br>2、threshold：等于table大小的2/3，当size&gt;=threshold时，遍历table并删除key为null的元素；如果删除后size&gt;=threshold的3/4，需要对table进行扩容。  </p><h2 id="ThreadLocal类提供的几个方法"><a href="#ThreadLocal类提供的几个方法" class="headerlink" title="ThreadLocal类提供的几个方法"></a>ThreadLocal类提供的几个方法</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T <span class="keyword">value</span></span>)</span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>)</span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initiailValue</span>(<span class="params"></span>)</span>&#123; &#125;</div></pre></td></tr></table></figure><p>set(T value)方法用来设置当前线程中变量的副本；get()方法是用来获取ThreadLocal在当前线程中保存的变量副本；remove()用来移除当前线程中变量的副本。  </p><h3 id="1、ThreadLocal-set-T-value-实现"><a href="#1、ThreadLocal-set-T-value-实现" class="headerlink" title="1、ThreadLocal.set(T value)实现"></a>1、ThreadLocal.set(T value)实现</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="literal">void</span> <span class="built_in">set</span>(T value)&#123;</div><div class="line">    <span class="keyword">Thread</span> t = <span class="keyword">Thread</span>.currentThread();</div><div class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap(t);<span class="comment">//从当前线程获取ThreadLocalMap实例</span></div><div class="line">    <span class="keyword">if</span>(<span class="built_in">map</span> != <span class="built_in">null</span>)</div><div class="line">        <span class="built_in">map</span>.<span class="built_in">set</span>(this, value);<span class="comment">//将ThreadLocal实例和value封装成Entry存入ThreadLocalMap中</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap getMap(<span class="keyword">Thread</span> t)&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上看出：<br><strong>1、从当前线程获取ThreadLocalMap实例<br>2、将ThreadLocal实例和value封装成Entry存入ThreadLocalMap中</strong>  </p><p><strong>map.set(this, value)的内部实现：</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="built_in">set</span>(ThreadLocal&lt;?&gt; <span class="built_in">key</span>, <span class="keyword">Object</span> value)&#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="built_in">int</span> len = tab.length;</div><div class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (len<span class="number">-1</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i,len)])&#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.<span class="built_in">get</span>();</div><div class="line">        <span class="keyword">if</span>(k == <span class="built_in">key</span>)&#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(k == <span class="keyword">null</span>)&#123;</div><div class="line">            replaceStaleEntry(<span class="built_in">key</span>, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(<span class="built_in">key</span>, value);</div><div class="line">    <span class="built_in">int</span> sz = ++<span class="built_in">size</span>;</div><div class="line">    <span class="keyword">if</span>(!cleanSomeSlots(i,sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        rehash();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1、通过key.threadLocalHashCode方法生成hash值；<br>2、通过 hash &amp; (len-1)，定位到table的位置i，假设table中位置i的元素为a；<br>3、如果a != null，假设a中的ThreadLocal的引用为k（即Entry的key）；<br>①如果引用k的实例和当前ThreadLocal实例一致，那么修改value值，返回<br>②如果引用k为null，说明元素a是陈旧的元素，删除并插入新元素，返回<br>③否则通过nextIndex方法找到下一个元素f，继续步骤3<br>4、如果a == null，那么把Entry加入到table的位置i上；<br>5、通过cleanSomeSlots删除陈旧的元素，如果table中没有元素删除，需要判断当前情况下是否要进行扩容</p><h3 id="2、ThreadLocal-get-实现"><a href="#2、ThreadLocal-get-实现" class="headerlink" title="2、ThreadLocal.get()实现"></a>2、ThreadLocal.get()实现</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> T <span class="built_in">get</span>()&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap();<span class="comment">//获取当前线程的threadLocals引用</span></div><div class="line">    <span class="keyword">if</span>(<span class="built_in">map</span> != <span class="keyword">null</span>)&#123;</div><div class="line">        ThreadLocalMap.Entry e = <span class="built_in">map</span>.getEntry(<span class="keyword">this</span>);<span class="comment">//根据this找到对应的Entry,this为当前ThreadLocal</span></div><div class="line">        <span class="keyword">if</span>(e != <span class="keyword">null</span>)&#123;</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Entry getEntry(ThreadLocal&lt;?&gt; <span class="built_in">key</span>)&#123;</div><div class="line">    <span class="built_in">int</span> i = <span class="built_in">key</span>.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i];</div><div class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span> &amp;&amp; e.<span class="built_in">get</span>() == <span class="built_in">key</span>)</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(<span class="built_in">key</span>, i, e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> T setInitialValue()&#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap <span class="built_in">map</span> = getMap(t);</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">map</span> != <span class="keyword">null</span>)</div><div class="line">        <span class="built_in">map</span>.<span class="built_in">set</span>(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>获取当前线程的threadLocals引用：<br>1、如果threadLocals不为null，那么通过ThreadLocalMap.getEntry(this)方法找到对应的entry，返回e.value<br>2、如果threadLocals为null，那么通过setInitialValue方法初始化，并返回  </p><h3 id="3、table扩容"><a href="#3、table扩容" class="headerlink" title="3、table扩容"></a>3、table扩容</h3><p><strong>当table中的元素数量达到阈值threshold的3/4时，会进行扩容操作：</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> void resize()&#123;</div><div class="line">    Entry[] oldTab = table;</div><div class="line">    int oldLen = oldTab.length;</div><div class="line">    int <span class="keyword">new</span><span class="type">Len</span> = oldLen * <span class="number">2</span>;</div><div class="line">    Entry[] <span class="keyword">new</span><span class="type">Tab</span> = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="keyword">new</span><span class="type">Len</span>];</div><div class="line">    int count = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; oldLen; ++j)&#123;</div><div class="line">        Entry e = oldTab[j];</div><div class="line">        <span class="keyword">if</span>(e != <span class="literal">null</span>)&#123;</div><div class="line">            ThreadLocal&lt;?&gt; k = e.<span class="keyword">get</span>();</div><div class="line">            <span class="keyword">if</span>(k == nunll)&#123;</div><div class="line">                e.value = <span class="literal">null</span>;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                int h = k.threadLocalHashCode &amp; (<span class="keyword">new</span><span class="type">Len</span> - <span class="number">1</span>);</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">new</span><span class="type">Tab</span>[h] != <span class="literal">null</span>)</div><div class="line">                    h = nextIndex(h,<span class="keyword">new</span><span class="type">Len</span>);</div><div class="line">                <span class="keyword">new</span><span class="type">Tab</span>[h] = e;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    setThreshold(<span class="keyword">new</span><span class="type">Len</span>);</div><div class="line">    size = count;</div><div class="line">    table = <span class="keyword">new</span><span class="type">Tab</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>1、新建新的数组newTab，大小为原来的2倍<br>2、复制table的元素到newTab，忽略陈旧的元素，假设table中的元素需要复制到newTab的位置i上，如果位置i存在元素，那么找下一个空位置进行插入  </p><h1 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h1><p>ThreadLocal不是用来解决对象共享访问的问题的，而主要是<strong>提供了保持对象的方法和避免参数传递的一种便捷的访问对象的方式：</strong><br><strong>1、每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保存在其中，自己管自己的，线程可以正确的访问到自己的对象</strong><br><strong>2、将一个共有的ThreadLocal静态实例作为Key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取出自己线程保存的哪个对象，避免了将这个对象作为参数传递的麻烦。</strong>  </p><p>最常用的ThreadLocal使用场景是用来解决<strong>数据库连接、Session管理</strong>等，如：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal threadSession = <span class="keyword">new</span> <span class="type">ThreadLocal</span>();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Session getSession() throws InfrastructureException&#123;</div><div class="line">    Session s = (Session) threadSession.<span class="keyword">get</span>();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>)&#123;</div><div class="line">            s = getSessionFactory().openSession();</div><div class="line">            threadSession.<span class="keyword">set</span>(s);</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">catch</span>(HibernateException ex)&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span>  <span class="type">InfrastructureException</span>(ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，在方法getSession()中，首先通过threadSession.get()判断当前线程有没有放进去session，如果还没有，那么通过getSessionFactory().openSession()来创建一个session，再把session用set放进去，实际上是放到当前线程的ThreadLocalMap中。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入ReetrantLock</title>
      <link href="/2017/08/21/%E6%B7%B1%E5%85%A5ReetrantLock/"/>
      <url>/2017/08/21/%E6%B7%B1%E5%85%A5ReetrantLock/</url>
      <content type="html"><![CDATA[<h1 id="一、Lock接口"><a href="#一、Lock接口" class="headerlink" title="一、Lock接口"></a>一、Lock接口</h1><p>在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，在java5之后，并发包中增加了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized类似的功能，但是在使用时需要显式地获取和释放锁。虽然缺少了synchronized隐式获取释放锁的便捷性，但是却拥有锁获取和释放的可操作性、可中断的获取锁、超时获取锁等多种synchronized不具备的同步特性。  </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReetrantLock();</div><div class="line">Condition condition = <span class="keyword">lock</span>.newCondition();</div><div class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">while</span>(条件判断)&#123;</div><div class="line">        condition.<span class="keyword">await</span>();</div><div class="line">    &#125;</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">    <span class="keyword">lock</span>.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需要显式的获取锁，并在finally块中显式的释放锁，保证在获取锁之后，最终能够被释放。  </p><h2 id="1、公平锁与非公平锁的实现"><a href="#1、公平锁与非公平锁的实现" class="headerlink" title="1、公平锁与非公平锁的实现"></a>1、公平锁与非公平锁的实现</h2><p>公平性与否，是针对于获取锁而言的。如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。</p><h3 id="①非公平锁实现"><a href="#①非公平锁实现" class="headerlink" title="①非公平锁实现"></a>①非公平锁实现</h3><p>对于非公平锁，只要CAS设置同步状态成功，就表示当前线程获取了锁。<br><strong>1、线程A和B同时执行CAS指令，假设线程A成功，线程B失败，表示线程A成功获取锁，并把同步器中的exclusiveOwnerThread设置为线程A。</strong><br><strong>2、竞争失败的线程B，在nonfairTryAcquire方法中，会再次尝试获取锁，在这段时间如果线程A释放锁，线程B就可以直接获取锁而不用挂起。</strong>  </p><h3 id="②公平锁实现"><a href="#②公平锁实现" class="headerlink" title="②公平锁实现"></a>②公平锁实现</h3><p><strong>在公平锁中，每当线程执行lock方法时，如果同步器的队列中有线程等待，则直接加入到队列中。</strong><br>公平锁的实现方法tryAcquire与非公平锁的实现方法nonfairTryAcquire方法比较，唯一不同的是判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，表示有线程比当前线程更早的请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。  </p><h2 id="2、重入锁实现"><a href="#2、重入锁实现" class="headerlink" title="2、重入锁实现"></a>2、重入锁实现</h2><p>重入锁ReentrantLock，即线程可以重复获取已经持有的锁。通过ReentrantLock的构造函数，还支持选择获取锁时的公平和非公平选择。<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(current == getExclusiveOwnerThread())&#123;</div><div class="line">    <span class="built_in">int</span> nextc = c + acquires;</div><div class="line">    <span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">    setState(nextc);</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为每个锁关联一个获取计数器和一个所有者线程，当计数值为0时，这个锁就没有被任何线程持有。当线程请求一个未被持有的锁时，JVM会记下锁的持有者，并且将获取计数值置为1，如果同一个线程再次获取这个锁，计数值将递增。每退出一次同步代码块，计数值就递减一次。当计数值为0时，这个锁就被释放。</p><h1 id="二、Condition接口"><a href="#二、Condition接口" class="headerlink" title="二、Condition接口"></a>二、Condition接口</h1><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()、notifyAll()方法，这些方法和synchronized配合，可以实现等待/通知模式。<br>Condition接口也提供了类似Object的监视器方法，和Lock配合来实现等待/通知模式。但两者存在差异。<br><strong>1、synchronized中，所有的线程都在同一个object的等待队列上等待；在ReentrantLock中，每个condition都维护了一个等待队列。</strong><br><strong>2、Condition是与Lock绑定的，所有就有Lock的公平性特性：如果是公平锁，线程按照FIFO的顺序从Condition.await的等待队列中释放；如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。</strong>  </p><h3 id="conditon在生产者消费者中的应用场景"><a href="#conditon在生产者消费者中的应用场景" class="headerlink" title="conditon在生产者消费者中的应用场景"></a>conditon在生产者消费者中的应用场景</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">ConditionTest</span>&#123;</div><div class="line">    final Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    final Condition notFull = <span class="keyword">lock</span>.newCondition();<span class="comment">//生产</span></div><div class="line">    final Condition notEmpty = <span class="keyword">lock</span>.newCondition();<span class="comment">//消费</span></div><div class="line">    final Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];<span class="comment">//存储商品的容器</span></div><div class="line">    <span class="keyword">int</span> putptr, takeptr, count;<span class="comment">//生产者角标、消费者角标、计数器</span></div><div class="line">    <span class="comment">//往容器中存储商品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">Object x</span>)throws InterruptedException</span>&#123;&#123;</div><div class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">while</span>(count == items.length)<span class="comment">//容器满，生产就等待</span></div><div class="line">                notFull.<span class="keyword">await</span>();</div><div class="line">            items[putptr] = x;</div><div class="line">            <span class="keyword">if</span>(++putptr == items.length)<span class="comment">//角标到容器最后，归零</span></div><div class="line">                putptr = <span class="number">0</span>;</div><div class="line">            ++count;</div><div class="line">            notEmpty.signal();<span class="comment">//唤醒一个消费者</span></div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">lock</span>.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//从容器出取出商品</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span>(<span class="params"></span>)throws InterruptedException</span>&#123;&#123;</div><div class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>)</div><div class="line">                notEmpty.<span class="keyword">await</span>();</div><div class="line">            Object x = items[takeptr];</div><div class="line">            <span class="keyword">if</span>(++takeptr == items.length)</div><div class="line">                takeptr = <span class="number">0</span>;</div><div class="line">            --count;</div><div class="line">            notFull.signal();</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">lock</span>.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="1、await方法实现"><a href="#1、await方法实现" class="headerlink" title="1、await方法实现"></a>1、await方法实现</h2><p><strong>当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition的signal()方法时，通知当前线程后，当前线程之后从await()方法处返回，并在返回前已经获取到了锁。</strong>  </p><p>如果线程A执行await方法：<br>1、将线程A加入到conditon的等待队列中，如果最后一个节点的状态是CANCELLED，就从队列中删除。<br>2、线程A释放锁，线程A修改AQS的状态state为0，并唤醒AQS同步队列中的线程B，线程B唤醒后，尝试获取锁。<br>3、线程A释放锁并唤醒线程B后，如果线程A不在AQS同步队列中，就通过LockSupport.park进行挂起操作。<br>4、当线程A被唤醒时，会通过acquireQueued方法竞争锁，如果失败，继续挂起；如果成功，线程A从await位置恢复。  </p><p><strong>acquireQueued方法：节点进入同步队列之后，就进入了一个自旋的过程，每个节点（每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋的过程中退出，否则依旧留在这个自旋的过程中（并会阻塞节点的线程）。</strong><br>如下图所示：<br><img src="http://osrmzp0jr.bkt.clouddn.com/d_%E5%89%AF%E6%9C%AC.jpg" alt="image"></p><h2 id="2、notify方法实现"><a href="#2、notify方法实现" class="headerlink" title="2、notify方法实现"></a>2、notify方法实现</h2><p>如果线程B执行notify方法：<br>1、接着上述场景，线程B执行signal方法，取出等待队列的第一个非CANCELLED的节点线程，即线程A。遇到CANCELLED线程就需要将其从队列中删除。<br>2、通过CAS修改线程A的waitStatus为0，表示该节点已经不是处于等待队列状态，并将A插入到AQS的同步队列中。<br>3、唤醒线程A，线程A和别的线程进行锁的竞争。  </p><h2 id="从队列角度看await方法和notify方法"><a href="#从队列角度看await方法和notify方法" class="headerlink" title="从队列角度看await方法和notify方法"></a>从队列角度看await方法和notify方法</h2><p>1、当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<br><img src="http://osrmzp0jr.bkt.clouddn.com/a_%E5%89%AF%E6%9C%AC.jpg" alt="image">  </p><p>2、当调用notify()方法时，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点已到同步队列中。<br><img src="http://osrmzp0jr.bkt.clouddn.com/b_%E5%89%AF%E6%9C%AC.jpg" alt="image">  </p><h1 id="三、synchronized和lock的区别"><a href="#三、synchronized和lock的区别" class="headerlink" title="三、synchronized和lock的区别"></a>三、synchronized和lock的区别</h1><p><strong>1、用法上：<br>synchronized是隐式锁，在需要同步的地方加上，可以加在方法上，也可以加在同步块上；<br>lock是显式锁，需要指定起始位置和终止位置，在加锁和解锁出通过lock()和unlock()显式指出，需要在finally中释放锁。<br>2、功能上：<br>ReentrantLock提供了和内置锁synchronized类似的功能和内存语义。此外，ReentrantLock还提供了更丰富的功能。包括定时的锁等待、公平性、实现非块结构的加锁，对线程的等待和唤醒操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。<br>3、性能上：<br>synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在java1.5中，synchronized是性能低效的，相比之下，lock的性能更高。<br>但是到了java1.6，发生了变化。synchronized进行了很多优化，有适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等等，导致在java1.6上，synchronized的性能并不比lock差。<br>4、机制上：<br>synchronized采用的是悲观锁机制，即线程获得的是独占锁，意味着其他线程只能阻塞来等待线程释放锁；<br>而Lock用的是乐观锁方式，乐观锁就是每次不加锁，而是假设没有冲突去完成某项操作，如果因为冲突失败就重试，知道成功为止。乐观锁实现的机制就是CAS操作。</strong>  </p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Semaphore</title>
      <link href="/2017/08/17/Semaphore/"/>
      <url>/2017/08/17/Semaphore/</url>
      <content type="html"><![CDATA[<h2 id="什么是Semaphore"><a href="#什么是Semaphore" class="headerlink" title="什么是Semaphore"></a>什么是Semaphore</h2><p><strong>Semaphore(信号量)是用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。</strong><br><strong>Semaphore的构造方法Semaphore(int permits)接受一个整形的数字，表示可用的许可证数量。许可证的数量也代表着最大并发数。</strong><br><strong>1、在访问特定资源时，必须使用acquire()方法来获取一个许可证，如果许可的数量为0，该线程就一直阻塞，直到有可用的许可。</strong><br><strong>2、访问完资源后，使用release()方法归还许可证。</strong><br>Semaphore和ReetrantLock类似，获取许可可用公平策略或者非公平策略，默认情况下使用非公平策略。  </p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Semaphore可用于流量控制，比如数据库连接。如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是在读到内存后，我们还需要存储到数据库中，而这时数据库的连接数如果只有10，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Excutors.newFixedThreadPool(THREAD_COUNT);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;THREAD_COUNT; i++)&#123;</div><div class="line">            threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                    <span class="keyword">try</span>&#123;</div><div class="line">                        <span class="comment">//读取文件操作</span></div><div class="line">                        s.acquire();</div><div class="line">                        <span class="comment">//存储数据操作</span></div><div class="line">                        s.release();</div><div class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">                        </div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        threadPool.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Semaphore的实现主要基于Java同步器AQS，内部使用state表示许可数量。  </p><h3 id="非公平策略"><a href="#非公平策略" class="headerlink" title="非公平策略"></a>非公平策略</h3><h4 id="1、acquire实现"><a href="#1、acquire实现" class="headerlink" title="1、acquire实现"></a>1、acquire实现</h4><p>核心代码如下  </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">final <span class="keyword">int</span> nonfairTryAcquireShared(<span class="keyword">int</span> acquires)&#123;</div><div class="line">    <span class="built_in">for</span>(;;)&#123;</div><div class="line">        <span class="keyword">int</span> <span class="built_in">available</span> = getState();</div><div class="line">        <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</div><div class="line">        <span class="built_in">if</span>(remaining&lt;<span class="number">0</span> || compareAndSetState(<span class="built_in">available</span>,remaining)</div><div class="line">            <span class="built_in">return</span> remaining;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>acquires的值默认为1，表示尝试获取一个许可，remaining代表剩余的许可数。<br><strong>如果remaining &lt; 0，表示目前没有剩余可用的许可了，那么当前线程进入AQS中的doAcquireSharedInterruptibly方法等待可用的许可，并且被挂起，直到被唤醒。</strong>  </p><h4 id="2、release实现"><a href="#2、release实现" class="headerlink" title="2、release实现"></a>2、release实现</h4><p>核心代码如下  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> tryReleaseShared(<span class="keyword">int</span> release)&#123;</div><div class="line">    <span class="keyword">for</span>(;;)&#123;</div><div class="line">        <span class="keyword">int</span> current = getState();</div><div class="line">        <span class="keyword">int</span> <span class="keyword">next</span> = current + releases;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">next</span> &lt; current)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>)</div><div class="line">        <span class="keyword">if</span>(compareAndSetState(current,<span class="keyword">next</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>releases的值默认为1，表示尝试释放1个许可；next代表许可释放成功后，可用许可的数量。<br><strong>1、通过unsafe.compareAndSwapInt修改state的值，确保同一时刻只有一个线程可以释放成功。</strong><br><strong>2、如果许可释放成功，那么当前线程进入到AQS的doReleaseShared方法，唤醒队列中等待许可的线程。</strong>  </p><h4 id="非公平性的体现"><a href="#非公平性的体现" class="headerlink" title="非公平性的体现"></a>非公平性的体现</h4><p><strong>当一个线程A执行acquire方法时，会直接尝试获取许可，而不管同一时刻阻塞队列中是否有线程也在等待许可，如果恰好有线程C执行release释放许可，并唤醒阻塞队列中的第一个等待的线程B，这时，线程A和B共同竞争可用许可，不公平性体现出来，线程A没有等待就和线程B同等对待。</strong>   </p><h3 id="公平策略"><a href="#公平策略" class="headerlink" title="公平策略"></a>公平策略</h3><h4 id="1、acquire实现-1"><a href="#1、acquire实现-1" class="headerlink" title="1、acquire实现"></a>1、acquire实现</h4><p>核心代码如下<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">final <span class="keyword">int</span> TryAcquireShared(<span class="keyword">int</span> acquires)&#123;</div><div class="line">    <span class="built_in">for</span>(;;)&#123;</div><div class="line">        <span class="built_in">if</span>(hasQueuePredecessors())</div><div class="line">            <span class="built_in">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> <span class="built_in">available</span> = getState();</div><div class="line">        <span class="keyword">int</span> remaining = <span class="built_in">available</span> - acquires;</div><div class="line">        <span class="built_in">if</span>(remaining&lt;<span class="number">0</span> || compareAndSetState(<span class="built_in">available</span>,remaining)</div><div class="line">            <span class="built_in">return</span> remaining;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>acquires的值默认为1，表示尝试获取一个许可，remaining代表剩余的许可数。<br>与非公平策略相比，只是多了一个对阻塞队列的检查。<br><strong>1、如果阻塞队列中没有等待的线程，那么当前线程可以参与许可的竞争；</strong><br><strong>2、如果阻塞队列中有等待的线程，那么直接插入阻塞队列尾结点并挂起，等待被唤醒。</strong>  </p><h4 id="2、release实现-1"><a href="#2、release实现-1" class="headerlink" title="2、release实现"></a>2、release实现</h4><p>和非公平策略一样。  </p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CyclicBarrier</title>
      <link href="/2017/08/16/CyclicBarrier/"/>
      <url>/2017/08/16/CyclicBarrier/</url>
      <content type="html"><![CDATA[<h2 id="什么是CyclicBarrier"><a href="#什么是CyclicBarrier" class="headerlink" title="什么是CyclicBarrier"></a>什么是CyclicBarrier</h2><p>CyclicBarrier也叫同步屏障，在jdk1.5中引入，<strong>可以让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，所有被阻塞的线程才能继续执行。</strong><br>CyclicBarrier就好比是一扇门，默认情况是关闭的，堵住所有线程执行的路径，只有所有线程都到达时，门才会打开。  </p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>1、<strong>默认的构造方法是CyclicBarrier(int parties)，参数parties表示屏障拦截的线程数量，每个线程会调用await方法来告诉CyclicBarrier它已经到达了屏障，然后当前线程就被阻塞。</strong><br>2、<strong>更高级的构造函数是CyclicBarrier(int parties, Runnable barrierAction)用于在所有线程到达屏障时，优先执行barrierAction。</strong><br><img src="http://osrmzp0jr.bkt.clouddn.com/CyclicBarrier.png" alt="image">  </p><h2 id="CyclicBarrier的实现原理"><a href="#CyclicBarrier的实现原理" class="headerlink" title="CyclicBarrier的实现原理"></a>CyclicBarrier的实现原理</h2><p>CyclicBarrier的实现主要基于ReentrantLock。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span></span>&#123;</div><div class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</div><div class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中，<strong>Generation用来控制屏障的循环使用，如果generation.broken为true的话，说明这个屏障已经损坏了，当某个线程await的时候，直接抛出异常。</strong>  </p><h3 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h3><p><strong>1、每当线程执行await方法时，内部变量count就减1，如果count!=0，说明有线程还没有到达屏障处，那么在锁的条件变量trip上等待。</strong><br><strong>2、当count==0时，说明所有的线程都到达屏障处，执行条件变量trip的signAll方法来唤醒等待的线程。</strong><br>其中nextGeneration可以实现屏障的循环使用：可以实现重新生成Generation对象和恢复count值。  </p><h2 id="CountDownLatch和CyclicBarrier的区别"><a href="#CountDownLatch和CyclicBarrier的区别" class="headerlink" title="CountDownLatch和CyclicBarrier的区别"></a>CountDownLatch和CyclicBarrier的区别</h2><p><strong>1、CountDownLatch的计数器只可以使用一次；而CyclicBarrier的计数器可以使用reset()方法重置，能够重复利用。</strong><br><strong>2、CountDownLatch是减计数器方式，构造方法中参数是要等待的线程的个数，每完成一个任务，调用countDown减1，当计数器为0时，说明所有线程的任务已经执行完，阻塞等待的线程被唤醒继续执行；CyclicBarrier中，构造方法中参数是屏障拦截的线程数量，当所有线程到达时，线程数等于parties变量指定的数，栅栏打开，所有线程通过。</strong><br><strong>3、CountDownLatch中，调用countDown方法实现计数器减1，调用await()方法只进行阻塞，对计数没有影响；CyclicBarrier中，调用await()方法计数器加1，加1后的值没有到达屏障拦截的数量，那么线程被阻塞。</strong></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CountDownLatch</title>
      <link href="/2017/08/15/CountDownLatch/"/>
      <url>/2017/08/15/CountDownLatch/</url>
      <content type="html"><![CDATA[<h2 id="什么是CountDownLatch"><a href="#什么是CountDownLatch" class="headerlink" title="什么是CountDownLatch"></a>什么是CountDownLatch</h2><p><strong>CountDownLatch也叫闭锁，在jdk1.5中引入，允许一个或多个线程等待其他线程完成操作后再执行。<br>CountDownLatch内部会维护一个初始值等于线程数量的计数器，主线程执行await方法，如果计数器大于0，那么主线程就阻塞等待。每当一个线程完成任务，计数器值就减一。当计数器为0时，表示所有的线程都已经完成任务，阻塞等待的主线程被唤醒，继续执行。</strong><br><img src="http://osrmzp0jr.bkt.clouddn.com/countdownlatch1.png" alt="image"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</div><div class="line">LatchDemo ld = <span class="keyword">new</span> LatchDemo(latch);</div><div class="line"></div><div class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</div><div class="line"><span class="keyword">new</span> Thread(ld).start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">latch.await();<span class="comment">//await方法挂起主线程</span></div><div class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line"></div><div class="line">System.out.println(<span class="string">"耗费时间："</span>+(end-start));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> CountDownLatch latch;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LatchDemo</span><span class="params">(CountDownLatch latch)</span></span>&#123;</div><div class="line"><span class="keyword">this</span>.latch=latch;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">50000</span>; i++)&#123;</div><div class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</div><div class="line">System.out.println(i);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">latch.countDown();<span class="comment">//计数器减一</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="CountDownLatch的实现原理"><a href="#CountDownLatch的实现原理" class="headerlink" title="CountDownLatch的实现原理"></a>CountDownLatch的实现原理</h2><p>CountDownLatch的实现主要是基于Java同步器AQS。其内部维护了一个AQS子类，并重写了相关的方法。  </p><h3 id="await实现"><a href="#await实现" class="headerlink" title="await实现"></a>await实现</h3><p>主线程执行await方法，tryAcquireShared方法中，如果state（state为未完成线程任务的线程个数）不等于0，返回-1，将主线程加入到等待队列中，主线程通过LockSupport.park(this)被挂起。<br>await():使当前线程在计数器至零之前一直等待，除非线程被中断。  </p><h3 id="countDown实现"><a href="#countDown实现" class="headerlink" title="countDown实现"></a>countDown实现</h3><p>countDown方法实现state的减1操作，即通过unsafe.compareAndSwapInt方法设置state值。<br>如果state的值为0，那么通过LockSupport.unpark唤醒await方法中挂起的主线程。  </p><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p><strong>join用于让当前的执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活就让当前线程继续等待下去。</strong> CountDownLatch也实现了join功能，并且比join功能更丰富。</p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java队列同步器AQS</title>
      <link href="/2017/08/15/java%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/"/>
      <url>/2017/08/15/java%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/</url>
      <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在java.util.concurrent.locks包中有很多Lock的实现类，<strong>常用的有ReetrantLock、ReadWriteLock，以及CountDownLatch，内部实现都依赖AbstractQueuedSynchronizer（AQS）类，AQS又称为队列同步器，完成代码块的并发访问控制。</strong>  </p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="comment">//等待队列的头结点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line">    <span class="comment">//等待队列的尾结点</span></div><div class="line">    priivate <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line">    <span class="comment">//同步状态</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> state; &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>队列同步器AQS是用来构建锁或其他同步组建的基础框架。<strong>内部使用一个int类型的成员变量state表示同步的状态，当state=0时，表示没有线程占有锁；state=1时，表示锁已经被占有。</strong> 同步状态state、头结点head、尾结点tail，都是由volatile修饰的，保证了线程之间的可见性。  </p><h3 id="Node结点"><a href="#Node结点" class="headerlink" title="Node结点"></a>Node结点</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> Node&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;<span class="comment">//描述对应线程的状态</span></div><div class="line">    <span class="keyword">volatile</span> Node prev;<span class="comment">//上一个节点</span></div><div class="line">    <span class="keyword">volatile</span> Node <span class="keyword">next</span>;<span class="comment">//后一个节点</span></div><div class="line">    <span class="keyword">volatile</span> Thread thread;<span class="comment">//当前线程</span></div><div class="line">    Node nextwaiter;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内部的FIFO队列（先进先出）：<br><img src="http://osrmzp0jr.bkt.clouddn.com/aqs1.png" alt="image"><br>黄色结点是head结点，是一个空节点，也就是代表当前持有锁的线程。每当有线程竞争失败，都会插入到队列的尾节点，tail节点始终指向队列的最后一个元素。<br>每个节点，除了存储了当前线程，前后节点的引用外，还有一个waitStatus变量，用于描述对应线程的状态：有的线程可能获取到锁，有的可能因为某些原因放弃竞争，有的线程可能在等待满足条件，满足后再执行。共四个状态：<br><strong>1、CANCELLED 取消状态  1<br>2、SIGNAL 等待触发状态  -1<br>3、CONDITION 等待条件状态  -2<br>4、PROPAGATE 状态需要向后传播  -3</strong><br>等待队列是FIFO先进先出，<strong>只有当前一个节点的状态是SIGNAL时，当前节点的线程才能被挂起。</strong>  </p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>子类重写tryAcquire和tryRelease方法，并通过CAS指令修改状态变量state。  </p><h3 id="线程获取锁的过程"><a href="#线程获取锁的过程" class="headerlink" title="线程获取锁的过程"></a>线程获取锁的过程</h3><p>如线程A和线程B进行竞争：<br>1、如果线程A执行CAS指令修改state成功，那么state被修改并返回true，线程A继续执行。<br>2、如果线程A执行CAS指令修改state失败，说明线程B此时执行CAS指令成功了，这时线程A会执行步骤3。<br>3、生成新Node节点node，通过CAS指令插入到等待队列的队尾（因为在同一时刻可能会有多个Node节点插入到等待队列中）。<br>4、<strong>node插入到队尾后，线程不会立马被挂起，而是会进行自旋操作。因为在node的插入过程中，线程B可能已经执行完成，所以要判断该node的前一个节点prev是否为head节点（代表线程B），如果prev==head，说明当前节点是队列中的第一个有效的节点，因此会再次尝试tryAcquire获取锁：</strong><br>&emsp;&emsp;①、如果成功获取到锁，表明线程B已经执行完成，线程A不需要挂起；<br>&emsp;&emsp;②、如果获取锁失败，表示线程B还未完成，至少state值还未被修改，那么执行步骤5。<br>5、只有在前一个节点的的状态是SIGNAL时，当前节点的线程才能被挂起，那么：<br>&emsp;&emsp;<strong>①如果prev的waitStatus=0，那么当前线程通过CAS指令修改waitStatus为Node.SIGNAL；</strong><br>&emsp;&emsp;<strong>②如果prev的waitStatus&gt;0，表明prev的线程状态是CANCELLED，需要从队列中删除；</strong><br>&emsp;&emsp;<strong>③如果prev的waitStatus为Node.SIGNAL，那么通过LockSupport.park()方法把线程A挂起，并等待被唤醒，被唤醒后进入步骤6。</strong><br>6、线程每次被唤醒时，都要进行中断检测，如果发现当前线程被中断，就抛出InterruptedException并退出循环。并不是被唤醒的线程就一定能获得锁，必须调用tryAcquire重新竞争。  </p><h3 id="线程释放锁的过程"><a href="#线程释放锁的过程" class="headerlink" title="线程释放锁的过程"></a>线程释放锁的过程</h3><p><strong>1、如果头节点head的waitStatus的值为-1，则用CAS指令重置为0；<br>2、找到waitStatus的值小于0的节点s，通过LockSupport.unpark(s.thread)唤醒线程。</strong>  </p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2017/08/14/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/08/14/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="一、Java内存模型的抽象结构"><a href="#一、Java内存模型的抽象结构" class="headerlink" title="一、Java内存模型的抽象结构"></a>一、Java内存模型的抽象结构</h1><p>&emsp;&emsp;<strong>java内存模型（JMM）是java线程之间的通信控制机制，JMM决定一个线程对共享变量（实例域、静态域和数组）的写入何时对另一个线程可见，java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</strong><br>&emsp;&emsp;JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量（实例域、静态域和数组元素）存储在主内存中，每个线程都有一个私有的本地内存（存放局部变量，方法定义参数和异常处理器参数），本地内存中存储了该线程以读、写共享变量的副本。</strong><br><img src="http://osrmzp0jr.bkt.clouddn.com/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="image"></p><p>线程A与B之间要通信的话，必须经历以下两个步骤：<br><strong>1、线程A把本地内存A中更新过的共享变量刷新到主内存中<br>2、线程B到主内存中去读取线程A之前已更新过的共享变量</strong>  </p><p><img src="http://osrmzp0jr.bkt.clouddn.com/22.png" alt="image">  </p><h3 id="1、指令重排序"><a href="#1、指令重排序" class="headerlink" title="1、指令重排序"></a>1、指令重排序</h3><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。<br><strong>①编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br><strong>②指令级并行的重排序</strong>：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br><strong>③内存系统的重排序</strong>：由于处理器使用缓存和读、写缓冲区，这使得加载和存储操作看上去可能在乱序执行。<br>&emsp;&emsp;①属于编译器重排序，②、③属于处理器重排序。<strong>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。</strong> 通过禁止特定类型的编译器重排序和处理器重排序，提供了一致的内存可见性保证。  </p><h3 id="2、内存屏障（Memory-Barrier）"><a href="#2、内存屏障（Memory-Barrier）" class="headerlink" title="2、内存屏障（Memory Barrier）"></a>2、内存屏障（Memory Barrier）</h3><p>内存屏障，又称内存栅栏，是一个CPU指令，主要实现两个功能：<br><strong>1、保证特定操作的执行顺序。插入一条内存屏障，会告诉编译器和CPU，不管什么指令都不能和这条内存屏障指令重排序。<br>2、强制刷出各种CPU缓存，确保内存数据的可见性。</strong>  </p><h3 id="3、数据依赖性"><a href="#3、数据依赖性" class="headerlink" title="3、数据依赖性"></a>3、数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。<strong>编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在数据依赖性关系的两个操作的执行顺序。</strong>  </p><h3 id="4、as-if-serial语义"><a href="#4、as-if-serial语义" class="headerlink" title="4、as-if-serial语义"></a>4、as-if-serial语义</h3><p><strong>as-if-serial语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。</strong> 所以编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序。</p><h3 id="5、顺序一致性内存模型"><a href="#5、顺序一致性内存模型" class="headerlink" title="5、顺序一致性内存模型"></a>5、顺序一致性内存模型</h3><p>是一个理想化的内存模型，一个线程中所有操作必须按照程序的顺序来执行。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。  </p><h3 id="6、happens-before规则"><a href="#6、happens-before规则" class="headerlink" title="6、happens-before规则"></a>6、happens-before规则</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。<br><strong>一个happens-before规则对应于一个或者多个编译器和处理器重排序规则。</strong><br>①程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>②监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>③volatile变量规则：对一个volatile域的写，happens-before于任意后序对这个volatile域的读。<br>④传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。<br><strong>注意：两个操作之间具有happens-before关系，并不意味着前一个操作必须在后一个操作之前执行！仅仅是要求前一个操作（执行的结果）对后一个操作是可见的，且前一个操作按顺序在第二个操作之前。</strong>  </p><h1 id="二、JVM对Java内存模型的实现"><a href="#二、JVM对Java内存模型的实现" class="headerlink" title="二、JVM对Java内存模型的实现"></a>二、JVM对Java内存模型的实现</h1><p>在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区，如下图：<br><img src="http://osrmzp0jr.bkt.clouddn.com/jvm1.png" alt="image"><br><strong>JVM中运行的每个线程都拥有自己的线程栈，包含了当前线程执行的方法调用信息，还包含了当前方法的所有本地变量信息，是线程私有的。<br>堆区包含了Java应用创建的所有对象信息，不管对象的引用是属于一个成员变量还是方法中的本地变量，对象都会被存储在堆区。</strong>  </p><p>下图展示了调用方法和本地变量存储在栈区，对象都存储在堆区：<br><img src="http://osrmzp0jr.bkt.clouddn.com/jvm2.png" alt="image">  </p><p><strong>1、一个本地变量如果是原始类型，那么存储在栈区；<br>2、一个本地变量可能是一个对象的引用，这种情况下，这个引用会被存储在栈中，但是对象本身仍然存储在堆区；<br>3、对于一个对象的成员方法，这些方法中包含本地变量，需要存储在栈中，即使所属的对象在堆区；<br>4、对于一个对象的成员变量，不管是原始类型还是包装类型，都被存储在堆区；<br>5、static类型的变量存储在堆区</strong>  </p><p><strong>堆中的对象可以被多线程共享。如果一个线程获得一个对象的引用，它就可以访问这个对象的成员变量；如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可以同时访问这个对象的成员变量，但是对于对象的本地变量，每个线程都会拷贝一份到自己的线程栈中。</strong> 如下图所示：<br><img src="http://osrmzp0jr.bkt.clouddn.com/jvm3.png" alt="image">  </p><h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><p><strong>当一个CPU需要访问主存时，会先去读取一部分主存数据到CPU缓存（CPU Cache），再读取CPU缓存到寄存器（CPU Registers）。当CPU需要写数据到主存时，同样会先flush寄存器到CPU缓存，然后在适当的时候把缓存数据flush到主存。</strong><br><img src="http://osrmzp0jr.bkt.clouddn.com/jvm4.png" alt="image">  </p><h2 id="Java内存模型和硬件内存架构之间的关系"><a href="#Java内存模型和硬件内存架构之间的关系" class="headerlink" title="Java内存模型和硬件内存架构之间的关系"></a>Java内存模型和硬件内存架构之间的关系</h2><p><strong>Java内存模型和硬件内存架构不是一致的。硬件架构中并没有区分栈和堆，从硬件上看，不管是栈还是堆，大部分数据都会存到主存中，还有一部分会存到缓存和寄存器中。</strong> 他们之间的关系如下图：<br><img src="http://osrmzp0jr.bkt.clouddn.com/jvm5.png" alt="image">  </p><p>当对象和变量存储到不同的内存区域后，会出现一些问题：<br><strong>1、共享对象对各个线程的可见性<br>2、共享对象的竞争现象</strong>  </p><h3 id="共享对象的可见性"><a href="#共享对象的可见性" class="headerlink" title="共享对象的可见性"></a>共享对象的可见性</h3><p><strong>当多个线程同时操作一个共享对象时，如果没有合理使用volatile和synchronized关键字，一个线程对共享对象的更新可能导致其他线程不可见。</strong><br>左边CPU中运行的线程从主存中拷贝共享对象obj到它的缓存，把obj的count改为2。但这个更新对右边CPU不可见，因为这个更新还没flush到主存中。可以使用volatile关键字解决问题。<br>如下图：<br><img src="http://osrmzp0jr.bkt.clouddn.com/jvm6.png" alt="image"></p><h3 id="竞争现象"><a href="#竞争现象" class="headerlink" title="竞争现象"></a>竞争现象</h3><p>如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。如下图所示，线程A、B共享一个对象obj，假设线程A、B从主存读取obj.count变量到自己的CPU缓存，并且两个线程都对obj.count做了加1操作，加1操作被执行了两个，最后count的值却为2。使用synchronized代码块解决问题，<strong>synchronized代码块可以保证同一个时刻只能有一个线程进入代码块，也能保证代码块中的所有变量从主存中去读，当线程退出代码块时，对所有变量的更新都会立即flush到主存。</strong><br><img src="http://osrmzp0jr.bkt.clouddn.com/jvm6.png" alt="image"></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>synchronized的实现原理及锁的升级</title>
      <link href="/2017/08/13/synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7/"/>
      <url>/2017/08/13/synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7/</url>
      <content type="html"><![CDATA[<h1 id="一、synchronized的实现原理"><a href="#一、synchronized的实现原理" class="headerlink" title="一、synchronized的实现原理"></a>一、synchronized的实现原理</h1><p>Java中的每一个对象都可以作为锁，有三种形式：<br><strong>1、对于普通同步方法，锁是当前实例对象。<br>2、对于静态同步方法，锁是当前类的Class对象。<br>3、对于同步代码块，锁是Synchronized括号中配置的对象.</strong>   </p><p>由JVM规范，<strong>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步</strong>，但两者实现细节不一样。<br><strong>1、代码块同步是使用monitorenter和monitorexit指令实现的。<br>2、方法同步则是依靠方法修饰符上的ACC_SYNCHRONIZED实现</strong>。  </p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。<strong>任何一个对象都有一个monitor与之关联。当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</strong><br>&emsp;&emsp;<strong>而synchronized用的锁是存放在Java对象头中的。</strong></p><h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>HotSpot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。  </p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><strong>对象头包括两部分：Mark Word 和 类型指针</strong>。  </p><p><strong>Mark Word</strong><br><strong>Mark Word用于存储对象自身的运行时数据，如哈希吗（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</strong>等，占用的内存大小和虚拟机的位长一致。  </p><p><strong>类型指针</strong><br><strong>类型指针指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例。</strong>   </p><p>&emsp;&emsp;在对象处于未被锁定的情况下，mark word的32bit空间中有25bit存储对象的哈希吗、4bit存储对象的分代年龄、2bit存储锁的标记位、1bit固定为0。</p><h1 id="锁的升级和对比"><a href="#锁的升级和对比" class="headerlink" title="锁的升级和对比"></a>锁的升级和对比</h1><p>&emsp;&emsp;为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，锁共有四种状态：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</strong>  </p><h2 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h2><p>&emsp;&emsp;大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低引入了偏向锁。<br>&emsp;&emsp;<strong>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要一次CAS原子指令来置换线程ID</strong>。<br><strong>（1）偏向锁的获取</strong><br>1、通过 markOop mark = obj-&gt;mark() 获取对象的markOop数据mark，即对象头的Mark Word；<br>2、判断mark是否为可偏向状态，即Mark的偏向锁标志位为1，锁标志位为01；<br>3、判断mark中Java Thread的状态：如果为空，则进入步骤4；如果指向当前线程，则执行同步代码块；如果指向其它线程，进入步骤5；<br>4、通过CAS原子指令设置mark中Java Thread为当前线程ID，如果执行CAS成功，则执行同步代码块，否则进入步骤5；<br>5、如果CAS执行失败，表示当前存在多个线程竞争锁，当达到全局安全点（safepoint），获得偏向锁的线程被挂起，撤销偏向锁，并升级为轻量级锁，升级完成后被阻塞在安全点的线程继续执行同步代码块。<br><strong>（2）偏向锁的撤销</strong><br>①偏向锁使用了一种等到竞争出现才会释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>②偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。<br>③暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。<br>④如果线程不处于活动状态，则将对象头设置成无锁状态；撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。<br><strong>（3）偏向锁的关闭</strong><br>偏向锁默认开启，但会在应用程序启动几秒后才激活。使用JVM参数关闭延迟：-XX：BiasedLockingStartupDelay=0。如果确定应用程序里所有的锁通常都处于竞争状态下，通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序会默认进入轻量级锁状态。  </p><h2 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h2><p>&emsp;&emsp;<strong>引入轻量级锁的目的：</strong>在多线程<strong>交替执行</strong>同步块时，尽量避免重量级锁引起的性能消耗，<strong>但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级为重量级锁。</strong><br><strong>（1）轻量级锁的获取</strong><br>当关闭偏向锁功能，或多个线程竞争偏向锁导致偏向锁升级为轻量级锁时，会尝试去获取轻量级锁。<br>1、通过 markOop mark = obj-&gt;mark() 获取对象的markOop数据mark，即对象头的Mark Word；<br>2、通过mark-&gt;is_neutral()方法判断mark是否为无锁状态：mark的偏向锁标志位为0（偏向锁关闭），锁标志位为01（无锁状态）；<br>3、如果mark处于无锁状态，则进入步骤4，否则进入步骤6；<br>4、把mark（对象头的Mark Word）复制到锁记录中（线程在执行同步块之前，JVM会现在当前线程的栈帧中创建用于存储锁记录的空间，_displaced_header字段）；<br>5、通过CAS尝试将Mark Word更新为指向锁记录的指针，如果更新成功，表示竞争到锁，执行同步代码，否则执行步骤6；<br>6、如果当前mark处于加锁状态，并且mark中的ptr指针指向当前线程的栈帧，则执行同步代码，否则说明有多个线程竞争轻量级锁，轻量级锁需要膨胀升级为重量级锁。  </p><p><strong>假设线程A和B同时执行到临界区</strong><br>1、线程A、B都把Mark Word复制到各自的锁记录（_displaced_header字段），该数据保存在线程的栈帧上，是线程私有的；<br>2、CAS操作保证只有一个线程可以将Mark Word更新为指向锁记录的指针，假设A执行成功，并返回继续执行同步代码块；<br>3、线程B的CAS操作失败，退出临界区，通过 ObjectSynchronizer::inflate方法开始膨胀锁。  </p><p><strong>（2）轻量级锁的解锁 </strong><br>轻量级锁解锁时，会使用CAS操作将锁记录中复制来的Mark Word重新替换回对象头。如果CAS成功，表示没有竞争发生，解锁成功；如果CAS失败，表示当前锁竞争存在，锁就会膨胀成重量级锁。  </p><h2 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h2><p>&emsp;&emsp;重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。<br>&emsp;&emsp;<strong>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。</strong> 在这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后才会唤醒这些线程，被唤醒的线程就会进行新的一轮夺锁之争。  </p><h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗,和执行非同步方法相比仅存在纳米级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度</td><td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原子操作及CAS算法</title>
      <link href="/2017/08/12/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8F%8ACAS%E7%AE%97%E6%B3%95/"/>
      <url>/2017/08/12/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%8F%8ACAS%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="一、原子操作的实现原理"><a href="#一、原子操作的实现原理" class="headerlink" title="一、原子操作的实现原理"></a>一、原子操作的实现原理</h1><h2 id="处理器如何实现原子操作"><a href="#处理器如何实现原子操作" class="headerlink" title="处理器如何实现原子操作"></a>处理器如何实现原子操作</h2><p><strong>1. 使用总线锁保证原子性</strong><br>&emsp;&emsp;<strong>总线锁</strong>就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，这样，该处理器就可以独占共享内存。<br><strong>2. 使用缓存锁保证原子性</strong><br>&emsp;&emsp;在同一时刻，我们只需要保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，使得在锁定期间，其他的处理器不能操作其他内存地址的数据，所以总线锁定开销较大，在某些场合用缓存锁代替总线锁。<br>&emsp;&emsp;<strong>缓存锁定</strong>是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，<strong>因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</strong>  </p><h2 id="Java如何实现原子操作"><a href="#Java如何实现原子操作" class="headerlink" title="Java如何实现原子操作"></a>Java如何实现原子操作</h2><p>&emsp;&emsp;Java中可以通过<strong>循环CAS</strong>和<strong>锁</strong>的方式来实现原子操作。<br><strong>1. 使用循环CAS实现原子操</strong><br>&emsp;&emsp;JVM中的CAS操作是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作，所以能保证原子操作的实现。<br><strong>2. 使用锁机制实现原子操作</strong><br>&emsp;&emsp;锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。<strong>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</strong>  </p><h1 id="二、CAS算法剖析"><a href="#二、CAS算法剖析" class="headerlink" title="二、CAS算法剖析"></a>二、CAS算法剖析</h1><p>&emsp;&emsp;<strong>CAS(Compare And Swap)，即比较并替换。三个操作数：内存值V，预估值A，更新值B，当且仅当V==A时，V=B。CAS的比较和替换是一组原子操作，不会被外部打断，属于硬件级别的操作，效率比加锁高</strong> </p><h2 id="AtomicInteger为例："><a href="#AtomicInteger为例：" class="headerlink" title="AtomicInteger为例："></a><strong>AtomicInteger为例：</strong></h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>&#123;</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        valueOffset = unsafe.objectFieldOffset(AtomicInteger.<span class="keyword">class</span>.getDeclaredField(<span class="string">"value"</span>))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> get()&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>①<strong>Unsafe</strong>是CAS的核心类，它提供了<strong>硬件级别的原子操作</strong>。<br>②<strong>valueOffset</strong>表示变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址来获取数据的原值的。<br>③<strong>value</strong>是用<strong>volatile</strong>修饰的，保证了value的可见性。  </p><p>AtomicInteger在并发下的累加操作过程：<br>&emsp;&emsp;在jdk1.8中，比较和替换操作放在Unsafe类中实现。假设线程A和B同时执行getAndAdd操作：  </p><ol><li>AtomicInteger中的value值为3，即内存中value为3，根据Java内存模型，线程A和B各持有一份value的副本，值为3.</li><li>线程A通过getIntVolatile(var1,var2)方法获取value值为3，此时线程切换，线程A挂起。</li><li>线程B通过getIntVolatile(var1,var2)方法获取value值为3，并利用<strong>compareAndSwapInt</strong>方法比较和替换，修改内存值为4，线程切换，线程B挂起。</li><li>线程A恢复，利用<strong>compareAndSwapInt</strong>方法比较，发现手中的值3和内存值4不一致，此时value正在被另一个线程修改，线程A不能修改value值。</li><li>线程的<strong>compareAndSwapInt</strong>实现，循环判断，重新获取value的值，value为volatile修饰变量，其他线程的修改，线程A总是能看到。直到<strong>compareAndSwapInt</strong>修改成功并返回true。 </li></ol><p>&emsp;&emsp;<strong>整个过程中，使用CAS保证了value修改的线程安全性。</strong>  </p><h3 id="compareAndSwapInt方法："><a href="#compareAndSwapInt方法：" class="headerlink" title="compareAndSwapInt方法："></a>compareAndSwapInt方法：</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> compareAndSwapInt(...)</div></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>compareAndSwapInt是一个本地方法的调用，会根据处理器的类型来决定是否为CMPXCHG指令添加lock前缀。</strong>多处理器，为CMPXCHG指令添加lock前缀；单处理器则省略lock前缀（不需为单处理器提供内存屏障效果）。  </p><h3 id="lock前缀："><a href="#lock前缀：" class="headerlink" title="lock前缀："></a>lock前缀：</h3><p>&emsp;&emsp;lock前缀的指令<strong>在多核处理器下</strong>会引发两件事：</p><ol><li><strong>将当前处理器缓存行的数据写回到系统内存。</strong></li><li><strong>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</strong>  </li></ol><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h2><p><strong>（1）ABA问题</strong><br>&emsp;&emsp;CAS在操作值的时候，需要检查值有没有发生变化，如果没有变化则更新。但如果一个值原来是A，变成了B，最后又变成A，那么使用CAS检查变化时会发现他的值没有发生变化，而实际上却变化了。<br><strong>解决方法：在变量前面加上版本号，每次变量更新时把版本号加1，那么A-&gt;B-&gt;C变成1A-&gt;2B-&gt;3A,在Atomic里提供了一个类AtomicStampedReference</strong>来解决ABA问题。<br><strong>（2）循环时间长开销大</strong><br>&emsp;&emsp;自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。<br><strong>（3）只能保证一个共享变量的原子操作</strong><br>&emsp;&emsp;当对一个共享变量执行操作时，可以使用循环CAS的方式保证原子操作，但对多个共享变量操作时，循环CAS就不能保证操作的原子性，这时候可以用锁。<strong>jdk提供AtomicReference保证了引用之间的原子性，就可以把多个变量放在一个对象里进行CAS操作。</strong></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入剖析volatile</title>
      <link href="/2017/08/11/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90volatile/"/>
      <url>/2017/08/11/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90volatile/</url>
      <content type="html"><![CDATA[<h1 id="一、volatile的性质"><a href="#一、volatile的性质" class="headerlink" title="一、volatile的性质"></a>一、volatile的性质</h1><h2 id="1、volatile保证可见性"><a href="#1、volatile保证可见性" class="headerlink" title="1、volatile保证可见性"></a>1、volatile保证可见性</h2><ol><li>volatile关键字保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对于其他线程来说是立即可见的。</li><li><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1</span></div><div class="line">boolean <span class="built_in">stop</span> =<span class="literal">false</span>;</div><div class="line"><span class="keyword">while</span>(!<span class="built_in">stop</span>)</div><div class="line">  doSomething();</div><div class="line"></div><div class="line"><span class="comment">//线程2</span></div><div class="line"><span class="built_in">stop</span>=<span class="literal">true</span>;</div></pre></td></tr></table></figure></li></ol><p>&emsp;&emsp;上面的代码，可能导致无法中断线程。当线程2更改了stop变量的值后，还没来得及写入内存中，线程2就转去做其他事情了，线程1由于不知道线程2对stop变量的修改，会一直循环下去。<br>&emsp;&emsp;使用volatile修饰后，发生变化：<br>第一：使用volatile会强制将修改的值写入主内存。<br>第二：使用volatile的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效。<br>第三：由于线程1的工作内存中的缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主内存读取。  </p><h2 id="2、volatile保证有序性"><a href="#2、volatile保证有序性" class="headerlink" title="2、volatile保证有序性"></a>2、volatile保证有序性</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//x、y不是volatile变量</span></div><div class="line"><span class="comment">//flag为volatile变量</span></div><div class="line">x=<span class="number">2</span>;            <span class="comment">//语句1</span></div><div class="line">y=<span class="number">0</span>;            <span class="comment">//语句2</span></div><div class="line">flag=true;      <span class="comment">//语句3</span></div><div class="line">x=<span class="number">4</span>;            <span class="comment">//语句4</span></div><div class="line">y=<span class="number">-1</span>            <span class="comment">//语句5</span></div></pre></td></tr></table></figure><p>①由于flag为volatile变量，在进行指令重排序时，不会将语句3放到语句1、2前面，也不会将语句3放到语句4、5的后面，但是语句1、2的顺序，语句4、5的执行顺序是不做任何保证的。<br>②并且volatile保证：执行到语句3时，语句1、2必定是执行完毕类的，而且语句1、2的执行结果对语句3、4、5是可见的。  </p><h2 id="3、volatile不能保证原子性"><a href="#3、volatile不能保证原子性" class="headerlink" title="3、volatile不能保证原子性"></a>3、volatile不能保证原子性</h2><p>&emsp;&emsp;原子性：即一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>&emsp;&emsp;可以通过synchronized或Lock进行加锁，来保证操作的原子性。也可以通过使用java.util.concurrent.atomic包下提供的原子操作类（对基本数据类型的一些操作进行了封装）来实现。<br>&emsp;&emsp;atomic是利用CAS（Compare And Swap）来实现原子性操作的，CAS实际上利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性的操作。  </p><h2 id="4、volatile的应用场景"><a href="#4、volatile的应用场景" class="headerlink" title="4、volatile的应用场景"></a>4、volatile的应用场景</h2><p>&emsp;&emsp;相较于synchronized，volatile是较为轻量级的同步策略，使用和执行成本更低，因为它不会引起线程上下文的切换和调度。但volatile无法代替synchronized，因为volatile无法保证操作的原子性。<br><strong>使用volatile的两个条件：<br>1、对变量的写操作不依赖于当前值<br>2、 该变量没有包含在具有其他变量的不变式中</strong> </p><h1 id="二、volatile的实现原理"><a href="#二、volatile的实现原理" class="headerlink" title="二、volatile的实现原理"></a>二、volatile的实现原理</h1><h2 id="1、可见性"><a href="#1、可见性" class="headerlink" title="1、可见性"></a>1、可见性</h2><p>&emsp;&emsp;处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据读到内部缓存后再进行操作，但操作完后不知道何时才会写到内存中。<br>&emsp;&emsp;对声明了volatile变量进行写操作时，<strong>JVM会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。</strong>这一步确保了如果有其他线程对声明了volatile的变量进行修改时，则立即更新主内存中的数据。<br>&emsp;&emsp;但此时其他处理器的缓存的数据还是旧数据，<strong>所以在多处理器的环境下，为了保证各个处理器的缓存一致，每个处理器会通过嗅探在总线上传播的数据来检查自己的缓存是否过期。当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个数据进行修改时，会强制重新从系统内存把数据读到处理器缓存里。</strong>这一步确保了其他线程获得的声明了volatile的变量都是从主内存中获取的最新的。  </p><h2 id="2、有序性"><a href="#2、有序性" class="headerlink" title="2、有序性"></a>2、有序性</h2><p>&emsp;&emsp;Lock前缀指令实际上相当于一个内存屏障（也称内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障之后的位置，即在执行到内存屏障这句指令时，在它之前的操作已经全部完成。</p><h2 id="3、Lock前缀指令"><a href="#3、Lock前缀指令" class="headerlink" title="3、Lock前缀指令"></a>3、Lock前缀指令</h2><p>在多处理器下会引发两件事：<br>①将当前处理器缓存行的数据写回到系统内存。<br>②这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。  </p><h1 id="三、volatile和synchronized的区别"><a href="#三、volatile和synchronized的区别" class="headerlink" title="三、volatile和synchronized的区别"></a>三、volatile和synchronized的区别</h1><p><strong>1、volatile的本质实在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中去获取。synchronized则是锁定当前线程才可以访问该变量，其他线程被阻塞住；<br>2、volatile只能使用在变量，synchronized可以使用在变量和方法上；<br>3、volatile只能实现变量的修改可见性，synchronized可以保证变量修改的可见性和原子性；<br>4、volatile不会造成线程的阻塞，synchronized会造成线程的阻塞。</strong></p>]]></content>
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入浅出多线程</title>
      <link href="/2017/07/08/Java%E5%9F%BA%E7%A1%80---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2017/07/08/Java%E5%9F%BA%E7%A1%80---%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="1、多线程的引入"><a href="#1、多线程的引入" class="headerlink" title="1、多线程的引入"></a><strong>1、多线程的引入</strong></h2><p>  多线程的相关内容是Java基础中非常重要的一部分，这两天对这部分知识进行了梳理，以达到复习和查漏补缺的目的。<br>  首先，多线程指的是在单个程序中可以同时运行多个不同的线程执行不同的任务，多线程编程的目的其实就是“最大限度地利用CPU资源”，我们接下来介绍下进程/程序/线程之间有什么区别和联系。</p><p> <strong>1. 进程与程序的区别是什么呢？</strong><br> （1）程序是长期存在的，进程是暂时的，是程序在数据集上的一次运行，有创建有撤销，存在是暂时的<br> （2）程序是静态的观念，进程是动态的观念<br> （3）进程具有并发性，而程序没有<br> （4） 进程是竞争计算机资源的基本单位，程序不是<br> （5）进程和程序不是一一对应的，一个程序可对应多个进程即多个进程可执行同一程序，一个进程可以执行一个或多个程序<br> <strong>2. 进程和线程又有什么区别呢？</strong><br> 线程是指进程内的一个执行单元，也是进程内的可调度实体。与进程的区别：<br> （1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位<br> （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行<br> （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源<br> （4）系统开销：在创建和撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建和撤销线程时的开销</p><h2 id="2、创建线程的两种方式"><a href="#2、创建线程的两种方式" class="headerlink" title="2、创建线程的两种方式"></a><strong>2、创建线程的两种方式</strong></h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a><strong>继承Thread类</strong></h3><ul><li>定义一个类去继承Thread</li><li>重写run方法</li><li>创建子类对象，就是创建线程对象</li><li><p>调用start方法，开启线程并让线程执行，同时告诉jvm去调用run方法</p><p>几个小问题：<br><strong>1.  线程对象调用run()方法和调用start()方法有什么区别</strong><br>调用run()方法不开启线程，仅仅是线程调用方法。调用start()方法开启线程，并让jvm调用run方法，在开启的线程中执行。<br><strong>2. 为什么要继承Thread类？</strong><br>因为Thread类描述线程事务，具备线程应有功能。<br><strong>3. 为什么不直接创建Thread类的对象呢？</strong><br>这么做start()调用的是Thread类中的run方法，此方法内部为空，不做任何事情，没有我们需要让线程执行的代码。</p><p> 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间，进行方法的压栈和弹栈。当执行线程的任务结束了，线程自动在栈内存中释放；当所有的执行线程都结束了，进程也就结束了。</p></li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a><strong>实现Runnable接口</strong></h3><ul><li>定义一个类来实现Runnable接口</li><li>覆盖接口中的run方法，将线程任务代码定义到run方法中</li><li>创建Thread类的对象（只有创建Thread对象，才能创建线程。）</li><li>将Runnable接口的子类对象作为参数传递给Thread类的构造函数</li><li>调用Thread类的start()方法开启线程</li></ul><p>Thread源码调用：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span>&#123;</div><div class="line"><span class="keyword">private</span> Runnable <span class="keyword">target</span>;</div><div class="line">Thread(Runnable <span class="keyword">target</span>)&#123;</div><div class="line"><span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">target</span> != <span class="keyword">null</span>)&#123;</div><div class="line"><span class="keyword">target</span>.run();</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</div><div class="line">run();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Runnable d = <span class="keyword">new</span> Demo();</div><div class="line">Thread t = <span class="keyword">new</span> Thread(d);</div><div class="line">t.start();</div></pre></td></tr></table></figure><p><strong>1. 为什么将Runnable接口的子类对象作为参数传递给Thread类的构造函数？</strong><br>   结合上面的Thread源码，我们不难看出，因为线程任务已被封装到Runnable接口的run()方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给Thread的构造函数，这样，线程对象创建时就可以明确要执行的线程任务了。</p><p><strong>2.  实现Runnable接口的方式较继承Thread的方式有何优势？</strong><br>  1、实现Runnable接口避免了单继承的局限性<br>  2、实现Runnable接口的方式，更加的符合面向对象，线程分为两部分，一部分是线程对象，一部分是线程任务。<br>  继承Thread类：线程对象和线程任务耦合在一起，一旦创建Thread类的子类对象，既是线程对象，又有线程任务<br>  实现Runnable接口：将线程任务单独分离出来，封装成对象，类型就是Runnable接口类型，Runnable接口对线程对象和线程任务进行了解耦</p><h2 id="3、多线程的安全问题"><a href="#3、多线程的安全问题" class="headerlink" title="3、多线程的安全问题"></a><strong>3、多线程的安全问题</strong></h2><p>  线程安全问题产生的原因：<br>  <strong>1、多个线程在操作共享的数据</strong><br>  <strong>2、线程任务操作共享数据的代码有多条（有多次运算）</strong><br>  解决思路：只要让一个线程在执行线程任务时，将多条操作共享数据的代码执行完，在执行过程中，不要让其他线程参与运算。</p><p>使用同步synchronized：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">synchronized</span><span class="params">(锁对象)</span></span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//需要被同步的代码...</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>  考虑到大家对synchronized锁可能很难理解，我做个比较形象的比喻来方便大家理解：使用同步时会用到锁，这就好比是<strong>在火车上上厕所</strong>。这又从何说起呢？<br>   <strong>火车上有个人想上厕所时，会去拿锁进入厕所并关上门，此时其他人拿不到锁是进不了厕所的。当这个人上完厕所后，离开厕所的同时释放了锁，那么其他人都具有同等的机会来竞相拿到锁进入厕所。</strong>这就好比一个线程拿到锁，此时其他线程无法进入同步代码块或者同步函数执行代码，当一个线程执行完后释放锁，其他线程争相获得cpu的执行权，以此来获得锁进入同步代码块执行代码。希望这个例子能给大家一些启发。</p><p>同步代码块的好处：解决了多线程的安全问题<br>同步弊端：降低了程序的性能（很多线程访问，每次访问都需要判断锁，做了很多无用功）；当线程任务中出现了多个同步（多个锁）时，如果同步嵌套了其他的同步，这时候容易引发死锁。<br><strong>同步前提：必须保证多个线程在同步中使用的是同一个锁。（也以此前提来判断同步是否书写正确）</strong></p><p><strong>同步代码块与同步函数的区别？</strong><br>1、同步函数使用的锁是固定的this；同步代码块使用的锁可以是任意对象<br>2、当线程任务只需要一个同步时，完全可以使用同步函数；当线程任务中需要多个同步时，必须通过锁来区分，这时候必须使用同步代码块<br>注：static同步函数使用的锁不是this，而是字节码文件对象，类名.class</p><h2 id="4、多线程间的通信"><a href="#4、多线程间的通信" class="headerlink" title="4、多线程间的通信"></a><strong>4、多线程间的通信</strong></h2><p>多线程间最为常见的应用案例：生产者消费者问题，具体说来就是：生产和消费同时进行，需要多线程，但是执行的任务却不相同，处理的资源确实相同的。在生产者生产了商品后应该告诉消费者进行消费，这时的生产者需要处于等待状态；消费者在消费了商品后应该告诉生产者进行生产，这时消费者需要处于等待状态。</p><p>  <strong>生产一个消费一个的情况</strong>：生产者生产面包，判断盘子中是否有面包，有的话生产者进入等待状态；没有的话将生产后的面包放于盘子中，唤醒消费者进行消费。如果盘子中没有面包，消费者就进入等待状态；如果盘子中有面包，那么消费者消费，同时唤醒生产者进行生产。以下为具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span></span>&#123;</div><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"><span class="comment">//定义标记flag</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//生产者生产行为</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name)</span></span>&#123;</div><div class="line"><span class="comment">//如果flag为true,说明盘子里有面包，不需要生产，生产者进入等待模式。</span></div><div class="line"><span class="keyword">if</span>(flag)</div><div class="line"><span class="keyword">this</span>.wait();</div><div class="line"><span class="keyword">this</span>.name = name + count;</div><div class="line">count++;</div><div class="line">System.out.println(<span class="string">"...生产者..."</span>+<span class="keyword">this</span>.name);</div><div class="line"><span class="comment">//完成生产，将标记改为true</span></div><div class="line">flag = <span class="keyword">true</span>;</div><div class="line"><span class="comment">//唤醒消费者</span></div><div class="line"><span class="keyword">this</span>.notify();</div><div class="line">&#125;</div><div class="line"><span class="comment">//消费者消费行为</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="comment">//如果flag为false,说明盘子里没有面包，消费不了，消费者者进入等待模式。</span></div><div class="line"><span class="keyword">if</span>(!flag)</div><div class="line"><span class="keyword">this</span>.wait();</div><div class="line">System.out.println(<span class="string">"...消费者..."</span>+<span class="keyword">this</span>.name);</div><div class="line"><span class="comment">//完成消费，盘子里没有面包了，将标记改为false</span></div><div class="line">flag = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//唤醒生产者</span></div><div class="line"><span class="keyword">this</span>.notify();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//描述生产者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> Resource r;</div><div class="line">Producer(Resource r)&#123;</div><div class="line"><span class="keyword">this</span>.r = r;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">r.set(<span class="string">"面包"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//描述消费者</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"><span class="keyword">private</span> Resource r;</div><div class="line">Consumer(Resource r)&#123;</div><div class="line"><span class="keyword">this</span>.r = r;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">r.out();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tset1</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">Resource r = <span class="keyword">new</span> resource();</div><div class="line">Producer pro = <span class="keyword">new</span> Producer(r);</div><div class="line">Consumer con = <span class="keyword">new</span> Consumer(r);</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(pro);</div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(con);</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="等待-唤醒机制"><a href="#等待-唤醒机制" class="headerlink" title="等待/唤醒机制"></a><strong>等待/唤醒机制</strong></h3><p>wait()：会让线程处于等待状态，其实就是将线程临时存储到线程池中。<br>notify()：会让线程池中任意一个等待的线程唤醒。<br>notifyAll()：会唤醒线程池中所有的等待线程。<br><strong>记住：这些方法必须使用在同步中，因为必须要标识wait、notify等方法所属的锁，同一个锁上的notify只能唤醒该锁上被wait的线程。</strong></p><p><strong>多生产多消费的形式</strong>：多个生产者，多个消费者的情况，如果延用上面的代码则会遇到一下几个问题，具体大家可以自己实施下，无非是，多new几个生产者、消费者，多创建几个线程。</p><p><strong><em>问题一：部分生产了的商品没有被消费，同一个商品可能被消费多次</em></strong><br>原因：被唤醒的线程没有再次判断标记，造成问题的发生<br>解决：只要让被唤醒的线程重新再次去判断标记就可以了，将if判断标记的方式改为while判断标记的方式。<br><strong>记住：多生产多消费，必须是while判断语句。</strong></p><p><strong><em>问题二：改为while后，死锁了</em></strong><br>原因：生产方唤醒了线程池中生产方的线程（由于唤醒的是线程池中<strong>任意一个</strong>线程），唤醒后判断标记flag，发现为true进入等待状态，此时所有线程都进入等待状态，程序无法继续执行，死锁发生。<br>解决：希望本方唤醒对方，没有对应的方法，只能使用notifyAll的方法。</p><p>经过上面两步，我们解决了遇到的问题，但是这种方式最大的问题是，<strong>效率相对比较低</strong>，那我们有没有更好的解决方法呢？答案是肯定的！</p><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a><strong>Lock接口</strong></h3><p>   Lock接口提供了更加面向对象的锁，在所中提供了更加显示的锁操作，我们可以通过lock()方法来获得锁，也可以用过unlock()方法来达到释放锁的目的，比同步更加厉害，可以用来替代synchronized。<br>   新锁（Lock）替代旧锁（synchronized），那么旧锁上的监视器方法（wait, notify, notifyAll）也在新锁上得到替换（await,  signal, signalAll）。在jdk1.5中，将这些原有的监视器方法封装到了一个Condition对象中，想要换取监视器的方法，就需要通过lock的newCondition方法获取Condition对象。通过使用新锁，我们可以在一个锁上创建多个监视器对象。<br>  下图为Lock与synchronized的对比：</p><p>  <img src="http://img.blog.csdn.net/20170320101442665?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="Lock与synchronized对比"></p><p>下面我们使用新锁的方式，介绍一个<strong>生产多个消费多个</strong>的问题：一边在生产商品，将生产的放于容器中；另一边从容器中取商品消费。</p><p>   <img src="http://img.blog.csdn.net/20170320102244052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="多个消费多个生产模型"></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Test2</span>&#123;</div><div class="line">final Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentranLock();<span class="comment">//锁</span></div><div class="line">final Condition notFull = <span class="keyword">lock</span>.newCondition();<span class="comment">//生产</span></div><div class="line">final Condition notEmpty = <span class="keyword">lock</span>.newCondition();<span class="comment">//消费</span></div><div class="line">final Object[] items = <span class="keyword">new</span> Object[<span class="number">20</span>];<span class="comment">//存储商品的容器</span></div><div class="line"><span class="keyword">int</span> putptr, takeptr, count;<span class="comment">//生产者角标、消费者角标、计数器</span></div><div class="line"><span class="comment">//往容器中存储商品</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">Object x</span>)throws InterruptException</span>&#123;</div><div class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>();<span class="comment">//加锁</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">while</span>(count == items.length)<span class="comment">//判断计数器是否已到数组长度，满了生产就进入等待状态</span></div><div class="line">notFull.<span class="keyword">await</span>();</div><div class="line">items[putptr] = x;<span class="comment">//按照角标存储商品</span></div><div class="line"><span class="keyword">if</span>(++putptr == items.length)<span class="comment">//存储角标到达数组长度，角标归零，重新从头存储商品</span></div><div class="line">putptr = <span class="number">0</span>;</div><div class="line">++count;<span class="comment">//计数器自增</span></div><div class="line">notEmpty.signal();<span class="comment">//唤醒消费者</span></div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line"><span class="keyword">lock</span>.unlock();<span class="comment">//释放锁</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">take</span>(<span class="params"></span>)throws InterruptException</span>&#123;</div><div class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line"><span class="keyword">while</span>(count==<span class="number">0</span>)</div><div class="line">notEmpty.<span class="keyword">await</span>();</div><div class="line">Object x = items[takeptr];</div><div class="line"><span class="keyword">if</span>(++takeptr == items.length)</div><div class="line">takeptr = <span class="number">0</span>;</div><div class="line">--count;</div><div class="line">notFull.signal();</div><div class="line"><span class="keyword">return</span> x;</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line"><span class="keyword">lock</span>.unlock();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a><strong>线程的状态</strong></h3><p>线程状态图如下所示：<br><img src="http://img.blog.csdn.net/20170320105528467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3VuaWFuXzkzMDEyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="线程状态图"></p><h2 id="5、多线程的细节"><a href="#5、多线程的细节" class="headerlink" title="5、多线程的细节"></a><strong>5、多线程的细节</strong></h2><p><strong>1. sleep方法和wait方法的异同？</strong><br>相同点：都可以让线程处于冻结状态<br>不同点：<br>1，sleep必须指定时间；wait可指定时间，也可不指定时间<br>2，sleep时间到，线程处于临时阻塞或进行状态；wait如果没有时间，必须要通过notify或者notifyAll唤醒<br>3，sleep不一定非要定义在同步中；wait必须要定义在同步中<br>4，都定义在同步中时，线程执行到sleep不会释放锁；线程执行到wait会释放锁</p><p><strong>2. 线程如何停止呢？</strong><br>线程结束就是让线程任务执行完，run方法结束。在run方法中通常都定义循环，只要控制住循环就可以了。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> <span class="title">Test3</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</div><div class="line"><span class="keyword">private</span> boolean flag = <span class="literal">true</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">while</span>(flag)</div><div class="line">System.<span class="keyword">out</span>.println(Thread.currentThread().getName()+<span class="string">"--------&gt;"</span>);</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//对标记修改的方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFlag</span>(<span class="params"></span>)</span>&#123;</div><div class="line">flag = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="title">StopThreadDemo</span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">Test3 t = <span class="keyword">new</span> Test3();</div><div class="line">Thread t1 = <span class="keyword">new</span> Thread(t);</div><div class="line">Thread t2 = <span class="keyword">new</span> Thread(t);</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line"><span class="comment">//满足循环要求，改变标记使其他线程任务能够结束，同时break跳出循环，让主线程也可以结束。</span></div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line"><span class="keyword">if</span>(++x = <span class="number">50</span>)&#123;</div><div class="line">t.changeFlag();</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">System.<span class="keyword">out</span>.println(<span class="string">"main----&gt;"</span>+x);</div><div class="line">&#125;</div><div class="line">System.<span class="keyword">out</span>.println(<span class="string">"over"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意：万一线程在任务中被冻结了，那么它还能去判断标记吗？不能！<br>解决：如果目标线程等待很长时间，则应该使用interrupt方法来中断该等待，所谓的中断并不是停止线程。<br>  interrupt的功能是将线程的状态清除，让线程恢复到运行状态（让线程重新具备cpu的执行资格）。由于是强制性的，所有会有异常发生，可以在catch中捕获异常，在异常处理中，改变标记让循环结束，让run方法结束。</p><p><strong>3.  守护线程的概念</strong><br>守护线程为后台线程，一般创建的都是前台线程。<br>相同点：前台、后台线程运行时都是一样的获取cpu的执行权和执行资格，都可以通过run方法结束，线程结束的方式结束。<br>不同点：当进程中所有的前台进程都结束了，无论后台处于什么样的状态，都会结束，从而进程会结束，进程的结束都是依赖于前台进程。</p><p><strong>4.  线程的优先级</strong><br>用数字标识。1-10，其中默认的初始优先级是5，最明显的优先级是1，5，10。</p><p><strong>5.  线程组ThreadGroup</strong><br>可以通过Thread的构造函数明确新线程对象所属的线程组。线程组的好处是，可以对多个同组线程进行统一的操作，效率高，默认是都属于main线程组。</p><p><strong>6.  jion()方法和yield()方法</strong><br>Thread1.jion()：主线程执行到这里，知道Thread1线程要加入执行，主线程释放了执行权、执行资格，并处于冻结状态。什么时候能恢复呢？等Thread1线程执行完后。<br>Thread2.yield()：线程临时暂停，将执行权释放，让其他线程有机会获得cpu的执行权。</p><p><strong>7. 开发中，线程的匿名内部类体现</strong><br>第一种方式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread()&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</div><div class="line"><span class="built_in">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">40</span>; x++)&#123;</div><div class="line">System.out.<span class="built_in">println</span>(Thread.currentThread().getName()+ <span class="string">"...X..."</span> +x);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure><p>第二种方式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Runnable r = <span class="keyword">new</span> Runnable()&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>()&#123;</div><div class="line"><span class="built_in">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="number">40</span>; x++)&#123;</div><div class="line">System.out.<span class="built_in">println</span>(Thread.currentThread().getName()+ <span class="string">"...Y..."</span> +x);</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">new</span> Thread(r).start();</div></pre></td></tr></table></figure><p><strong>8.  关于成员变量与局部变量</strong><br>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时，他们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另一个线程。如果一个变量是局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他的线程。</p><p>  <strong>先总结这么多，刚买了《Java并发编程实战》，后面肯定要通过好好读这本书对并发有个更好的理解，大家多多交流，一起努力！</strong></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
