<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Wunian"><title>Spring源码解析之AOP设计与实现 | Wunian's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring源码解析之AOP设计与实现</h1><a id="logo" href="/.">Wunian's Blog</a><p class="description">清风徐来，水波不兴</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring源码解析之AOP设计与实现</h1><div class="post-meta">Jul 14, 2018<span> | </span><span class="category"><a href="/categories/Spring源码解析/">Spring源码解析</a></span></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>AOP即面向切面编程，底层通过策略模式选择JDK动态代理还是CGLIB动态代理的方式实现，通过AOP可以在不修改原代码的基础上完成对类的功能的增强。相较于继承这种纵向抽取机制，AOP采用的横向抽取机制更加符合高内聚低耦合的思想。  </p>
<h3 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h3><ul>
<li>连接点：类中哪些方法可以被增强，这些方法称为连接点</li>
<li>切入点(Pointcut)：类中有很多可以被增强的方法，而实际选用的被增强方法就是切入点</li>
<li>通知(Advice)：定义增强的逻辑，即在切入点做什么增强操作，有BeforeAdvice、AfterAdvice、ThrowsAdvice等</li>
<li>通知器(Advisor)：将目标方法的切面增强设计(Advice)和切入点(Pointcut)结合起来。通过Advisor，可以定义使用哪个通知并在哪个Pointcut使用它，也就是给指定的Pointcut指定对应的Advice  </li>
</ul>
<a id="more"></a>
<h4 id="1、Advice"><a href="#1、Advice" class="headerlink" title="1、Advice"></a>1、Advice</h4><p>通知，是AOP的一个基本接口，BeforeAdvice、AfterAdvice、ThrowsAdvice都继承于它。下面以BeforeAdvice为例，在其继承体系中，定义了为待增强目标方法设置的前置增强接口MethodBeforeAdvice。  </p>
<p>使用这个前置接口需要实现一个回调函数<strong>before</strong>()，before方法的实现在Advice中被配置到目标方法后，会在调用木变方法时被回调。  </p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void before(<span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>, <span class="title">Object</span> <span class="title">target</span>) <span class="title">throws</span> <span class="title">Throwable</span>;</span></div></pre></td></tr></table></figure>
<p>参数：<br>Method，是目标方法的反射对象；Object数组，是目标方法的输入参数。  </p>
<h4 id="2、Pointcut"><a href="#2、Pointcut" class="headerlink" title="2、Pointcut"></a>2、Pointcut</h4><p>从Pointcut的接口定义中可以知道，需要返回一个<strong>MethodMatcher</strong>，对于Pointcut的匹配判断（即是否需要对当前方法进行增强），都是由这个MethodMatcher来完成的。  </p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public<span class="built_in"> interface </span>Pointcut&#123;</div><div class="line">    ClassFilter getClassFilter();</div><div class="line">    MethodMatcher getMethodMatcher();</div><div class="line">    Pointcut <span class="literal">TRUE</span> = TruePointcut.INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在MethodMatcher接口中，有一个<strong>matches()</strong> 方法，matches方法在匹配连接点的过程中有着至关重要的作用。  </p>
<p>在Pointcut的继承体系中，MethodMatcher可以配置成JdkRegexpMethodPointcut和NameMatchMethodPointcut来完成方法的匹配判断。  </p>
<p><strong>JdkRegexpMethodPointcut</strong> 通过使用正则表达式来对方法名进行匹配判断的。而<strong>NameMatchMethodPointcut</strong> 通过根据方法的全限定名称来进行匹配判断。  </p>
<h4 id="3、Advisor通知器"><a href="#3、Advisor通知器" class="headerlink" title="3、Advisor通知器"></a>3、Advisor通知器</h4><p>以DefaultPointcutAdvisor为例：  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultPointcutAdvisor</span> ...</span>&#123;</div><div class="line">    <span class="keyword">private</span> Pointcut <span class="keyword">pointcut</span> = Pointcut.TRUE;</div><div class="line">    </div><div class="line">    //创建一个匹配所有方法的DefaultPointcutAdvisor</div><div class="line">    public <span class="title">DefaultPointcutAdvisor</span>(Advice advice)&#123;</div><div class="line">        <span class="keyword">this</span>(Pointcut.TRUE, advice);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//为指定的pointcut和advice创建一个DefaultPointcutAdvisor</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultPointcutAdvisor</span><span class="params">(Pointcut pointcut, Advice advice)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.pointcut = <span class="keyword">pointcut</span>;</div><div class="line">        <span class="title">setAdvice</span>(advice);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AOP的设计与实现"><a href="#AOP的设计与实现" class="headerlink" title="AOP的设计与实现"></a>AOP的设计与实现</h3><p>在使用Spring AOP的过程中，我们可以通过配置达到在目标方法执行前或执行后进行其他操作的目的。这也是AOP完成的流程，首先为目标对象建立代理对象，然后启动代理对象的拦截器来完成各种切面的注入过程。同时，这一系列的织入设计是通过一系列的Adapter来实现的（不同的Advice有不同的Adapter来适配），比如MethodBeforeAdvice就有MethodBeforeAdviceAdapter与之匹配。<br><img src="http://osrmzp0jr.bkt.clouddn.com/aopproxy%20generate.jpg" alt="image"><br>在AOP模块中，代理对象的生成主要是通过ProxyFactoryBean来完成的，在其中封装了代理对象的生成过程。在ProxyFactoryBean中，代理对象的生成是以<strong>getObject()</strong> 方法为入口的。  </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>&#123;</div><div class="line">    <span class="comment">//在此完成为Proxy对象配置Advisor链</span></div><div class="line">    <span class="comment">//这个初始化的过程发生在第一次通过ProxyFactoryBean去获取代理对象的时候</span></div><div class="line">    initializeAdvisorChain();</div><div class="line">    </div><div class="line">    <span class="comment">//对单例和多例类型加以区分，调用不同方法生成代理对象</span></div><div class="line">    <span class="keyword">if</span>(isSingleton())&#123;</div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">getSingletonInstance</span><span class="params">()</span></span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="function"><span class="keyword">return</span> <span class="title">newPrototypeInstance</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如getObject方法中展现的那样，如果是单例对象，那么调用<strong>getSingletonInstance()</strong> 方法生成单例的代理对象，否则调用<strong>newPrototypeInstance()</strong> 生成对象。我们来分析下getSingletonInstance：  </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> synchronized Object getSingletonInstance()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.singletonInstance == <span class="literal">null</span>)&#123;</div><div class="line">        <span class="keyword">this</span>.targetSource = freshTargetSource();</div><div class="line">        ...</div><div class="line">        <span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面方法通过createAopProxy()返回的AopProxy传入getProxy方法来得到代理对象</span></div><div class="line"><span class="keyword">protected</span> Object getProxy(AopProxy aopProxy)&#123;</div><div class="line">    <span class="keyword">return</span> aopProxy.getProxy(<span class="keyword">this</span>.proxyClassLoader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>关键就在于通过createAopProxy()方法获取到AopProxy</strong>，最终调用的是<strong>DefaultAopProxyFactory</strong>的createAopProxy(config)方法来完成创建AopProxy。  </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> AopProxy createAopProxy(AdvisedSupport <span class="built_in">config</span>) throws AopConfigException &#123;</div><div class="line">        <span class="built_in">if</span> (<span class="built_in">config</span>.isOptimize() || <span class="built_in">config</span>.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(<span class="built_in">config</span>)) &#123;</div><div class="line">            Class&lt;?&gt; targetClass = <span class="built_in">config</span>.getTargetClass();</div><div class="line">            <span class="built_in">if</span> (targetClass == null) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</div><div class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果 targetClass 是接口类，使用JDK来生成AopProxy</span></div><div class="line">            <span class="built_in">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</div><div class="line">                <span class="built_in">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 否则使用CGLIB来生成AopProxy对象</span></div><div class="line">            <span class="built_in">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(<span class="built_in">config</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">else</span> &#123;</div><div class="line">            <span class="built_in">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(<span class="built_in">config</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到在这个方法中，对是否为接口类进行了判断。如果是接口类，就会使用Jdk动态代理生成代理对象；否则，会使用cglib动态代理生成代理对象。通过这个AopProxy对象，将AOP代理对象的生成和框架的其他部门进行了分离。  </p>
<p>这样之后，ProxyFactoryBean的getObject方法返回得到的就不是一个普通的Java对象了，而是一个AopProxy代理对象。这时候就不会让应用只是调用目标方法实现，而是会作为AOP实现的一部分(参照invoke方法的实现)。  </p>
<h3 id="AOP拦截器链的实现"><a href="#AOP拦截器链的实现" class="headerlink" title="AOP拦截器链的实现"></a>AOP拦截器链的实现</h3><p>Spring AOP在通过动态代理生成代理对象的时候，相关的拦截器就已经被配置到代理对象中去了，拦截器在代理对象中起作用是通过对这些方法的回调来完成的。  </p>
<h4 id="拦截器链的获取"><a href="#拦截器链的获取" class="headerlink" title="拦截器链的获取"></a>拦截器链的获取</h4><p>在DefaultAdvisorChainFactory中实现了拦截器链的获取过程。首先设置一个List，长度是由配置的通知器的个数决定的，之后通过AdvisorAdapterRegistry来实现拦截器的注册，通过AdvisorAdapterRegistry就行适配，获取到Advisor通知器对应的拦截器，再把它加入到前面的List中去，这样就完成了拦截器的注册。  </p>
<h4 id="拦截器链的调用"><a href="#拦截器链的调用" class="headerlink" title="拦截器链的调用"></a>拦截器链的调用</h4><p>如果通过Jdk动态代理的方式生成代理对象，那么需要通过<strong>InvocationHandler的invoke</strong>方法来设置拦截器的回调；如果通过Cglib动态代理的方式生成代理对象，那么就需要通过<strong>DynamicAdvisedInterceptor的intercept</strong>方法来实现拦截器的回调。  </p>
<p>但不管是哪种方式，它们对拦截器链的调用都是在<strong>ReflectiveMethodInvocation</strong>中通过<strong>proceed</strong>方法实现的。在proceed方法中，会逐个运行拦截器的拦截方法。在运行拦截方法之前，需要对代理方法完成一个匹配判断，来决定拦截器是否满足切面增强的要求（通过前面提到的matches方法实现）。在proceed方法中，先进行判断，如果现在运行到拦截器的末尾，那么就会直接调用目标对象的实现方法。  </p>
</div><div class="tags"><a href="/tags/Spring/">Spring</a><a href="/tags/源码解析/">源码解析</a></div><div class="post-nav"><a class="next" href="/2018/06/25/负载均衡那些事/">负载均衡那些事</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring源码解析/">Spring源码解析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java并发/">java并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式系统/">分布式系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/剑指offer/">剑指offer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大型网站技术架构核心原理/">大型网站技术架构核心原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/深入理解Java虚拟机/">深入理解Java虚拟机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/算法，剑指offer/" style="font-size: 15px;">算法，剑指offer</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/java并发/" style="font-size: 15px;">java并发</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/tags/java，java基础/" style="font-size: 15px;">java，java基础</a> <a href="/tags/java虚拟机/" style="font-size: 15px;">java虚拟机</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/大型网站技术架构/" style="font-size: 15px;">大型网站技术架构</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/Spring源码解析之AOP设计与实现/">Spring源码解析之AOP设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/负载均衡那些事/">负载均衡那些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/Netty之EventLoop与线程模型 /">Netty之EventLoop与线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/15/Netty 之组件与设计 /">Netty之组件与设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/Netty之构建Netty应用程序/">Netty之构建Netty应用程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/Netty剖析之核心组件/">Netty剖析之核心组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/Spring源码解析之IOC容器（二）/">Spring源码解析之IOC容器（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/Spring源码解析之IOC容器（一）/">Spring源码解析之IOC容器（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/16/谈谈分布式事务/">谈谈分布式事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/浅谈分库分表/">浅谈分库分表</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://coolshell.cn/" title="陈皓" target="_blank">陈皓</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Wunian's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>