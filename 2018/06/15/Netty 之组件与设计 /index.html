<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Wunian"><title>Netty之组件与设计 | Wunian's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Netty之组件与设计</h1><a id="logo" href="/.">Wunian's Blog</a><p class="description">清风徐来，水波不兴</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Netty之组件与设计</h1><div class="post-meta">Jun 15, 2018<span> | </span><span class="category"><a href="/categories/Netty/">Netty</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、Channel、EventLoop、ChannelFuture"><span class="toc-number">1.</span> <span class="toc-text">一、Channel、EventLoop、ChannelFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventLoop接口"><span class="toc-number">1.1.</span> <span class="toc-text">EventLoop接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelFuture"><span class="toc-number">1.2.</span> <span class="toc-text">ChannelFuture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、ChannelHandler和ChannelPipeline"><span class="toc-number">2.</span> <span class="toc-text">二、ChannelHandler和ChannelPipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelHandler"><span class="toc-number">2.1.</span> <span class="toc-text">ChannelHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelPipeline"><span class="toc-number">2.2.</span> <span class="toc-text">ChannelPipeline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelHandlerContext"><span class="toc-number">2.3.</span> <span class="toc-text">ChannelHandlerContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel和ChannelHandlerContext相同方法调用的区别："><span class="toc-number">2.4.</span> <span class="toc-text">Channel和ChannelHandlerContext相同方法调用的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、ServerBootstrap和Bootstrap"><span class="toc-number">3.</span> <span class="toc-text">三、ServerBootstrap和Bootstrap</span></a></li></ol></div></div><div class="post-content"><h3 id="一、Channel、EventLoop、ChannelFuture"><a href="#一、Channel、EventLoop、ChannelFuture" class="headerlink" title="一、Channel、EventLoop、ChannelFuture"></a>一、Channel、EventLoop、ChannelFuture</h3><p>这些类合在一起，可以被认为是Netty网络抽象的代表：  </p>
<ul>
<li>Channel——Socket</li>
<li>EventLoop——控制流、多线程处理、并发处理</li>
<li>ChannelFuture——异步通知<a id="more"></a>
<h4 id="EventLoop接口"><a href="#EventLoop接口" class="headerlink" title="EventLoop接口"></a>EventLoop接口</h4>EventLoop定义了Netty的核心抽象，用来处理连接的生命周期中所发生的事件。之后在Netty的线程模型中还会做更详细的讲解，我们先来看看EventLoop、Channel之间是怎样的关系。  </li>
</ul>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/EventLoopGroup.png" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/2184951-2e248d85df2a1a86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/490" alt="image"><br>首先有EventLoopGroup，用来管理EventLoop的生命周期，默认情况下，一个EventLoopGroup中有两倍线程的EventLoop。创建Channel后，将Channel注册到EventLoop，之后在Channel的整个生命周期中，都由这个EventLoop来处理I/O事件。而实际上，每个EventLoop都会维护一个Selector和TaskQueue（之后的文章会进一步讨论）。  </p>
<p>EventLoop和Channel一般是一对多的形式，他们之间关系可总结为以下几点：  </p>
<ul>
<li>一个EventLoopGroup包含一个或者多个EventLoop；  </li>
<li>一个EventLoop在它的生命周期内只和一个Thread绑定；  </li>
<li>与EventLoop绑定的Thread会处理所有EventLoop要处理的I/O事件，也就是注册在EventLoop上Channel需要处理的事件；  </li>
<li>一个Channel在它的生命周期内只注册于一个EventLoop；  </li>
<li>一个EventLoop可能会被分配给一个或多个Channel。  </li>
</ul>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>Netty中所有的I/O操作都是异步的，因此一个操作不会立刻返回，我们需要一种在之后的某个时间点确定其结果的方法。Netty提供了ChannelFuture接口，它的addListener()方法注册了一个ChannelFutureListener，用于在某个操作完成时（无论是否成功）得到通知。这个异步是指编程模型上的异步，基于reactor模式的事件驱动，事件处理器的注册和处理器的执行都是异步的。  </p>
<p>如上一篇文章中的代码实例，bind()用于异步的绑定服务器，ctx.write(in)用于异步的将缓存中数据写到context等等。  </p>
<h3 id="二、ChannelHandler和ChannelPipeline"><a href="#二、ChannelHandler和ChannelPipeline" class="headerlink" title="二、ChannelHandler和ChannelPipeline"></a>二、ChannelHandler和ChannelPipeline</h3><h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h4><p>ChannelHandler派生出ChannelInboundHandler和ChannelOutboundHandler接口。<br>如果有入站事件被读取，那么它会从ChannelPipeline的头部开始流动，并传递给第一个ChannelInboundHandler。这个handler具体会做怎样的处理，取决于它的具体功能，处理完之后，数据将会被传递给handler链中的下一个ChannelInboundHandler。最终到达ChannelPipeline的尾端，这样所有的入站事件处理就完成了。出站事件的处理与之相反。  </p>
<h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p><img src="https://upload-images.jianshu.io/upload_images/2184951-beacd91367f1f4eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/629" alt="image">  </p>
<p>ChannelPipeline为ChannelHandler链提供了容器，并且定义了用于在该链上传播入站和出站事件流的API。每个Channel在创建时，会分配一个专属的ChannelPipeline。ChannelHandler安装到ChannelPipeline的过程如下：  </p>
<ul>
<li>一个ChannelInitializer的实现被注册到ServerBootstrap中；</li>
<li>当ChannelIntializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler，这些handler与Channel想关联，也可以根据需要进行动态的添加和删除；</li>
<li>ChannelIntializer将它自己从ChannelPipeline中移除。  </li>
</ul>
<p>ChannelHandler的执行顺序是由它们被添加的顺序决定的，第一个执行完会传递给下一个handler。  </p>
<h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><p>ChannelHandler被添加到ChannelPipeline时，它会被分配一个ChannelHandlerContext，它代表了ChannelHandler和ChannelPipeline之间的绑定，它的主要功能是管理它所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。</p>
<h4 id="Channel和ChannelHandlerContext相同方法调用的区别："><a href="#Channel和ChannelHandlerContext相同方法调用的区别：" class="headerlink" title="Channel和ChannelHandlerContext相同方法调用的区别："></a>Channel和ChannelHandlerContext相同方法调用的区别：</h4><p>Channel和ChannelHandlerContext有一些共同的方法，但是它们的调用存在一些差别：</p>
<ul>
<li>如果调用Channel或者ChannelPipeline上的这些方法，它们将沿着整个ChannelPipeline进行传播；</li>
<li>而如果调用位于ChannelHandlerContext上的这些相同方法，就会从ctx关联的ChannelHandler开始，并且只会传播给位于该ChannelPipeline中的下一个能够处理这个事件的ChannelHandler。  </li>
</ul>
<h3 id="三、ServerBootstrap和Bootstrap"><a href="#三、ServerBootstrap和Bootstrap" class="headerlink" title="三、ServerBootstrap和Bootstrap"></a>三、ServerBootstrap和Bootstrap</h3><p>Netty的引导类主要为应用程序提供了网络层的配置。对于服务端，涉及到将一个进程绑定到某个指定的端口；对于客户端，涉及到将一个进程连接到另一个运行在某个指定主机的指定端口上的进程。分为ServerBootstrap和Bootstrap这两种引导类。    </p>
<p>这两个是两种类型的引导：一个用于客户端（Bootstrap），一个用于服务器（ServerBootstrap），无论你的应用程序是使用哪种协议或者处理哪种类型的数据，唯一决定它该使用哪种引导类的是它是客户端还是服务端。  </p>
<p>两者最大的区别在于：引导一个客户端只需要一个EventLoopGroup，但是引导一个服务端需要两个EventLoopGroup，这是为什么呢？<br>原因在于服务器需要两组不同的Channel，第一组只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字Socket；而第二组将包含所有已创建的用来处理传入客户端连接的Channel。  </p>
<p><img src="http://osrmzp0jr.bkt.clouddn.com/evenloop_meitu_2.jpg" alt="image">  </p>
<p>与ServerChannel相关联的EventLoopGroup将分配一个为传入连接请求创建Channel的EventLoop，一旦连接被接收，第二个EventLoopGroup就会给它的Channel分配一个EventLoop。</p>
</div><div class="tags"><a href="/tags/Netty/">Netty</a></div><div class="post-nav"><a class="pre" href="/2018/06/16/Netty之EventLoop与线程模型 /">Netty之EventLoop与线程模型</a><a class="next" href="/2018/06/14/Netty之构建Netty应用程序/">Netty之构建Netty应用程序</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring源码解析/">Spring源码解析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java并发/">java并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式系统/">分布式系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/剑指offer/">剑指offer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/大型网站技术架构核心原理/">大型网站技术架构核心原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/深入理解Java虚拟机/">深入理解Java虚拟机</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/算法，剑指offer/" style="font-size: 15px;">算法，剑指offer</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/java并发/" style="font-size: 15px;">java并发</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/tags/java，java基础/" style="font-size: 15px;">java，java基础</a> <a href="/tags/java虚拟机/" style="font-size: 15px;">java虚拟机</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/AQS/" style="font-size: 15px;">AQS</a> <a href="/tags/大型网站技术架构/" style="font-size: 15px;">大型网站技术架构</a> <a href="/tags/分布式系统/" style="font-size: 15px;">分布式系统</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/14/Spring源码解析之AOP设计与实现/">Spring源码解析之AOP设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/负载均衡那些事/">负载均衡那些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/16/Netty之EventLoop与线程模型 /">Netty之EventLoop与线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/15/Netty 之组件与设计 /">Netty之组件与设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/Netty之构建Netty应用程序/">Netty之构建Netty应用程序</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/Netty剖析之核心组件/">Netty剖析之核心组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/11/Spring源码解析之IOC容器（二）/">Spring源码解析之IOC容器（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/Spring源码解析之IOC容器（一）/">Spring源码解析之IOC容器（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/16/谈谈分布式事务/">谈谈分布式事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/12/浅谈分库分表/">浅谈分库分表</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a><ul></ul><a href="https://coolshell.cn/" title="陈皓" target="_blank">陈皓</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Wunian's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>